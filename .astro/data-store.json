[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.13.3","content-config-digest","d35ab36223815803","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"where\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":false,\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[null,null,null],\"rehypePlugins\":[null,[null,{\"experimentalHeadingIdCompat\":false}],null,[null,{\"themes\":[{\"name\":\"Night Owl No Italics\",\"type\":\"dark\",\"colors\":{\"focusBorder\":\"#122d42\",\"foreground\":\"#d6deeb\",\"disabledForeground\":\"#cccccc80\",\"descriptionForeground\":\"#d6deebb3\",\"errorForeground\":\"#ef5350\",\"icon.foreground\":\"#c5c5c5\",\"contrastActiveBorder\":null,\"contrastBorder\":\"#122d42\",\"textBlockQuote.background\":\"#7f7f7f1a\",\"textBlockQuote.border\":\"#007acc80\",\"textCodeBlock.background\":\"#4f4f4f\",\"textLink.activeForeground\":\"#3794ff\",\"textLink.foreground\":\"#3794ff\",\"textPreformat.foreground\":\"#d7ba7d\",\"textSeparator.foreground\":\"#ffffff2e\",\"editor.background\":\"#23262f\",\"editor.foreground\":\"#d6deeb\",\"editorLineNumber.foreground\":\"#4b6479\",\"editorLineNumber.activeForeground\":\"#c5e4fd\",\"editorActiveLineNumber.foreground\":\"#c6c6c6\",\"editor.selectionBackground\":\"#1d3b53\",\"editor.inactiveSelectionBackground\":\"#7e57c25a\",\"editor.selectionHighlightBackground\":\"#5f7e9779\",\"editorError.foreground\":\"#ef5350\",\"editorWarning.foreground\":\"#b39554\",\"editorInfo.foreground\":\"#3794ff\",\"editorHint.foreground\":\"#eeeeeeb2\",\"problemsErrorIcon.foreground\":\"#ef5350\",\"problemsWarningIcon.foreground\":\"#b39554\",\"problemsInfoIcon.foreground\":\"#3794ff\",\"editor.findMatchBackground\":\"#5f7e9779\",\"editor.findMatchHighlightBackground\":\"#1085bb5d\",\"editor.findRangeHighlightBackground\":\"#3a3d4166\",\"editorLink.activeForeground\":\"#4e94ce\",\"editorLightBulb.foreground\":\"#ffcc00\",\"editorLightBulbAutoFix.foreground\":\"#75beff\",\"diffEditor.insertedTextBackground\":\"#99b76d23\",\"diffEditor.insertedTextBorder\":\"#c5e47833\",\"diffEditor.removedTextBackground\":\"#ef535033\",\"diffEditor.removedTextBorder\":\"#ef53504d\",\"diffEditor.insertedLineBackground\":\"#9bb95533\",\"diffEditor.removedLineBackground\":\"#ff000033\",\"editorStickyScroll.background\":\"#011627\",\"editorStickyScrollHover.background\":\"#2a2d2e\",\"editorInlayHint.background\":\"#5f7e97cc\",\"editorInlayHint.foreground\":\"#ffffff\",\"editorInlayHint.typeBackground\":\"#5f7e97cc\",\"editorInlayHint.typeForeground\":\"#ffffff\",\"editorInlayHint.parameterBackground\":\"#5f7e97cc\",\"editorInlayHint.parameterForeground\":\"#ffffff\",\"editorPane.background\":\"#011627\",\"editorGroup.emptyBackground\":\"#011627\",\"editorGroup.focusedEmptyBorder\":null,\"editorGroupHeader.tabsBackground\":\"var(--sl-color-black)\",\"editorGroupHeader.tabsBorder\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"editorGroupHeader.noTabsBackground\":\"#011627\",\"editorGroupHeader.border\":null,\"editorGroup.border\":\"#011627\",\"editorGroup.dropBackground\":\"#7e57c273\",\"editorGroup.dropIntoPromptForeground\":\"#d6deeb\",\"editorGroup.dropIntoPromptBackground\":\"#021320\",\"editorGroup.dropIntoPromptBorder\":null,\"sideBySideEditor.horizontalBorder\":\"#011627\",\"sideBySideEditor.verticalBorder\":\"#011627\",\"scrollbar.shadow\":\"#010b14\",\"scrollbarSlider.background\":\"#ffffff17\",\"scrollbarSlider.hoverBackground\":\"#ffffff40\",\"scrollbarSlider.activeBackground\":\"#084d8180\",\"panel.background\":\"#011627\",\"panel.border\":\"#5f7e97\",\"panelTitle.activeBorder\":\"#5f7e97\",\"panelTitle.activeForeground\":\"#ffffffcc\",\"panelTitle.inactiveForeground\":\"#d6deeb80\",\"panelSectionHeader.background\":\"#80808051\",\"terminal.background\":\"#011627\",\"widget.shadow\":\"#011627\",\"editorWidget.background\":\"#021320\",\"editorWidget.foreground\":\"#d6deeb\",\"editorWidget.border\":\"#5f7e97\",\"quickInput.background\":\"#021320\",\"quickInput.foreground\":\"#d6deeb\",\"quickInputTitle.background\":\"#ffffff1a\",\"pickerGroup.foreground\":\"#d1aaff\",\"pickerGroup.border\":\"#011627\",\"editor.hoverHighlightBackground\":\"#7e57c25a\",\"editorHoverWidget.background\":\"#011627\",\"editorHoverWidget.foreground\":\"#d6deeb\",\"editorHoverWidget.border\":\"#5f7e97\",\"editorHoverWidget.statusBarBackground\":\"#011a2f\",\"titleBar.activeBackground\":\"var(--sl-color-black)\",\"titleBar.activeForeground\":\"var(--sl-color-text)\",\"titleBar.inactiveBackground\":\"#010e1a\",\"titleBar.inactiveForeground\":\"#eeefff99\",\"titleBar.border\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"toolbar.hoverBackground\":\"#5a5d5e50\",\"toolbar.activeBackground\":\"#63666750\",\"tab.activeBackground\":\"#0b2942\",\"tab.unfocusedActiveBackground\":\"#0b2942\",\"tab.inactiveBackground\":\"#01111d\",\"tab.unfocusedInactiveBackground\":\"#01111d\",\"tab.activeForeground\":\"var(--sl-color-text)\",\"tab.inactiveForeground\":\"#5f7e97\",\"tab.unfocusedActiveForeground\":\"#5f7e97\",\"tab.unfocusedInactiveForeground\":\"#5f7e97\",\"tab.hoverBackground\":null,\"tab.unfocusedHoverBackground\":null,\"tab.hoverForeground\":null,\"tab.unfocusedHoverForeground\":null,\"tab.border\":\"#272b3b\",\"tab.lastPinnedBorder\":\"#585858\",\"tab.activeBorder\":\"transparent\",\"tab.unfocusedActiveBorder\":\"#262a39\",\"tab.activeBorderTop\":\"var(--sl-color-accent-high)\",\"tab.unfocusedActiveBorderTop\":null,\"tab.hoverBorder\":null,\"tab.unfocusedHoverBorder\":null,\"tab.activeModifiedBorder\":\"#3399cc\",\"tab.inactiveModifiedBorder\":\"#3399cc80\",\"tab.unfocusedActiveModifiedBorder\":\"#3399cc80\",\"tab.unfocusedInactiveModifiedBorder\":\"#3399cc40\",\"badge.background\":\"#5f7e97\",\"badge.foreground\":\"#ffffff\",\"button.background\":\"#7e57c2cc\",\"button.foreground\":\"#ffffffcc\",\"button.border\":\"#122d42\",\"button.separator\":\"#ffffff52\",\"button.hoverBackground\":\"#7e57c2\",\"button.secondaryBackground\":\"#3a3d41\",\"button.secondaryForeground\":\"#ffffff\",\"button.secondaryHoverBackground\":\"#46494e\",\"dropdown.background\":\"#011627\",\"dropdown.foreground\":\"#ffffffcc\",\"dropdown.border\":\"#5f7e97\",\"list.activeSelectionBackground\":\"#234d708c\",\"list.activeSelectionForeground\":\"#ffffff\",\"tree.indentGuidesStroke\":\"#585858\",\"input.background\":\"#0b253a\",\"input.foreground\":\"#ffffffcc\",\"input.placeholderForeground\":\"#5f7e97\",\"inputOption.activeBorder\":\"#ffffffcc\",\"inputOption.hoverBackground\":\"#5a5d5e80\",\"inputOption.activeBackground\":\"#122d4266\",\"inputOption.activeForeground\":\"#ffffff\",\"inputValidation.infoBackground\":\"#00589ef2\",\"inputValidation.infoBorder\":\"#64b5f6\",\"inputValidation.warningBackground\":\"#675700f2\",\"inputValidation.warningBorder\":\"#ffca28\",\"inputValidation.errorBackground\":\"#ab0300f2\",\"inputValidation.errorBorder\":\"#ef5350\",\"keybindingLabel.background\":\"#8080802b\",\"keybindingLabel.foreground\":\"#cccccc\",\"keybindingLabel.border\":\"#33333399\",\"keybindingLabel.bottomBorder\":\"#44444499\",\"menu.foreground\":\"#ffffffcc\",\"menu.background\":\"#011627\",\"menu.selectionForeground\":\"#ffffff\",\"menu.selectionBackground\":\"#234d708c\",\"menu.separatorBackground\":\"#606060\",\"editor.snippetTabstopHighlightBackground\":\"#7c7c74c\",\"editor.snippetFinalTabstopHighlightBorder\":\"#525252\",\"terminal.ansiBlack\":\"#011627\",\"terminal.ansiRed\":\"#ef5350\",\"terminal.ansiGreen\":\"#22da6e\",\"terminal.ansiYellow\":\"#c5e478\",\"terminal.ansiBlue\":\"#82aaff\",\"terminal.ansiMagenta\":\"#c792ea\",\"terminal.ansiCyan\":\"#21c7a8\",\"terminal.ansiWhite\":\"#ffffff\",\"terminal.ansiBrightBlack\":\"#575656\",\"terminal.ansiBrightRed\":\"#ef5350\",\"terminal.ansiBrightGreen\":\"#22da6e\",\"terminal.ansiBrightYellow\":\"#ffeb95\",\"terminal.ansiBrightBlue\":\"#82aaff\",\"terminal.ansiBrightMagenta\":\"#c792ea\",\"terminal.ansiBrightCyan\":\"#7fdbca\",\"terminal.ansiBrightWhite\":\"#ffffff\",\"selection.background\":\"#4373c2\",\"input.border\":\"#5f7e97\",\"punctuation.definition.generic.begin.html\":\"#ef5350f2\",\"progress.background\":\"#7e57c2\",\"breadcrumb.foreground\":\"#a599e9\",\"breadcrumb.focusForeground\":\"#ffffff\",\"breadcrumb.activeSelectionForeground\":\"#ffffff\",\"breadcrumbPicker.background\":\"#001122\",\"list.invalidItemForeground\":\"#975f94\",\"list.dropBackground\":\"#011627\",\"list.focusBackground\":\"#010d18\",\"list.focusForeground\":\"#ffffff\",\"list.highlightForeground\":\"#ffffff\",\"list.hoverBackground\":\"#011627\",\"list.hoverForeground\":\"#ffffff\",\"list.inactiveSelectionBackground\":\"#0e293f\",\"list.inactiveSelectionForeground\":\"#5f7e97\",\"activityBar.background\":\"#011627\",\"activityBar.dropBackground\":\"#5f7e97\",\"activityBar.foreground\":\"#5f7e97\",\"activityBar.border\":\"#011627\",\"activityBarBadge.background\":\"#44596b\",\"activityBarBadge.foreground\":\"#ffffff\",\"sideBar.background\":\"#011627\",\"sideBar.foreground\":\"#89a4bb\",\"sideBar.border\":\"#011627\",\"sideBarTitle.foreground\":\"#5f7e97\",\"sideBarSectionHeader.background\":\"#011627\",\"sideBarSectionHeader.foreground\":\"#5f7e97\",\"editorCursor.foreground\":\"#80a4c2\",\"editor.wordHighlightBackground\":\"#f6bbe533\",\"editor.wordHighlightStrongBackground\":\"#e2a2f433\",\"editor.lineHighlightBackground\":\"#0003\",\"editor.rangeHighlightBackground\":\"#7e57c25a\",\"editorIndentGuide.background\":\"#5e81ce52\",\"editorIndentGuide.activeBackground\":\"#7e97ac\",\"editorRuler.foreground\":\"#5e81ce52\",\"editorCodeLens.foreground\":\"#5e82ceb4\",\"editorBracketMatch.background\":\"#5f7e974d\",\"editorOverviewRuler.currentContentForeground\":\"#7e57c2\",\"editorOverviewRuler.incomingContentForeground\":\"#7e57c2\",\"editorOverviewRuler.commonContentForeground\":\"#7e57c2\",\"editorGutter.background\":\"#011627\",\"editorGutter.modifiedBackground\":\"#e2b93d\",\"editorGutter.addedBackground\":\"#9ccc65\",\"editorGutter.deletedBackground\":\"#ef5350\",\"editorSuggestWidget.background\":\"#2c3043\",\"editorSuggestWidget.border\":\"#2b2f40\",\"editorSuggestWidget.foreground\":\"#d6deeb\",\"editorSuggestWidget.highlightForeground\":\"#ffffff\",\"editorSuggestWidget.selectedBackground\":\"#5f7e97\",\"debugExceptionWidget.background\":\"#011627\",\"debugExceptionWidget.border\":\"#5f7e97\",\"editorMarkerNavigation.background\":\"#0b2942\",\"editorMarkerNavigationError.background\":\"#ef5350\",\"editorMarkerNavigationWarning.background\":\"#ffca28\",\"peekView.border\":\"#5f7e97\",\"peekViewEditor.background\":\"#011627\",\"peekViewEditor.matchHighlightBackground\":\"#7e57c25a\",\"peekViewResult.background\":\"#011627\",\"peekViewResult.fileForeground\":\"#5f7e97\",\"peekViewResult.lineForeground\":\"#5f7e97\",\"peekViewResult.matchHighlightBackground\":\"#ffffffcc\",\"peekViewResult.selectionBackground\":\"#2e3250\",\"peekViewResult.selectionForeground\":\"#5f7e97\",\"peekViewTitle.background\":\"#011627\",\"peekViewTitleDescription.foreground\":\"#697098\",\"peekViewTitleLabel.foreground\":\"#5f7e97\",\"merge.currentHeaderBackground\":\"#5f7e97\",\"merge.incomingHeaderBackground\":\"#7e57c25a\",\"statusBar.background\":\"#011627\",\"statusBar.foreground\":\"#5f7e97\",\"statusBar.border\":\"#262a39\",\"statusBar.debuggingBackground\":\"#202431\",\"statusBar.debuggingBorder\":\"#1f2330\",\"statusBar.noFolderBackground\":\"#011627\",\"statusBar.noFolderBorder\":\"#25293a\",\"statusBarItem.activeBackground\":\"#202431\",\"statusBarItem.hoverBackground\":\"#202431\",\"statusBarItem.prominentBackground\":\"#202431\",\"statusBarItem.prominentHoverBackground\":\"#202431\",\"notifications.background\":\"#01111d\",\"notifications.border\":\"#262a39\",\"notificationCenter.border\":\"#262a39\",\"notificationToast.border\":\"#262a39\",\"notifications.foreground\":\"#ffffffcc\",\"notificationLink.foreground\":\"#80cbc4\",\"extensionButton.prominentForeground\":\"#ffffffcc\",\"extensionButton.prominentBackground\":\"#7e57c2cc\",\"extensionButton.prominentHoverBackground\":\"#7e57c2\",\"terminal.selectionBackground\":\"#1b90dd4d\",\"terminalCursor.background\":\"#234d70\",\"debugToolBar.background\":\"#011627\",\"welcomePage.buttonBackground\":\"#011627\",\"welcomePage.buttonHoverBackground\":\"#011627\",\"walkThrough.embeddedEditorBackground\":\"#011627\",\"gitDecoration.modifiedResourceForeground\":\"#a2bffc\",\"gitDecoration.deletedResourceForeground\":\"#ef535090\",\"gitDecoration.untrackedResourceForeground\":\"#c5e478ff\",\"gitDecoration.ignoredResourceForeground\":\"#395a75\",\"gitDecoration.conflictingResourceForeground\":\"#ffeb95cc\",\"source.elm\":\"#5f7e97\",\"string.quoted.single.js\":\"#ffffff\",\"meta.objectliteral.js\":\"#82aaff\"},\"fg\":\"#d6deeb\",\"bg\":\"#23262f\",\"semanticHighlighting\":false,\"settings\":[{\"name\":\"Changed\",\"scope\":[\"markup.changed\",\"meta.diff.header.git\",\"meta.diff.header.from-file\",\"meta.diff.header.to-file\"],\"settings\":{\"foreground\":\"#a2bffc\"}},{\"name\":\"Deleted\",\"scope\":[\"markup.deleted.diff\"],\"settings\":{\"foreground\":\"#f27775fe\"}},{\"name\":\"Inserted\",\"scope\":[\"markup.inserted.diff\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Global settings\",\"settings\":{\"background\":\"#011627\",\"foreground\":\"#d6deeb\"}},{\"name\":\"Comment\",\"scope\":[\"comment\"],\"settings\":{\"foreground\":\"#919f9f\",\"fontStyle\":\"\"}},{\"name\":\"String\",\"scope\":[\"string\"],\"settings\":{\"foreground\":\"#ecc48d\"}},{\"name\":\"String Quoted\",\"scope\":[\"string.quoted\",\"variable.other.readwrite.js\"],\"settings\":{\"foreground\":\"#ecc48d\"}},{\"name\":\"Support Constant Math\",\"scope\":[\"support.constant.math\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Number\",\"scope\":[\"constant.numeric\",\"constant.character.numeric\"],\"settings\":{\"foreground\":\"#f78c6c\",\"fontStyle\":\"\"}},{\"name\":\"Built-in constant\",\"scope\":[\"constant.language\",\"punctuation.definition.constant\",\"variable.other.constant\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"User-defined constant\",\"scope\":[\"constant.character\",\"constant.other\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Constant Character Escape\",\"scope\":[\"constant.character.escape\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"RegExp String\",\"scope\":[\"string.regexp\",\"string.regexp keyword.other\"],\"settings\":{\"foreground\":\"#5ca7e4\"}},{\"name\":\"Comma in functions\",\"scope\":[\"meta.function punctuation.separator.comma\"],\"settings\":{\"foreground\":\"#889fb2\"}},{\"name\":\"Variable\",\"scope\":[\"variable\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Keyword\",\"scope\":[\"punctuation.accessor\",\"keyword\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Storage\",\"scope\":[\"storage\",\"meta.var.expr\",\"meta.class meta.method.declaration meta.var.expr storage.type.js\",\"storage.type.property.js\",\"storage.type.property.ts\",\"storage.type.property.tsx\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Storage type\",\"scope\":[\"storage.type\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Storage type\",\"scope\":[\"storage.type.function.arrow.js\"],\"settings\":{\"fontStyle\":\"\"}},{\"name\":\"Class name\",\"scope\":[\"entity.name.class\",\"meta.class entity.name.type.class\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Inherited class\",\"scope\":[\"entity.other.inherited-class\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Function name\",\"scope\":[\"entity.name.function\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Meta Tag\",\"scope\":[\"punctuation.definition.tag\",\"meta.tag\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"HTML Tag names\",\"scope\":[\"entity.name.tag\",\"meta.tag.other.html\",\"meta.tag.other.js\",\"meta.tag.other.tsx\",\"entity.name.tag.tsx\",\"entity.name.tag.js\",\"entity.name.tag\",\"meta.tag.js\",\"meta.tag.tsx\",\"meta.tag.html\"],\"settings\":{\"foreground\":\"#caece6\",\"fontStyle\":\"\"}},{\"name\":\"Tag attribute\",\"scope\":[\"entity.other.attribute-name\"],\"settings\":{\"fontStyle\":\"\",\"foreground\":\"#c5e478\"}},{\"name\":\"Entity Name Tag Custom\",\"scope\":[\"entity.name.tag.custom\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Library (function & constant)\",\"scope\":[\"support.function\",\"support.constant\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Support Constant Property Value meta\",\"scope\":[\"support.constant.meta.property-value\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Library class/type\",\"scope\":[\"support.type\",\"support.class\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Support Variable DOM\",\"scope\":[\"support.variable.dom\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Invalid\",\"scope\":[\"invalid\"],\"settings\":{\"background\":\"#ff2c83\",\"foreground\":\"#ffffff\"}},{\"name\":\"Invalid deprecated\",\"scope\":[\"invalid.deprecated\"],\"settings\":{\"foreground\":\"#ffffff\",\"background\":\"#d3423e\"}},{\"name\":\"Keyword Operator\",\"scope\":[\"keyword.operator\"],\"settings\":{\"foreground\":\"#7fdbca\",\"fontStyle\":\"\"}},{\"name\":\"Keyword Operator Relational\",\"scope\":[\"keyword.operator.relational\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Keyword Operator Assignment\",\"scope\":[\"keyword.operator.assignment\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Keyword Operator Arithmetic\",\"scope\":[\"keyword.operator.arithmetic\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Keyword Operator Bitwise\",\"scope\":[\"keyword.operator.bitwise\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Keyword Operator Increment\",\"scope\":[\"keyword.operator.increment\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Keyword Operator Ternary\",\"scope\":[\"keyword.operator.ternary\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Double-Slashed Comment\",\"scope\":[\"comment.line.double-slash\"],\"settings\":{\"foreground\":\"#919f9f\"}},{\"name\":\"Object\",\"scope\":[\"object\"],\"settings\":{\"foreground\":\"#cdebf7\"}},{\"name\":\"Null\",\"scope\":[\"constant.language.null\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"Meta Brace\",\"scope\":[\"meta.brace\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Meta Delimiter Period\",\"scope\":[\"meta.delimiter.period\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Punctuation Definition String\",\"scope\":[\"punctuation.definition.string\"],\"settings\":{\"foreground\":\"#d9f5dd\"}},{\"name\":\"Punctuation Definition String Markdown\",\"scope\":[\"punctuation.definition.string.begin.markdown\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"Boolean\",\"scope\":[\"constant.language.boolean\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"Object Comma\",\"scope\":[\"object.comma\"],\"settings\":{\"foreground\":\"#ffffff\"}},{\"name\":\"Variable Parameter Function\",\"scope\":[\"variable.parameter.function\"],\"settings\":{\"foreground\":\"#7fdbca\",\"fontStyle\":\"\"}},{\"name\":\"Support Type Property Name & entity name tags\",\"scope\":[\"support.type.vendor.property-name\",\"support.constant.vendor.property-value\",\"support.type.property-name\",\"meta.property-list entity.name.tag\"],\"settings\":{\"foreground\":\"#80cbc4\",\"fontStyle\":\"\"}},{\"name\":\"Entity Name tag reference in stylesheets\",\"scope\":[\"meta.property-list entity.name.tag.reference\"],\"settings\":{\"foreground\":\"#57eaf1\"}},{\"name\":\"Constant Other Color RGB Value Punctuation Definition Constant\",\"scope\":[\"constant.other.color.rgb-value punctuation.definition.constant\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"Constant Other Color\",\"scope\":[\"constant.other.color\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"Keyword Other Unit\",\"scope\":[\"keyword.other.unit\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"Meta Selector\",\"scope\":[\"meta.selector\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Entity Other Attribute Name Id\",\"scope\":[\"entity.other.attribute-name.id\"],\"settings\":{\"foreground\":\"#fad430\"}},{\"name\":\"Meta Property Name\",\"scope\":[\"meta.property-name\"],\"settings\":{\"foreground\":\"#80cbc4\"}},{\"name\":\"Doctypes\",\"scope\":[\"entity.name.tag.doctype\",\"meta.tag.sgml.doctype\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Punctuation Definition Parameters\",\"scope\":[\"punctuation.definition.parameters\"],\"settings\":{\"foreground\":\"#d9f5dd\"}},{\"name\":\"Keyword Control Operator\",\"scope\":[\"keyword.control.operator\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Keyword Operator Logical\",\"scope\":[\"keyword.operator.logical\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Variable Instances\",\"scope\":[\"variable.instance\",\"variable.other.instance\",\"variable.readwrite.instance\",\"variable.other.readwrite.instance\",\"variable.other.property\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Variable Property Other object property\",\"scope\":[\"variable.other.object.property\"],\"settings\":{\"foreground\":\"#faf39f\",\"fontStyle\":\"\"}},{\"name\":\"Variable Property Other object\",\"scope\":[\"variable.other.object.js\"],\"settings\":{\"fontStyle\":\"\"}},{\"name\":\"Entity Name Function\",\"scope\":[\"entity.name.function\"],\"settings\":{\"foreground\":\"#82aaff\",\"fontStyle\":\"\"}},{\"name\":\"Keyword Operator Comparison, returns, imports, and Keyword Operator Ruby\",\"scope\":[\"keyword.control.conditional.js\",\"keyword.operator.comparison\",\"keyword.control.flow.js\",\"keyword.control.flow.ts\",\"keyword.control.flow.tsx\",\"keyword.control.ruby\",\"keyword.control.def.ruby\",\"keyword.control.loop.js\",\"keyword.control.loop.ts\",\"keyword.control.import.js\",\"keyword.control.import.ts\",\"keyword.control.import.tsx\",\"keyword.control.from.js\",\"keyword.control.from.ts\",\"keyword.control.from.tsx\",\"keyword.control.conditional.js\",\"keyword.control.conditional.ts\",\"keyword.control.switch.js\",\"keyword.control.switch.ts\",\"keyword.operator.instanceof.js\",\"keyword.operator.expression.instanceof.ts\",\"keyword.operator.expression.instanceof.tsx\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Support Constant, `new` keyword, Special Method Keyword, `debugger`, other keywords\",\"scope\":[\"support.constant\",\"keyword.other.special-method\",\"keyword.other.new\",\"keyword.other.debugger\",\"keyword.control\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Support Function\",\"scope\":[\"support.function\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Invalid Broken\",\"scope\":[\"invalid.broken\"],\"settings\":{\"foreground\":\"#989da0\",\"background\":\"#F78C6C\"}},{\"name\":\"Invalid Unimplemented\",\"scope\":[\"invalid.unimplemented\"],\"settings\":{\"background\":\"#8BD649\",\"foreground\":\"#ffffff\"}},{\"name\":\"Invalid Illegal\",\"scope\":[\"invalid.illegal\"],\"settings\":{\"foreground\":\"#ffffff\",\"background\":\"#ec5f67\"}},{\"name\":\"Language Variable\",\"scope\":[\"variable.language\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Support Variable Property\",\"scope\":[\"support.variable.property\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Variable Function\",\"scope\":[\"variable.function\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Variable Interpolation\",\"scope\":[\"variable.interpolation\"],\"settings\":{\"foreground\":\"#ef787f\"}},{\"name\":\"Meta Function Call\",\"scope\":[\"meta.function-call\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Punctuation Section Embedded\",\"scope\":[\"punctuation.section.embedded\"],\"settings\":{\"foreground\":\"#e2817f\"}},{\"name\":\"Punctuation Tweaks\",\"scope\":[\"punctuation.terminator.expression\",\"punctuation.definition.arguments\",\"punctuation.definition.array\",\"punctuation.section.array\",\"meta.array\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"More Punctuation Tweaks\",\"scope\":[\"punctuation.definition.list.begin\",\"punctuation.definition.list.end\",\"punctuation.separator.arguments\",\"punctuation.definition.list\"],\"settings\":{\"foreground\":\"#d9f5dd\"}},{\"name\":\"Template Strings\",\"scope\":[\"string.template meta.template.expression\"],\"settings\":{\"foreground\":\"#e2817f\"}},{\"name\":\"Backtics(``) in Template Strings\",\"scope\":[\"string.template punctuation.definition.string\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Italics\",\"scope\":[\"italic\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"italic\"}},{\"name\":\"Bold\",\"scope\":[\"bold\"],\"settings\":{\"foreground\":\"#c5e478\",\"fontStyle\":\"bold\"}},{\"name\":\"Quote\",\"scope\":[\"quote\"],\"settings\":{\"foreground\":\"#969bb7\",\"fontStyle\":\"\"}},{\"name\":\"Raw Code\",\"scope\":[\"raw\"],\"settings\":{\"foreground\":\"#80cbc4\"}},{\"name\":\"CoffeScript Variable Assignment\",\"scope\":[\"variable.assignment.coffee\"],\"settings\":{\"foreground\":\"#31e1eb\"}},{\"name\":\"CoffeScript Parameter Function\",\"scope\":[\"variable.parameter.function.coffee\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"CoffeeScript Assignments\",\"scope\":[\"variable.assignment.coffee\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"C# Readwrite Variables\",\"scope\":[\"variable.other.readwrite.cs\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"C# Classes & Storage types\",\"scope\":[\"entity.name.type.class.cs\",\"storage.type.cs\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"C# Namespaces\",\"scope\":[\"entity.name.type.namespace.cs\"],\"settings\":{\"foreground\":\"#b2ccd6\"}},{\"name\":\"C# Unquoted String Zone\",\"scope\":[\"string.unquoted.preprocessor.message.cs\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"C# Region\",\"scope\":[\"punctuation.separator.hash.cs\",\"keyword.preprocessor.region.cs\",\"keyword.preprocessor.endregion.cs\"],\"settings\":{\"foreground\":\"#ffcb8b\",\"fontStyle\":\"bold\"}},{\"name\":\"C# Other Variables\",\"scope\":[\"variable.other.object.cs\"],\"settings\":{\"foreground\":\"#b2ccd6\"}},{\"name\":\"C# Enum\",\"scope\":[\"entity.name.type.enum.cs\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Dart String\",\"scope\":[\"string.interpolated.single.dart\",\"string.interpolated.double.dart\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Dart Class\",\"scope\":[\"support.class.dart\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Tag names in Stylesheets\",\"scope\":[\"entity.name.tag.css\",\"entity.name.tag.less\",\"entity.name.tag.custom.css\",\"support.constant.property-value.css\"],\"settings\":{\"foreground\":\"#ff6d6d\",\"fontStyle\":\"\"}},{\"name\":\"Wildcard(*) selector in Stylesheets\",\"scope\":[\"entity.name.tag.wildcard.css\",\"entity.name.tag.wildcard.less\",\"entity.name.tag.wildcard.scss\",\"entity.name.tag.wildcard.sass\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"CSS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.css\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"Attribute Name for CSS\",\"scope\":[\"meta.attribute-selector.css entity.other.attribute-name.attribute\",\"variable.other.readwrite.js\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"Elixir Classes\",\"scope\":[\"source.elixir support.type.elixir\",\"source.elixir meta.module.elixir entity.name.class.elixir\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Elixir Functions\",\"scope\":[\"source.elixir entity.name.function\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Elixir Constants\",\"scope\":[\"source.elixir constant.other.symbol.elixir\",\"source.elixir constant.other.keywords.elixir\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Elixir String Punctuations\",\"scope\":[\"source.elixir punctuation.definition.string\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Elixir\",\"scope\":[\"source.elixir variable.other.readwrite.module.elixir\",\"source.elixir variable.other.readwrite.module.elixir punctuation.definition.variable.elixir\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Elixir Binary Punctuations\",\"scope\":[\"source.elixir .punctuation.binary.elixir\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"Closure Constant Keyword\",\"scope\":[\"constant.keyword.clojure\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Go Function Calls\",\"scope\":[\"source.go meta.function-call.go\"],\"settings\":{\"foreground\":\"#dddddd\"}},{\"name\":\"Go Keywords\",\"scope\":[\"source.go keyword.package.go\",\"source.go keyword.import.go\",\"source.go keyword.function.go\",\"source.go keyword.type.go\",\"source.go keyword.struct.go\",\"source.go keyword.interface.go\",\"source.go keyword.const.go\",\"source.go keyword.var.go\",\"source.go keyword.map.go\",\"source.go keyword.channel.go\",\"source.go keyword.control.go\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"Go Constants e.g. nil, string format (%s, %d, etc.)\",\"scope\":[\"source.go constant.language.go\",\"source.go constant.other.placeholder.go\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"C++ Functions\",\"scope\":[\"entity.name.function.preprocessor.cpp\",\"entity.scope.name.cpp\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"C++ Meta Namespace\",\"scope\":[\"meta.namespace-block.cpp\"],\"settings\":{\"foreground\":\"#e0dec6\"}},{\"name\":\"C++ Language Primitive Storage\",\"scope\":[\"storage.type.language.primitive.cpp\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"C++ Preprocessor Macro\",\"scope\":[\"meta.preprocessor.macro.cpp\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"C++ Variable Parameter\",\"scope\":[\"variable.parameter\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Powershell Variables\",\"scope\":[\"variable.other.readwrite.powershell\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Powershell Function\",\"scope\":[\"support.function.powershell\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"ID Attribute Name in HTML\",\"scope\":[\"entity.other.attribute-name.id.html\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"HTML Punctuation Definition Tag\",\"scope\":[\"punctuation.definition.tag.html\"],\"settings\":{\"foreground\":\"#6ae9f0\"}},{\"name\":\"HTML Doctype\",\"scope\":[\"meta.tag.sgml.doctype.html\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"\"}},{\"name\":\"JavaScript Classes\",\"scope\":[\"meta.class entity.name.type.class.js\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"JavaScript Method Declaration e.g. `constructor`\",\"scope\":[\"meta.method.declaration storage.type.js\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"JavaScript Terminator\",\"scope\":[\"terminator.js\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JavaScript Meta Punctuation Definition\",\"scope\":[\"meta.js punctuation.definition.js\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Entity Names in Code Documentations\",\"scope\":[\"entity.name.type.instance.jsdoc\",\"entity.name.type.instance.phpdoc\"],\"settings\":{\"foreground\":\"#889fb2\"}},{\"name\":\"Other Variables in Code Documentations\",\"scope\":[\"variable.other.jsdoc\",\"variable.other.phpdoc\"],\"settings\":{\"foreground\":\"#78ccf0\"}},{\"name\":\"JavaScript module imports and exports\",\"scope\":[\"variable.other.meta.import.js\",\"meta.import.js variable.other\",\"variable.other.meta.export.js\",\"meta.export.js variable.other\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JavaScript Variable Parameter Function\",\"scope\":[\"variable.parameter.function.js\"],\"settings\":{\"foreground\":\"#8b96ea\"}},{\"name\":\"JavaScript[React] Variable Other Object\",\"scope\":[\"variable.other.object.js\",\"variable.other.object.jsx\",\"variable.object.property.js\",\"variable.object.property.jsx\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JavaScript Variables\",\"scope\":[\"variable.js\",\"variable.other.js\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JavaScript Entity Name Type\",\"scope\":[\"entity.name.type.js\",\"entity.name.type.module.js\"],\"settings\":{\"foreground\":\"#ffcb8b\",\"fontStyle\":\"\"}},{\"name\":\"JavaScript Support Classes\",\"scope\":[\"support.class.js\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"JSON Property Names\",\"scope\":[\"support.type.property-name.json\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"JSON Support Constants\",\"scope\":[\"support.constant.json\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"JSON Property values (string)\",\"scope\":[\"meta.structure.dictionary.value.json string.quoted.double\"],\"settings\":{\"foreground\":\"#c789d6\"}},{\"name\":\"Strings in JSON values\",\"scope\":[\"string.quoted.double.json punctuation.definition.string.json\"],\"settings\":{\"foreground\":\"#80cbc4\"}},{\"name\":\"Specific JSON Property values like null\",\"scope\":[\"meta.structure.dictionary.json meta.structure.dictionary.value constant.language\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"JavaScript Other Variable\",\"scope\":[\"variable.other.object.js\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Ruby Variables\",\"scope\":[\"variable.other.ruby\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Ruby Class\",\"scope\":[\"entity.name.type.class.ruby\"],\"settings\":{\"foreground\":\"#ecc48d\"}},{\"name\":\"Ruby Hashkeys\",\"scope\":[\"constant.language.symbol.hashkey.ruby\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"LESS Tag names\",\"scope\":[\"entity.name.tag.less\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"LESS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.css\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"Attribute Name for LESS\",\"scope\":[\"meta.attribute-selector.less entity.other.attribute-name.attribute\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"Markdown Headings\",\"scope\":[\"markup.heading.markdown\",\"markup.heading.setext.1.markdown\",\"markup.heading.setext.2.markdown\"],\"settings\":{\"foreground\":\"#82b1ff\"}},{\"name\":\"Markdown Italics\",\"scope\":[\"markup.italic.markdown\"],\"settings\":{\"foreground\":\"#c792ea\",\"fontStyle\":\"italic\"}},{\"name\":\"Markdown Bold\",\"scope\":[\"markup.bold.markdown\"],\"settings\":{\"foreground\":\"#c5e478\",\"fontStyle\":\"bold\"}},{\"name\":\"Markdown Quote + others\",\"scope\":[\"markup.quote.markdown\"],\"settings\":{\"foreground\":\"#969bb7\",\"fontStyle\":\"\"}},{\"name\":\"Markdown Raw Code + others\",\"scope\":[\"markup.inline.raw.markdown\"],\"settings\":{\"foreground\":\"#80cbc4\"}},{\"name\":\"Markdown Links\",\"scope\":[\"markup.underline.link.markdown\",\"markup.underline.link.image.markdown\"],\"settings\":{\"foreground\":\"#ff869a\",\"fontStyle\":\"underline\"}},{\"name\":\"Markdown Link Title and Description\",\"scope\":[\"string.other.link.title.markdown\",\"string.other.link.description.markdown\"],\"settings\":{\"foreground\":\"#d6deeb\",\"fontStyle\":\"underline\"}},{\"name\":\"Markdown Punctuation\",\"scope\":[\"punctuation.definition.string.markdown\",\"punctuation.definition.string.begin.markdown\",\"punctuation.definition.string.end.markdown\",\"meta.link.inline.markdown punctuation.definition.string\"],\"settings\":{\"foreground\":\"#82b1ff\"}},{\"name\":\"Markdown MetaData Punctuation\",\"scope\":[\"punctuation.definition.metadata.markdown\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"Markdown List Punctuation\",\"scope\":[\"beginning.punctuation.definition.list.markdown\"],\"settings\":{\"foreground\":\"#82b1ff\"}},{\"name\":\"Markdown Inline Raw String\",\"scope\":[\"markup.inline.raw.string.markdown\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"PHP Variables\",\"scope\":[\"variable.other.php\"],\"settings\":{\"foreground\":\"#bec5d4\"}},{\"name\":\"Support Classes in PHP\",\"scope\":[\"support.class.php\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"Punctuations in PHP function calls\",\"scope\":[\"meta.function-call.php punctuation\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"PHP Global Variables\",\"scope\":[\"variable.other.global.php\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Declaration Punctuation in PHP Global Variables\",\"scope\":[\"variable.other.global.php punctuation.definition.variable\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Language Constants in Python\",\"scope\":[\"constant.language.python\"],\"settings\":{\"foreground\":\"#ff6a83\"}},{\"name\":\"Python Function Parameter and Arguments\",\"scope\":[\"variable.parameter.function.python\",\"meta.function-call.arguments.python\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Python Function Call\",\"scope\":[\"meta.function-call.python\",\"meta.function-call.generic.python\"],\"settings\":{\"foreground\":\"#b2ccd6\"}},{\"name\":\"Punctuations in Python\",\"scope\":[\"punctuation.python\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"Decorator Functions in Python\",\"scope\":[\"entity.name.function.decorator.python\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Python Language Variable\",\"scope\":[\"source.python variable.language.special\"],\"settings\":{\"foreground\":\"#8eace3\"}},{\"name\":\"Python import control keyword\",\"scope\":[\"keyword.control\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"SCSS Variable\",\"scope\":[\"variable.scss\",\"variable.sass\",\"variable.parameter.url.scss\",\"variable.parameter.url.sass\"],\"settings\":{\"foreground\":\"#c5e478\"}},{\"name\":\"Variables in SASS At-Rules\",\"scope\":[\"source.css.scss meta.at-rule variable\",\"source.css.sass meta.at-rule variable\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"Variables in SASS At-Rules\",\"scope\":[\"source.css.scss meta.at-rule variable\",\"source.css.sass meta.at-rule variable\"],\"settings\":{\"foreground\":\"#bec5d4\"}},{\"name\":\"Attribute Name for SASS\",\"scope\":[\"meta.attribute-selector.scss entity.other.attribute-name.attribute\",\"meta.attribute-selector.sass entity.other.attribute-name.attribute\"],\"settings\":{\"foreground\":\"#f78c6c\"}},{\"name\":\"Tag names in SASS\",\"scope\":[\"entity.name.tag.scss\",\"entity.name.tag.sass\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"SASS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.scss\",\"keyword.other.unit.sass\"],\"settings\":{\"foreground\":\"#ffeb95\"}},{\"name\":\"TypeScript[React] Variables and Object Properties\",\"scope\":[\"variable.other.readwrite.alias.ts\",\"variable.other.readwrite.alias.tsx\",\"variable.other.readwrite.ts\",\"variable.other.readwrite.tsx\",\"variable.other.object.ts\",\"variable.other.object.tsx\",\"variable.object.property.ts\",\"variable.object.property.tsx\",\"variable.other.ts\",\"variable.other.tsx\",\"variable.tsx\",\"variable.ts\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"TypeScript[React] Entity Name Types\",\"scope\":[\"entity.name.type.ts\",\"entity.name.type.tsx\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"TypeScript[React] Node Classes\",\"scope\":[\"support.class.node.ts\",\"support.class.node.tsx\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"TypeScript[React] Entity Name Types as Parameters\",\"scope\":[\"meta.type.parameters.ts entity.name.type\",\"meta.type.parameters.tsx entity.name.type\"],\"settings\":{\"foreground\":\"#889fb2\"}},{\"name\":\"TypeScript[React] Import/Export Punctuations\",\"scope\":[\"meta.import.ts punctuation.definition.block\",\"meta.import.tsx punctuation.definition.block\",\"meta.export.ts punctuation.definition.block\",\"meta.export.tsx punctuation.definition.block\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"TypeScript[React] Punctuation Decorators\",\"scope\":[\"meta.decorator punctuation.decorator.ts\",\"meta.decorator punctuation.decorator.tsx\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"TypeScript[React] Punctuation Decorators\",\"scope\":[\"meta.tag.js meta.jsx.children.tsx\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"YAML Entity Name Tags\",\"scope\":[\"entity.name.tag.yaml\"],\"settings\":{\"foreground\":\"#7fdbca\"}},{\"name\":\"JavaScript Variable Other ReadWrite\",\"scope\":[\"variable.other.readwrite.js\",\"variable.parameter\"],\"settings\":{\"foreground\":\"#d7dbe0\"}},{\"name\":\"Support Class Component\",\"scope\":[\"support.class.component.js\",\"support.class.component.tsx\"],\"settings\":{\"foreground\":\"#f78c6c\",\"fontStyle\":\"\"}},{\"name\":\"Text nested in React tags\",\"scope\":[\"meta.jsx.children\",\"meta.jsx.children.js\",\"meta.jsx.children.tsx\"],\"settings\":{\"foreground\":\"#d6deeb\"}},{\"name\":\"TypeScript Classes\",\"scope\":[\"meta.class entity.name.type.class.tsx\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"TypeScript Entity Name Type\",\"scope\":[\"entity.name.type.tsx\",\"entity.name.type.module.tsx\"],\"settings\":{\"foreground\":\"#ffcb8b\"}},{\"name\":\"TypeScript Class Variable Keyword\",\"scope\":[\"meta.class.ts meta.var.expr.ts storage.type.ts\",\"meta.class.tsx meta.var.expr.tsx storage.type.tsx\"],\"settings\":{\"foreground\":\"#c792ea\"}},{\"name\":\"TypeScript Method Declaration e.g. `constructor`\",\"scope\":[\"meta.method.declaration storage.type.ts\",\"meta.method.declaration storage.type.tsx\"],\"settings\":{\"foreground\":\"#82aaff\"}},{\"name\":\"normalize font style of certain components\",\"scope\":[\"meta.property-list.css meta.property-value.css variable.other.less\",\"meta.property-list.scss variable.scss\",\"meta.property-list.sass variable.sass\",\"meta.brace\",\"keyword.operator.operator\",\"keyword.operator.or.regexp\",\"keyword.operator.expression.in\",\"keyword.operator.relational\",\"keyword.operator.assignment\",\"keyword.operator.comparison\",\"keyword.operator.type\",\"keyword.operator\",\"keyword\",\"punctuation.definintion.string\",\"punctuation\",\"variable.other.readwrite.js\",\"storage.type\",\"source.css\",\"string.quoted\"],\"settings\":{\"fontStyle\":\"\"}}],\"styleOverrides\":{\"frames\":{\"editorBackground\":\"var(--sl-color-gray-6)\",\"terminalBackground\":\"var(--sl-color-gray-6)\",\"editorActiveTabBackground\":\"var(--sl-color-gray-6)\",\"terminalTitlebarDotsForeground\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"terminalTitlebarDotsOpacity\":\"0.75\",\"inlineButtonForeground\":\"var(--sl-color-text)\",\"frameBoxShadowCssValue\":\"none\"},\"textMarkers\":{\"markBackground\":\"#ffffff17\",\"markBorderColor\":\"#ffffff40\"}}},{\"name\":\"Night Owl Light\",\"type\":\"light\",\"colors\":{\"focusBorder\":\"#93a1a1\",\"foreground\":\"#403f53\",\"disabledForeground\":\"#61616180\",\"descriptionForeground\":\"#403f53\",\"errorForeground\":\"#403f53\",\"icon.foreground\":\"#424242\",\"contrastActiveBorder\":null,\"contrastBorder\":null,\"textBlockQuote.background\":\"#7f7f7f1a\",\"textBlockQuote.border\":\"#007acc80\",\"textCodeBlock.background\":\"#dcdcdc66\",\"textLink.activeForeground\":\"#006ab1\",\"textLink.foreground\":\"#006ab1\",\"textPreformat.foreground\":\"#a31515\",\"textSeparator.foreground\":\"#0000002e\",\"editor.background\":\"#f6f7f9\",\"editor.foreground\":\"#403f53\",\"editorLineNumber.foreground\":\"#90a7b2\",\"editorLineNumber.activeForeground\":\"#403f53\",\"editorActiveLineNumber.foreground\":\"#0b216f\",\"editor.selectionBackground\":\"#e0e0e0\",\"editor.inactiveSelectionBackground\":\"#e0e0e080\",\"editor.selectionHighlightBackground\":\"#339cec33\",\"editorError.foreground\":\"#e64d49\",\"editorWarning.foreground\":\"#daaa01\",\"editorInfo.foreground\":\"#1a85ff\",\"editorHint.foreground\":\"#6c6c6c\",\"problemsErrorIcon.foreground\":\"#e64d49\",\"problemsWarningIcon.foreground\":\"#daaa01\",\"problemsInfoIcon.foreground\":\"#1a85ff\",\"editor.findMatchBackground\":\"#93a1a16c\",\"editor.findMatchHighlightBackground\":\"#93a1a16c\",\"editor.findRangeHighlightBackground\":\"#7497a633\",\"editorLink.activeForeground\":\"#0000ff\",\"editorLightBulb.foreground\":\"#ddb100\",\"editorLightBulbAutoFix.foreground\":\"#007acc\",\"diffEditor.insertedTextBackground\":\"#9ccc2c40\",\"diffEditor.insertedTextBorder\":null,\"diffEditor.removedTextBackground\":\"#ff000033\",\"diffEditor.removedTextBorder\":null,\"diffEditor.insertedLineBackground\":\"#9bb95533\",\"diffEditor.removedLineBackground\":\"#ff000033\",\"editorStickyScroll.background\":\"#fbfbfb\",\"editorStickyScrollHover.background\":\"#f0f0f0\",\"editorInlayHint.background\":\"#2aa29899\",\"editorInlayHint.foreground\":\"#f0f0f0\",\"editorInlayHint.typeBackground\":\"#2aa29899\",\"editorInlayHint.typeForeground\":\"#f0f0f0\",\"editorInlayHint.parameterBackground\":\"#2aa29899\",\"editorInlayHint.parameterForeground\":\"#f0f0f0\",\"editorPane.background\":\"#fbfbfb\",\"editorGroup.emptyBackground\":null,\"editorGroup.focusedEmptyBorder\":null,\"editorGroupHeader.tabsBackground\":\"var(--sl-color-gray-6)\",\"editorGroupHeader.tabsBorder\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"editorGroupHeader.noTabsBackground\":\"#f0f0f0\",\"editorGroupHeader.border\":null,\"editorGroup.border\":\"#f0f0f0\",\"editorGroup.dropBackground\":\"#2677cb2d\",\"editorGroup.dropIntoPromptForeground\":\"#403f53\",\"editorGroup.dropIntoPromptBackground\":\"#f0f0f0\",\"editorGroup.dropIntoPromptBorder\":null,\"sideBySideEditor.horizontalBorder\":\"#f0f0f0\",\"sideBySideEditor.verticalBorder\":\"#f0f0f0\",\"scrollbar.shadow\":\"#cccccc\",\"scrollbarSlider.background\":\"#0000001a\",\"scrollbarSlider.hoverBackground\":\"#00000055\",\"scrollbarSlider.activeBackground\":\"#00000099\",\"panel.background\":\"#f0f0f0\",\"panel.border\":\"#d9d9d9\",\"panelTitle.activeBorder\":\"#424242\",\"panelTitle.activeForeground\":\"#424242\",\"panelTitle.inactiveForeground\":\"#424242bf\",\"panelSectionHeader.background\":\"#80808051\",\"terminal.background\":\"#f6f6f6\",\"widget.shadow\":\"#d9d9d9\",\"editorWidget.background\":\"#f0f0f0\",\"editorWidget.foreground\":\"#403f53\",\"editorWidget.border\":\"#d9d9d9\",\"quickInput.background\":\"#f0f0f0\",\"quickInput.foreground\":\"#403f53\",\"quickInputTitle.background\":\"#0000000f\",\"pickerGroup.foreground\":\"#403f53\",\"pickerGroup.border\":\"#d9d9d9\",\"editor.hoverHighlightBackground\":\"#339cec33\",\"editorHoverWidget.background\":\"#f0f0f0\",\"editorHoverWidget.foreground\":\"#403f53\",\"editorHoverWidget.border\":\"#d9d9d9\",\"editorHoverWidget.statusBarBackground\":\"#e4e4e4\",\"titleBar.activeBackground\":\"var(--sl-color-gray-6)\",\"titleBar.activeForeground\":\"var(--sl-color-text)\",\"titleBar.inactiveBackground\":\"#f0f0f099\",\"titleBar.inactiveForeground\":\"#33333399\",\"titleBar.border\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"toolbar.hoverBackground\":\"#b8b8b850\",\"toolbar.activeBackground\":\"#a6a6a650\",\"tab.activeBackground\":\"#f6f6f6\",\"tab.unfocusedActiveBackground\":\"#f6f6f6\",\"tab.inactiveBackground\":\"#f0f0f0\",\"tab.unfocusedInactiveBackground\":\"#f0f0f0\",\"tab.activeForeground\":\"var(--sl-color-text)\",\"tab.inactiveForeground\":\"#403f53\",\"tab.unfocusedActiveForeground\":\"#403f53b3\",\"tab.unfocusedInactiveForeground\":\"#403f5380\",\"tab.hoverBackground\":null,\"tab.unfocusedHoverBackground\":null,\"tab.hoverForeground\":null,\"tab.unfocusedHoverForeground\":null,\"tab.border\":\"#f0f0f0\",\"tab.lastPinnedBorder\":\"#a9a9a9\",\"tab.activeBorder\":\"transparent\",\"tab.unfocusedActiveBorder\":null,\"tab.activeBorderTop\":\"var(--sl-color-accent)\",\"tab.unfocusedActiveBorderTop\":null,\"tab.hoverBorder\":null,\"tab.unfocusedHoverBorder\":null,\"tab.activeModifiedBorder\":\"#2aa298\",\"tab.inactiveModifiedBorder\":\"#93a1a1\",\"tab.unfocusedActiveModifiedBorder\":\"#93a1a1\",\"tab.unfocusedInactiveModifiedBorder\":\"#93a1a1\",\"badge.background\":\"#2aa298\",\"badge.foreground\":\"#f0f0f0\",\"button.background\":\"#2aa298\",\"button.foreground\":\"#f0f0f0\",\"button.border\":null,\"button.separator\":\"#f0f0f066\",\"button.hoverBackground\":\"#22827a\",\"button.secondaryBackground\":\"#5f6a79\",\"button.secondaryForeground\":\"#ffffff\",\"button.secondaryHoverBackground\":\"#4c5561\",\"dropdown.background\":\"#f0f0f0\",\"dropdown.foreground\":\"#403f53\",\"dropdown.border\":\"#d9d9d9\",\"list.activeSelectionBackground\":\"#d3e8f8\",\"list.activeSelectionForeground\":\"#403f53\",\"tree.indentGuidesStroke\":\"#a9a9a9\",\"input.background\":\"#f0f0f0\",\"input.foreground\":\"#403f53\",\"input.placeholderForeground\":\"#93a1a1\",\"inputOption.activeBorder\":\"#2aa298\",\"inputOption.hoverBackground\":\"#b8b8b850\",\"inputOption.activeBackground\":\"#93a1a133\",\"inputOption.activeForeground\":\"#000000\",\"inputValidation.infoBackground\":\"#f0f0f0\",\"inputValidation.infoBorder\":\"#d0d0d0\",\"inputValidation.warningBackground\":\"#daaa01\",\"inputValidation.warningBorder\":\"#e0af02\",\"inputValidation.errorBackground\":\"#f76e6e\",\"inputValidation.errorBorder\":\"#de3d3b\",\"keybindingLabel.background\":\"#dddddd66\",\"keybindingLabel.foreground\":\"#555555\",\"keybindingLabel.border\":\"#cccccc66\",\"keybindingLabel.bottomBorder\":\"#bbbbbb66\",\"menu.foreground\":\"#403f53\",\"menu.background\":\"#f0f0f0\",\"menu.selectionForeground\":\"#403f53\",\"menu.selectionBackground\":\"#d3e8f8\",\"menu.separatorBackground\":\"#d4d4d4\",\"editor.snippetTabstopHighlightBackground\":\"#0a326433\",\"editor.snippetFinalTabstopHighlightBorder\":\"#0a326480\",\"terminal.ansiBlack\":\"#403f53\",\"terminal.ansiRed\":\"#de3d3b\",\"terminal.ansiGreen\":\"#08916a\",\"terminal.ansiYellow\":\"#e0af02\",\"terminal.ansiBlue\":\"#288ed7\",\"terminal.ansiMagenta\":\"#d6438a\",\"terminal.ansiCyan\":\"#2aa298\",\"terminal.ansiWhite\":\"#f0f0f0\",\"terminal.ansiBrightBlack\":\"#403f53\",\"terminal.ansiBrightRed\":\"#de3d3b\",\"terminal.ansiBrightGreen\":\"#08916a\",\"terminal.ansiBrightYellow\":\"#daaa01\",\"terminal.ansiBrightBlue\":\"#288ed7\",\"terminal.ansiBrightMagenta\":\"#d6438a\",\"terminal.ansiBrightCyan\":\"#2aa298\",\"terminal.ansiBrightWhite\":\"#f0f0f0\",\"selection.background\":\"#7a8181ad\",\"notifications.background\":\"#f0f0f0\",\"notifications.foreground\":\"#403f53\",\"notificationLink.foreground\":\"#994cc3\",\"notifications.border\":\"#cccccc\",\"notificationCenter.border\":\"#cccccc\",\"notificationToast.border\":\"#cccccc\",\"notificationCenterHeader.foreground\":\"#403f53\",\"notificationCenterHeader.background\":\"#f0f0f0\",\"input.border\":\"#d9d9d9\",\"progressBar.background\":\"#2aa298\",\"list.inactiveSelectionBackground\":\"#e0e7ea\",\"list.inactiveSelectionForeground\":\"#403f53\",\"list.focusBackground\":\"#d3e8f8\",\"list.hoverBackground\":\"#d3e8f8\",\"list.focusForeground\":\"#403f53\",\"list.hoverForeground\":\"#403f53\",\"list.highlightForeground\":\"#403f53\",\"list.errorForeground\":\"#e64d49\",\"list.warningForeground\":\"#daaa01\",\"activityBar.background\":\"#f0f0f0\",\"activityBar.foreground\":\"#403f53\",\"activityBar.dropBackground\":\"#d0d0d0\",\"activityBarBadge.background\":\"#403f53\",\"activityBarBadge.foreground\":\"#f0f0f0\",\"activityBar.border\":\"#f0f0f0\",\"sideBar.background\":\"#f0f0f0\",\"sideBar.foreground\":\"#403f53\",\"sideBarTitle.foreground\":\"#403f53\",\"sideBar.border\":\"#f0f0f0\",\"editorGroup.background\":\"#f6f6f6\",\"editorCursor.foreground\":\"#90a7b2\",\"editor.wordHighlightBackground\":\"#339cec33\",\"editor.wordHighlightStrongBackground\":\"#007dd659\",\"editor.lineHighlightBackground\":\"#f0f0f0\",\"editor.rangeHighlightBackground\":\"#7497a633\",\"editorWhitespace.foreground\":\"#d9d9d9\",\"editorIndentGuide.background\":\"#d9d9d9\",\"editorCodeLens.foreground\":\"#403f53\",\"editorBracketMatch.background\":\"#d3e8f8\",\"editorBracketMatch.border\":\"#2aa298\",\"editorError.border\":\"#fbfbfb\",\"editorWarning.border\":\"#daaa01\",\"editorGutter.addedBackground\":\"#49d0c5\",\"editorGutter.modifiedBackground\":\"#6fbef6\",\"editorGutter.deletedBackground\":\"#f76e6e\",\"editorRuler.foreground\":\"#d9d9d9\",\"editorOverviewRuler.errorForeground\":\"#e64d49\",\"editorOverviewRuler.warningForeground\":\"#daaa01\",\"editorSuggestWidget.background\":\"#f0f0f0\",\"editorSuggestWidget.foreground\":\"#403f53\",\"editorSuggestWidget.highlightForeground\":\"#403f53\",\"editorSuggestWidget.selectedBackground\":\"#d3e8f8\",\"editorSuggestWidget.border\":\"#d9d9d9\",\"debugExceptionWidget.background\":\"#f0f0f0\",\"debugExceptionWidget.border\":\"#d9d9d9\",\"editorMarkerNavigation.background\":\"#d0d0d0\",\"editorMarkerNavigationError.background\":\"#f76e6e\",\"editorMarkerNavigationWarning.background\":\"#daaa01\",\"debugToolBar.background\":\"#f0f0f0\",\"extensionButton.prominentBackground\":\"#2aa298\",\"extensionButton.prominentForeground\":\"#f0f0f0\",\"statusBar.background\":\"#f0f0f0\",\"statusBar.border\":\"#f0f0f0\",\"statusBar.debuggingBackground\":\"#f0f0f0\",\"statusBar.debuggingForeground\":\"#403f53\",\"statusBar.foreground\":\"#403f53\",\"statusBar.noFolderBackground\":\"#f0f0f0\",\"statusBar.noFolderForeground\":\"#403f53\",\"peekView.border\":\"#d9d9d9\",\"peekViewEditor.background\":\"#f6f6f6\",\"peekViewEditorGutter.background\":\"#f6f6f6\",\"peekViewEditor.matchHighlightBackground\":\"#49d0c5\",\"peekViewResult.background\":\"#f0f0f0\",\"peekViewResult.fileForeground\":\"#403f53\",\"peekViewResult.lineForeground\":\"#403f53\",\"peekViewResult.matchHighlightBackground\":\"#49d0c5\",\"peekViewResult.selectionBackground\":\"#e0e7ea\",\"peekViewResult.selectionForeground\":\"#403f53\",\"peekViewTitle.background\":\"#f0f0f0\",\"peekViewTitleLabel.foreground\":\"#403f53\",\"peekViewTitleDescription.foreground\":\"#403f53\",\"terminal.foreground\":\"#403f53\"},\"fg\":\"#403f53\",\"bg\":\"#f6f7f9\",\"semanticHighlighting\":false,\"settings\":[{\"name\":\"Changed\",\"scope\":[\"markup.changed\",\"meta.diff.header.git\",\"meta.diff.header.from-file\",\"meta.diff.header.to-file\"],\"settings\":{\"foreground\":\"#556484\"}},{\"name\":\"Deleted\",\"scope\":[\"markup.deleted.diff\"],\"settings\":{\"foreground\":\"#ae3c3afd\"}},{\"name\":\"Inserted\",\"scope\":[\"markup.inserted.diff\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Global settings\",\"settings\":{\"background\":\"#011627\",\"foreground\":\"#403f53\"}},{\"name\":\"Comment\",\"scope\":[\"comment\"],\"settings\":{\"foreground\":\"#5f636f\"}},{\"name\":\"String\",\"scope\":[\"string\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"String Quoted\",\"scope\":[\"string.quoted\",\"variable.other.readwrite.js\"],\"settings\":{\"foreground\":\"#984e4d\"}},{\"name\":\"Support Constant Math\",\"scope\":[\"support.constant.math\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Number\",\"scope\":[\"constant.numeric\",\"constant.character.numeric\"],\"settings\":{\"foreground\":\"#aa0982\",\"fontStyle\":\"\"}},{\"name\":\"Built-in constant\",\"scope\":[\"constant.language\",\"punctuation.definition.constant\",\"variable.other.constant\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"User-defined constant\",\"scope\":[\"constant.character\",\"constant.other\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Constant Character Escape\",\"scope\":[\"constant.character.escape\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"RegExp String\",\"scope\":[\"string.regexp\",\"string.regexp keyword.other\"],\"settings\":{\"foreground\":\"#3a688f\"}},{\"name\":\"Comma in functions\",\"scope\":[\"meta.function punctuation.separator.comma\"],\"settings\":{\"foreground\":\"#4d667b\"}},{\"name\":\"Variable\",\"scope\":[\"variable\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Keyword\",\"scope\":[\"punctuation.accessor\",\"keyword\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Storage\",\"scope\":[\"storage\",\"meta.var.expr\",\"meta.class meta.method.declaration meta.var.expr storage.type.js\",\"storage.type.property.js\",\"storage.type.property.ts\",\"storage.type.property.tsx\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Storage type\",\"scope\":[\"storage.type\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Storage type\",\"scope\":[\"storage.type.function.arrow.js\"],\"settings\":{\"fontStyle\":\"\"}},{\"name\":\"Class name\",\"scope\":[\"entity.name.class\",\"meta.class entity.name.type.class\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Inherited class\",\"scope\":[\"entity.other.inherited-class\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Function name\",\"scope\":[\"entity.name.function\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Meta Tag\",\"scope\":[\"punctuation.definition.tag\",\"meta.tag\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"HTML Tag names\",\"scope\":[\"entity.name.tag\",\"meta.tag.other.html\",\"meta.tag.other.js\",\"meta.tag.other.tsx\",\"entity.name.tag.tsx\",\"entity.name.tag.js\",\"entity.name.tag\",\"meta.tag.js\",\"meta.tag.tsx\",\"meta.tag.html\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Tag attribute\",\"scope\":[\"entity.other.attribute-name\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Entity Name Tag Custom\",\"scope\":[\"entity.name.tag.custom\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Library (function & constant)\",\"scope\":[\"support.function\",\"support.constant\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Support Constant Property Value meta\",\"scope\":[\"support.constant.meta.property-value\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Library class/type\",\"scope\":[\"support.type\",\"support.class\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Support Variable DOM\",\"scope\":[\"support.variable.dom\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Invalid\",\"scope\":[\"invalid\"],\"settings\":{\"foreground\":\"#bb2060\"}},{\"name\":\"Invalid deprecated\",\"scope\":[\"invalid.deprecated\"],\"settings\":{\"foreground\":\"#b23834\"}},{\"name\":\"Keyword Operator\",\"scope\":[\"keyword.operator\"],\"settings\":{\"foreground\":\"#096e72\",\"fontStyle\":\"\"}},{\"name\":\"Keyword Operator Relational\",\"scope\":[\"keyword.operator.relational\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Assignment\",\"scope\":[\"keyword.operator.assignment\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Arithmetic\",\"scope\":[\"keyword.operator.arithmetic\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Bitwise\",\"scope\":[\"keyword.operator.bitwise\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Increment\",\"scope\":[\"keyword.operator.increment\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Operator Ternary\",\"scope\":[\"keyword.operator.ternary\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Double-Slashed Comment\",\"scope\":[\"comment.line.double-slash\"],\"settings\":{\"foreground\":\"#5d6376\"}},{\"name\":\"Object\",\"scope\":[\"object\"],\"settings\":{\"foreground\":\"#58656a\"}},{\"name\":\"Null\",\"scope\":[\"constant.language.null\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"Meta Brace\",\"scope\":[\"meta.brace\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Meta Delimiter Period\",\"scope\":[\"meta.delimiter.period\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Punctuation Definition String\",\"scope\":[\"punctuation.definition.string\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Punctuation Definition String Markdown\",\"scope\":[\"punctuation.definition.string.begin.markdown\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"Boolean\",\"scope\":[\"constant.language.boolean\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"Object Comma\",\"scope\":[\"object.comma\"],\"settings\":{\"foreground\":\"#646464\"}},{\"name\":\"Variable Parameter Function\",\"scope\":[\"variable.parameter.function\"],\"settings\":{\"foreground\":\"#096e72\",\"fontStyle\":\"\"}},{\"name\":\"Support Type Property Name & entity name tags\",\"scope\":[\"support.type.vendor.property-name\",\"support.constant.vendor.property-value\",\"support.type.property-name\",\"meta.property-list entity.name.tag\"],\"settings\":{\"foreground\":\"#096e72\",\"fontStyle\":\"\"}},{\"name\":\"Entity Name tag reference in stylesheets\",\"scope\":[\"meta.property-list entity.name.tag.reference\"],\"settings\":{\"foreground\":\"#286d70\"}},{\"name\":\"Constant Other Color RGB Value Punctuation Definition Constant\",\"scope\":[\"constant.other.color.rgb-value punctuation.definition.constant\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Constant Other Color\",\"scope\":[\"constant.other.color\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Keyword Other Unit\",\"scope\":[\"keyword.other.unit\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Meta Selector\",\"scope\":[\"meta.selector\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Entity Other Attribute Name Id\",\"scope\":[\"entity.other.attribute-name.id\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Meta Property Name\",\"scope\":[\"meta.property-name\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Doctypes\",\"scope\":[\"entity.name.tag.doctype\",\"meta.tag.sgml.doctype\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Punctuation Definition Parameters\",\"scope\":[\"punctuation.definition.parameters\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Keyword Control Operator\",\"scope\":[\"keyword.control.operator\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Keyword Operator Logical\",\"scope\":[\"keyword.operator.logical\"],\"settings\":{\"foreground\":\"#8844ae\",\"fontStyle\":\"\"}},{\"name\":\"Variable Instances\",\"scope\":[\"variable.instance\",\"variable.other.instance\",\"variable.readwrite.instance\",\"variable.other.readwrite.instance\",\"variable.other.property\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Variable Property Other object property\",\"scope\":[\"variable.other.object.property\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Variable Property Other object\",\"scope\":[\"variable.other.object.js\"],\"settings\":{\"fontStyle\":\"\"}},{\"name\":\"Entity Name Function\",\"scope\":[\"entity.name.function\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Keyword Operator Comparison, imports, returns and Keyword Operator Ruby\",\"scope\":[\"keyword.operator.comparison\",\"keyword.control.flow.js\",\"keyword.control.flow.ts\",\"keyword.control.flow.tsx\",\"keyword.control.ruby\",\"keyword.control.module.ruby\",\"keyword.control.class.ruby\",\"keyword.control.def.ruby\",\"keyword.control.loop.js\",\"keyword.control.loop.ts\",\"keyword.control.import.js\",\"keyword.control.import.ts\",\"keyword.control.import.tsx\",\"keyword.control.from.js\",\"keyword.control.from.ts\",\"keyword.control.from.tsx\",\"keyword.operator.instanceof.js\",\"keyword.operator.expression.instanceof.ts\",\"keyword.operator.expression.instanceof.tsx\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Keyword Control Conditional\",\"scope\":[\"keyword.control.conditional.js\",\"keyword.control.conditional.ts\",\"keyword.control.switch.js\",\"keyword.control.switch.ts\"],\"settings\":{\"foreground\":\"#8844ae\",\"fontStyle\":\"\"}},{\"name\":\"Support Constant, `new` keyword, Special Method Keyword, `debugger`, other keywords\",\"scope\":[\"support.constant\",\"keyword.other.special-method\",\"keyword.other.new\",\"keyword.other.debugger\",\"keyword.control\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Support Function\",\"scope\":[\"support.function\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Invalid Broken\",\"scope\":[\"invalid.broken\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Invalid Unimplemented\",\"scope\":[\"invalid.unimplemented\"],\"settings\":{\"foreground\":\"#486e26\"}},{\"name\":\"Invalid Illegal\",\"scope\":[\"invalid.illegal\"],\"settings\":{\"foreground\":\"#984e4d\"}},{\"name\":\"Language Variable\",\"scope\":[\"variable.language\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Support Variable Property\",\"scope\":[\"support.variable.property\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Variable Function\",\"scope\":[\"variable.function\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Variable Interpolation\",\"scope\":[\"variable.interpolation\"],\"settings\":{\"foreground\":\"#a64348\"}},{\"name\":\"Meta Function Call\",\"scope\":[\"meta.function-call\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Punctuation Section Embedded\",\"scope\":[\"punctuation.section.embedded\"],\"settings\":{\"foreground\":\"#b23834\"}},{\"name\":\"Punctuation Tweaks\",\"scope\":[\"punctuation.terminator.expression\",\"punctuation.definition.arguments\",\"punctuation.definition.array\",\"punctuation.section.array\",\"meta.array\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"More Punctuation Tweaks\",\"scope\":[\"punctuation.definition.list.begin\",\"punctuation.definition.list.end\",\"punctuation.separator.arguments\",\"punctuation.definition.list\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Template Strings\",\"scope\":[\"string.template meta.template.expression\"],\"settings\":{\"foreground\":\"#b23834\"}},{\"name\":\"Backtics(``) in Template Strings\",\"scope\":[\"string.template punctuation.definition.string\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Italics\",\"scope\":[\"italic\"],\"settings\":{\"foreground\":\"#8844ae\",\"fontStyle\":\"italic\"}},{\"name\":\"Bold\",\"scope\":[\"bold\"],\"settings\":{\"foreground\":\"#3b61b0\",\"fontStyle\":\"bold\"}},{\"name\":\"Quote\",\"scope\":[\"quote\"],\"settings\":{\"foreground\":\"#5c6285\"}},{\"name\":\"Raw Code\",\"scope\":[\"raw\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"CoffeScript Variable Assignment\",\"scope\":[\"variable.assignment.coffee\"],\"settings\":{\"foreground\":\"#186e73\"}},{\"name\":\"CoffeScript Parameter Function\",\"scope\":[\"variable.parameter.function.coffee\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"CoffeeScript Assignments\",\"scope\":[\"variable.assignment.coffee\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"C# Readwrite Variables\",\"scope\":[\"variable.other.readwrite.cs\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"C# Classes & Storage types\",\"scope\":[\"entity.name.type.class.cs\",\"storage.type.cs\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"C# Namespaces\",\"scope\":[\"entity.name.type.namespace.cs\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Tag names in Stylesheets\",\"scope\":[\"entity.name.tag.css\",\"entity.name.tag.less\",\"entity.name.tag.custom.css\",\"support.constant.property-value.css\"],\"settings\":{\"foreground\":\"#984e4d\",\"fontStyle\":\"\"}},{\"name\":\"Wildcard(*) selector in Stylesheets\",\"scope\":[\"entity.name.tag.wildcard.css\",\"entity.name.tag.wildcard.less\",\"entity.name.tag.wildcard.scss\",\"entity.name.tag.wildcard.sass\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"CSS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.css\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Attribute Name for CSS\",\"scope\":[\"meta.attribute-selector.css entity.other.attribute-name.attribute\",\"variable.other.readwrite.js\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Elixir Classes\",\"scope\":[\"source.elixir support.type.elixir\",\"source.elixir meta.module.elixir entity.name.class.elixir\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir Functions\",\"scope\":[\"source.elixir entity.name.function\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir Constants\",\"scope\":[\"source.elixir constant.other.symbol.elixir\",\"source.elixir constant.other.keywords.elixir\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir String Punctuations\",\"scope\":[\"source.elixir punctuation.definition.string\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir\",\"scope\":[\"source.elixir variable.other.readwrite.module.elixir\",\"source.elixir variable.other.readwrite.module.elixir punctuation.definition.variable.elixir\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Elixir Binary Punctuations\",\"scope\":[\"source.elixir .punctuation.binary.elixir\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Closure Constant Keyword\",\"scope\":[\"constant.keyword.clojure\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Go Function Calls\",\"scope\":[\"source.go meta.function-call.go\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Go Keywords\",\"scope\":[\"source.go keyword.package.go\",\"source.go keyword.import.go\",\"source.go keyword.function.go\",\"source.go keyword.type.go\",\"source.go keyword.struct.go\",\"source.go keyword.interface.go\",\"source.go keyword.const.go\",\"source.go keyword.var.go\",\"source.go keyword.map.go\",\"source.go keyword.channel.go\",\"source.go keyword.control.go\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"Go Constants e.g. nil, string format (%s, %d, etc.)\",\"scope\":[\"source.go constant.language.go\",\"source.go constant.other.placeholder.go\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"C++ Functions\",\"scope\":[\"entity.name.function.preprocessor.cpp\",\"entity.scope.name.cpp\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"C++ Meta Namespace\",\"scope\":[\"meta.namespace-block.cpp\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"C++ Language Primitive Storage\",\"scope\":[\"storage.type.language.primitive.cpp\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"C++ Preprocessor Macro\",\"scope\":[\"meta.preprocessor.macro.cpp\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"C++ Variable Parameter\",\"scope\":[\"variable.parameter\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Powershell Variables\",\"scope\":[\"variable.other.readwrite.powershell\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Powershell Function\",\"scope\":[\"support.function.powershell\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"ID Attribute Name in HTML\",\"scope\":[\"entity.other.attribute-name.id.html\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"HTML Punctuation Definition Tag\",\"scope\":[\"punctuation.definition.tag.html\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"HTML Doctype\",\"scope\":[\"meta.tag.sgml.doctype.html\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"JavaScript Classes\",\"scope\":[\"meta.class entity.name.type.class.js\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"JavaScript Method Declaration e.g. `constructor`\",\"scope\":[\"meta.method.declaration storage.type.js\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"JavaScript Terminator\",\"scope\":[\"terminator.js\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JavaScript Meta Punctuation Definition\",\"scope\":[\"meta.js punctuation.definition.js\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Entity Names in Code Documentations\",\"scope\":[\"entity.name.type.instance.jsdoc\",\"entity.name.type.instance.phpdoc\"],\"settings\":{\"foreground\":\"#4d667b\"}},{\"name\":\"Other Variables in Code Documentations\",\"scope\":[\"variable.other.jsdoc\",\"variable.other.phpdoc\"],\"settings\":{\"foreground\":\"#3e697c\"}},{\"name\":\"JavaScript module imports and exports\",\"scope\":[\"variable.other.meta.import.js\",\"meta.import.js variable.other\",\"variable.other.meta.export.js\",\"meta.export.js variable.other\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JavaScript Variable Parameter Function\",\"scope\":[\"variable.parameter.function.js\"],\"settings\":{\"foreground\":\"#555ea2\"}},{\"name\":\"JavaScript[React] Variable Other Object\",\"scope\":[\"variable.other.object.js\",\"variable.other.object.jsx\",\"variable.object.property.js\",\"variable.object.property.jsx\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JavaScript Variables\",\"scope\":[\"variable.js\",\"variable.other.js\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JavaScript Entity Name Type\",\"scope\":[\"entity.name.type.js\",\"entity.name.type.module.js\"],\"settings\":{\"foreground\":\"#111111\",\"fontStyle\":\"\"}},{\"name\":\"JavaScript Support Classes\",\"scope\":[\"support.class.js\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"JSON Property Names\",\"scope\":[\"support.type.property-name.json\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"JSON Support Constants\",\"scope\":[\"support.constant.json\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"JSON Property values (string)\",\"scope\":[\"meta.structure.dictionary.value.json string.quoted.double\"],\"settings\":{\"foreground\":\"#7c5686\"}},{\"name\":\"Strings in JSON values\",\"scope\":[\"string.quoted.double.json punctuation.definition.string.json\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Specific JSON Property values like null\",\"scope\":[\"meta.structure.dictionary.json meta.structure.dictionary.value constant.language\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"JavaScript Other Variable\",\"scope\":[\"variable.other.object.js\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Ruby Variables\",\"scope\":[\"variable.other.ruby\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Ruby Class\",\"scope\":[\"entity.name.type.class.ruby\"],\"settings\":{\"foreground\":\"#984e4d\"}},{\"name\":\"Ruby Hashkeys\",\"scope\":[\"constant.language.symbol.hashkey.ruby\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Ruby Symbols\",\"scope\":[\"constant.language.symbol.ruby\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"LESS Tag names\",\"scope\":[\"entity.name.tag.less\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"LESS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.css\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Attribute Name for LESS\",\"scope\":[\"meta.attribute-selector.less entity.other.attribute-name.attribute\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Markdown Headings\",\"scope\":[\"markup.heading.markdown\",\"markup.heading.setext.1.markdown\",\"markup.heading.setext.2.markdown\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Markdown Italics\",\"scope\":[\"markup.italic.markdown\"],\"settings\":{\"foreground\":\"#8844ae\",\"fontStyle\":\"italic\"}},{\"name\":\"Markdown Bold\",\"scope\":[\"markup.bold.markdown\"],\"settings\":{\"foreground\":\"#3b61b0\",\"fontStyle\":\"bold\"}},{\"name\":\"Markdown Quote + others\",\"scope\":[\"markup.quote.markdown\"],\"settings\":{\"foreground\":\"#5c6285\"}},{\"name\":\"Markdown Raw Code + others\",\"scope\":[\"markup.inline.raw.markdown\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Markdown Links\",\"scope\":[\"markup.underline.link.markdown\",\"markup.underline.link.image.markdown\"],\"settings\":{\"foreground\":\"#954f5a\",\"fontStyle\":\"underline\"}},{\"name\":\"Markdown Link Title and Description\",\"scope\":[\"string.other.link.title.markdown\",\"string.other.link.description.markdown\"],\"settings\":{\"foreground\":\"#403f53\",\"fontStyle\":\"underline\"}},{\"name\":\"Markdown Punctuation\",\"scope\":[\"punctuation.definition.string.markdown\",\"punctuation.definition.string.begin.markdown\",\"punctuation.definition.string.end.markdown\",\"meta.link.inline.markdown punctuation.definition.string\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Markdown MetaData Punctuation\",\"scope\":[\"punctuation.definition.metadata.markdown\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Markdown List Punctuation\",\"scope\":[\"beginning.punctuation.definition.list.markdown\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Markdown Inline Raw String\",\"scope\":[\"markup.inline.raw.string.markdown\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"PHP Variables\",\"scope\":[\"variable.other.php\",\"variable.other.property.php\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Support Classes in PHP\",\"scope\":[\"support.class.php\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Punctuations in PHP function calls\",\"scope\":[\"meta.function-call.php punctuation\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"PHP Global Variables\",\"scope\":[\"variable.other.global.php\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Declaration Punctuation in PHP Global Variables\",\"scope\":[\"variable.other.global.php punctuation.definition.variable\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Language Constants in Python\",\"scope\":[\"constant.language.python\"],\"settings\":{\"foreground\":\"#a24848\"}},{\"name\":\"Python Function Parameter and Arguments\",\"scope\":[\"variable.parameter.function.python\",\"meta.function-call.arguments.python\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Python Function Call\",\"scope\":[\"meta.function-call.python\",\"meta.function-call.generic.python\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"Punctuations in Python\",\"scope\":[\"punctuation.python\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Decorator Functions in Python\",\"scope\":[\"entity.name.function.decorator.python\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Python Language Variable\",\"scope\":[\"source.python variable.language.special\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Python import control keyword\",\"scope\":[\"keyword.control\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"SCSS Variable\",\"scope\":[\"variable.scss\",\"variable.sass\",\"variable.parameter.url.scss\",\"variable.parameter.url.sass\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Variables in SASS At-Rules\",\"scope\":[\"source.css.scss meta.at-rule variable\",\"source.css.sass meta.at-rule variable\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"Variables in SASS At-Rules\",\"scope\":[\"source.css.scss meta.at-rule variable\",\"source.css.sass meta.at-rule variable\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"Attribute Name for SASS\",\"scope\":[\"meta.attribute-selector.scss entity.other.attribute-name.attribute\",\"meta.attribute-selector.sass entity.other.attribute-name.attribute\"],\"settings\":{\"foreground\":\"#aa0982\"}},{\"name\":\"Tag names in SASS\",\"scope\":[\"entity.name.tag.scss\",\"entity.name.tag.sass\"],\"settings\":{\"foreground\":\"#096e72\"}},{\"name\":\"SASS Keyword Other Unit\",\"scope\":[\"keyword.other.unit.scss\",\"keyword.other.unit.sass\"],\"settings\":{\"foreground\":\"#8844ae\"}},{\"name\":\"TypeScript[React] Variables and Object Properties\",\"scope\":[\"variable.other.readwrite.alias.ts\",\"variable.other.readwrite.alias.tsx\",\"variable.other.readwrite.ts\",\"variable.other.readwrite.tsx\",\"variable.other.object.ts\",\"variable.other.object.tsx\",\"variable.object.property.ts\",\"variable.object.property.tsx\",\"variable.other.ts\",\"variable.other.tsx\",\"variable.tsx\",\"variable.ts\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"TypeScript[React] Entity Name Types\",\"scope\":[\"entity.name.type.ts\",\"entity.name.type.tsx\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"TypeScript[React] Node Classes\",\"scope\":[\"support.class.node.ts\",\"support.class.node.tsx\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"TypeScript[React] Entity Name Types as Parameters\",\"scope\":[\"meta.type.parameters.ts entity.name.type\",\"meta.type.parameters.tsx entity.name.type\"],\"settings\":{\"foreground\":\"#4d667b\"}},{\"name\":\"TypeScript[React] Import/Export Punctuations\",\"scope\":[\"meta.import.ts punctuation.definition.block\",\"meta.import.tsx punctuation.definition.block\",\"meta.export.ts punctuation.definition.block\",\"meta.export.tsx punctuation.definition.block\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"TypeScript[React] Punctuation Decorators\",\"scope\":[\"meta.decorator punctuation.decorator.ts\",\"meta.decorator punctuation.decorator.tsx\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"TypeScript[React] Punctuation Decorators\",\"scope\":[\"meta.tag.js meta.jsx.children.tsx\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"YAML Entity Name Tags\",\"scope\":[\"entity.name.tag.yaml\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"JavaScript Variable Other ReadWrite\",\"scope\":[\"variable.other.readwrite.js\",\"variable.parameter\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"Support Class Component\",\"scope\":[\"support.class.component.js\",\"support.class.component.tsx\"],\"settings\":{\"foreground\":\"#aa0982\",\"fontStyle\":\"\"}},{\"name\":\"Text nested in React tags\",\"scope\":[\"meta.jsx.children\",\"meta.jsx.children.js\",\"meta.jsx.children.tsx\"],\"settings\":{\"foreground\":\"#403f53\"}},{\"name\":\"TypeScript Classes\",\"scope\":[\"meta.class entity.name.type.class.tsx\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"TypeScript Entity Name Type\",\"scope\":[\"entity.name.type.tsx\",\"entity.name.type.module.tsx\"],\"settings\":{\"foreground\":\"#111111\"}},{\"name\":\"TypeScript Class Variable Keyword\",\"scope\":[\"meta.class.ts meta.var.expr.ts storage.type.ts\",\"meta.class.tsx meta.var.expr.tsx storage.type.tsx\"],\"settings\":{\"foreground\":\"#76578b\"}},{\"name\":\"TypeScript Method Declaration e.g. `constructor`\",\"scope\":[\"meta.method.declaration storage.type.ts\",\"meta.method.declaration storage.type.tsx\"],\"settings\":{\"foreground\":\"#3b61b0\"}},{\"name\":\"normalize font style of certain components\",\"scope\":[\"meta.property-list.css meta.property-value.css variable.other.less\",\"meta.property-list.scss variable.scss\",\"meta.property-list.sass variable.sass\",\"meta.brace\",\"keyword.operator.operator\",\"keyword.operator.or.regexp\",\"keyword.operator.expression.in\",\"keyword.operator.relational\",\"keyword.operator.assignment\",\"keyword.operator.comparison\",\"keyword.operator.type\",\"keyword.operator\",\"keyword\",\"punctuation.definintion.string\",\"punctuation\",\"variable.other.readwrite.js\",\"storage.type\",\"source.css\",\"string.quoted\"],\"settings\":{\"fontStyle\":\"\"}}],\"styleOverrides\":{\"frames\":{\"editorBackground\":\"var(--sl-color-gray-7)\",\"terminalBackground\":\"var(--sl-color-gray-7)\",\"editorActiveTabBackground\":\"var(--sl-color-gray-7)\",\"terminalTitlebarDotsForeground\":\"color-mix(in srgb, var(--sl-color-gray-5), transparent 25%)\",\"terminalTitlebarDotsOpacity\":\"0.75\",\"inlineButtonForeground\":\"var(--sl-color-text)\",\"frameBoxShadowCssValue\":\"none\"},\"textMarkers\":{\"markBackground\":\"#0000001a\",\"markBorderColor\":\"#00000055\"}}}],\"defaultLocale\":\"en\",\"cascadeLayer\":\"starlight.components\",\"styleOverrides\":{\"borderRadius\":\"0px\",\"borderWidth\":\"1px\",\"codePaddingBlock\":\"0.75rem\",\"codePaddingInline\":\"1rem\",\"codeFontFamily\":\"var(--__sl-font-mono)\",\"codeFontSize\":\"var(--sl-text-code)\",\"codeLineHeight\":\"var(--sl-line-height)\",\"uiFontFamily\":\"var(--__sl-font)\",\"textMarkers\":{\"lineDiffIndicatorMarginLeft\":\"0.25rem\",\"defaultChroma\":\"45\",\"backgroundOpacity\":\"60%\"}},\"plugins\":[{\"name\":\"Starlight Plugin\",\"hooks\":{}},{\"name\":\"astro-expressive-code\",\"hooks\":{}}]}]],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false},\"legacy\":{\"collections\":false},\"prefetch\":{\"prefetchAll\":true},\"i18n\":{\"defaultLocale\":\"en\",\"locales\":[\"en\"],\"routing\":{\"prefixDefaultLocale\":false,\"redirectToDefaultLocale\":false,\"fallbackType\":\"redirect\"}}}","docs",["Map",11,12,25,26,35,36,45,46,55,56,65,66,75,76,85,86,95,96,105,106,115,116,125,126,135,136,145,146,155,156,165,166,175,176,185,186,195,196,205,206,215,216,225,226,235,236,245,246,255,256,265,266,275,276,285,286,295,296,305,306,315,316,325,326,335,336,345,346,355,356,365,366,375,376,385,386,395,396,405,406,415,416,424,425,434,435,444,445,454,455,463,464,472,473,482,483,492,493,502,503,512,513,522,523,531,532,541,542,550,551,559,560,569,570,579,580,589,590,598,599,608,609,618,619,628,629,638,639,648,649,658,659,668,669,678,679,688,689,695,696,702,703,709,710,719,720,729,730,739,740,749,750,759,760,769,770,779,780,788,789,797,798,806,807,815,816,824,825,834,835,844,845,854,855,864,865,874,875,884,885,894,895,904,905,913,914,922,923,931,932,940,941,949,950,959,960,970,971,981,982,992,993,1002,1003,1011,1012,1020,1021,1030,1031,1040,1041,1050,1051,1060,1061,1070,1071,1080,1081,1090,1091,1100,1101,1108,1109,1117,1118,1126,1127,1135,1136,1144,1145,1154,1155,1163,1164,1172,1173,1182,1183,1192,1193,1202,1203,1212,1213,1222,1223,1232,1233,1241,1242,1251,1252,1261,1262,1270,1271,1280,1281,1290,1291,1300,1301,1310,1311,1319,1320,1329,1330,1340,1341,1350,1351,1360,1361,1369,1370,1379,1380,1389,1390,1399,1400,1409,1410,1419,1420,1429,1430,1438,1439,1448,1449,1458,1459,1468,1469,1478,1479,1488,1489,1498,1499,1508,1509,1517,1518,1527,1528,1536,1537,1545,1546,1555,1556,1565,1566,1575,1576,1584,1585,1591,1592,1601,1602,1611,1612,1621,1622,1631,1632,1641,1642,1651,1652,1661,1662,1671,1672,1681,1682,1691,1692,1701,1702,1711,1712,1721,1722,1731,1732,1741,1742,1751,1752,1761,1762,1771,1772],"index",{"id":11,"data":13,"body":22,"filePath":23,"digest":24,"deferredRender":16},{"title":14,"description":15,"editUrl":16,"head":17,"template":18,"sidebar":19,"pagefind":16,"draft":20},"技術情報がすぐ見つかる StarLightDoc","StarLightDocは、Astro + Starlightで構築された高速で検索対応の技術ドキュメントサイトです。複雑な情報を効率的に整理し、開発者の課題を解決します。",true,[],"doc",{"hidden":20,"attrs":21},false,{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n## 技術ドキュメントを探すのに時間を無駄にしていませんか？\n\n散らばった情報、見つけにくいページ、古くなったドキュメントにうんざりしていませんか？ **StarLightDoc**は、そんなあなたの課題を解決するために生まれました。必要な情報に最短でたどり着き、あなたの開発を加速させます。\n\n\u003CCardGrid>\n  \u003CCard title=\"🚀 待つストレスからの解放\" icon=\"rocket\">\n    Astroによる最高のパフォーマンスで、必要な情報に一瞬でアクセス。\n  \u003C/Card>\n  \u003CCard title=\"📱 あらゆる場所で快適に\" icon=\"mobile\">\n    スマホでもタブレットでも、常に最適なレイアウトで閲覧できます。\n  \u003C/Card>\n  \u003CCard title=\"🔍 欲しい情報がすぐ見つかる\" icon=\"magnifier\">\n    強力な全文検索機能で、時間を無駄にすることなく答えにたどり着きます。\n  \u003C/Card>\n  \u003CCard title=\"💖 誰にでも優しいデザイン\" icon=\"heart\">\n    WCAG準拠のアクセシビリティで、すべてのユーザーに快適な体験を提供します。\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n## StarLightDoc が選ばれる理由\n\nこのドキュメントサイトは、あなたの開発効率を最大限に高めるために設計されています。\n\n* **検索ファースト設計**: 強力な検索機能を中心に据え、欲しい情報に最速でアクセスできる設計です。\n* **ユーザーフレンドリーなUI**: ライト・ダークモードの切り替えや、清潔で整理されたレイアウトが、長時間の閲覧でも目を疲れさせません。\n* **堅牢な技術基盤**: 静的サイト生成技術により、セキュリティとパフォーマンスを両立しています。\n* **常に最新**: コンテンツは継続的に更新され、常に正確で新しい情報を提供します。\n\n> **開発者の声**:\n> 「以前は、必要な情報を見つけるのに数十分かかっていましたが、StarLightDocの検索機能のおかげで数秒で見つけられるようになりました。本当に開発効率が上がりました！」\n> *— XXX株式会社 ソフトウェアエンジニア Y.S*\n\n---\n\n## サイトが役立つ具体的なシーン\n\nStarLightDocは、以下のような場面であなたの強力な味方になります。\n\n* **緊急のトラブル対応時**: サーバーがダウンした時、焦っていても大丈夫です。強力な全文検索で、エラーコードや現象を検索すれば、迅速に解決策を見つけ出せます。\n* **新しい技術の学習時**: チュートリアル、リファレンス、FAQが整理されたサイト構造で、初心者でも迷うことなく学習を進められます。\n* **チーム開発の効率化**: チームメンバー全員が同じドキュメントを参照することで、情報の属人化を防ぎ、スムーズな連携が可能になります。\n\n---\n\n## StarLightDocの技術と哲学\n\nこのサイトは、ただ速いだけではありません。あなたの情報収集体験を根本から変えることを目指しています。\n\n* **Astro + Starlight**: 静的サイトジェネレーションの力を最大限に活用。ビルド時にすべてのHTMLを生成することで、サーバーへの負荷を最小限に抑え、圧倒的な表示速度を実現しています。\n* **Markdownベースのコンテンツ**: コンテンツはすべてMarkdownで記述されています。これにより、シンプルでメンテナンスしやすく、常に正確な情報を維持できます。\n* **継続的な改善**: ユーザーのフィードバックを基に、UI/UXの改善、新機能の追加、コンテンツの拡充を定期的に行っています。\n\n---\n\n## StarLightDocを今すぐ体験\n\n1. **サイドバーから探す**: 左側のメニューから関心のあるトピックを選択し、探求を始めましょう。\n2. **検索ボックスを活用**: 特定のキーワードで検索し、ピンポイントで答えを見つけましょう。\n3. **関連記事から学ぶ**: 各記事の最下部にある関連リンクから、知識をさらに深めましょう。\n\n© 2025 Naoya Iijima. All rights reserved.\n\n\u003Cdiv style=\"text-align: center; margin-top: 3rem;\">\n  \u003Ca href=\"/djangoガイド/01_はじめに/01_setup/\" style=\"padding: 1rem 2rem; background-color: #007BFF; color: white; border-radius: 5px; text-decoration: none; font-weight: bold;\">今すぐドキュメントを読み始める\u003C/a>\n\u003C/div>","src/content/docs/index.mdx","c17af53a2056f064","starlightガイド/01_環境構築",{"id":25,"data":27,"body":32,"filePath":33,"digest":34,"deferredRender":16},{"title":28,"editUrl":16,"head":29,"template":18,"sidebar":30,"pagefind":16,"draft":20},"StarLight 環境構築入門",[],{"hidden":20,"attrs":31},{},"## Starlight 環境構築入門\nStarlightは、Astroを基盤としたドキュメントサイト構築のためのフレームワークです。Astroのシンプルなセットアップをさらに最適化し、美しいドキュメントサイトを素早く立ち上げることができます。このガイドでは、Starlightを使って新しいドキュメントプロジェクトを作成し、コンテンツを追加する基本的な手順を解説します。\n\n### 1. 新規プロジェクトの作成 🚀\nまず、ターミナルを開き、以下のコマンドを実行してStarlightの公式インストーラーを起動します。\n\n```bash\n# npmを使う場合\nnpm create astro@latest -- --template starlight\n```\n\nこのコマンドは、Astroのインストーラーを実行し、テンプレートとしてstarlightを直接指定します。\n\nコマンドを実行すると、対話形式でいくつかの質問が表示されます。\n\n- **Where would you like to create your new project?** (プロジェクトを作成する場所は？)\n  プロジェクト名を入力します。例: `./my-starlight-docs`\n\n- **Would you like to install dependencies?** (依存関係をインストールしますか？)\n  `y`を入力してnpmなどのパッケージをインストールします。\n\n- **Would you like to initialize a new git repository?** (Gitリポジトリを初期化しますか？)\n  バージョン管理にGitを使う場合は`y`を選択します。\n\nセットアップが完了したら、作成されたプロジェクトのディレクトリに移動します。\n\n```bash\ncd my-starlight-docs\n```\n\n### 2. 開発サーバーの起動\nプロジェクトの準備ができたので、開発サーバーを起動してみましょう。以下のコマンドを実行してください。\n\n```bash\nnpm run dev\n```\n\nサーバーが起動すると、ターミナルにローカルURL（通常は `http://localhost:4321`）が表示されます。ブラウザでこのURLにアクセスすると、Starlightのドキュメントサイトが表示されます。このサーバーにはホットリロード機能があり、リアルタイムで変更を確認できます。\n\n### 3. コンテンツの追加\nStarlightは、`src/content/docs/`ディレクトリ内のファイルをドキュメントとして扱います。MarkdownまたはMDXファイルとしてコンテンツを作成するだけで、自動的にページが生成されます。\n\n#### 新しいページの作成\n例として、「最初のページ」を作成してみましょう。`src/content/docs/`に`first-page.mdx`というファイルを作成します。\n\n```markdown\n---\ntitle: 最初のページ\ndescription: これはStarlightで作成した最初のページです。\nauthor: あなたの名前\ndate: 2023-10-01\ntags: [Starlight, Astro, ドキュメント]\nversion: 1.0\ncategory: ガイド\nlayout: default\nstatus: published\n---\n\n# Starlightへようこそ！\n\nこれはStarlightで作成した最初のドキュメントページです。\n\n**太字**や*斜体*など、通常のMarkdown構文を使ってコンテンツを記述できます。\n```\n\nファイルを保存すると、開発サーバーが自動的に更新され、サイドバーに新しいページが表示されます。\n\n#### フロントマターについて\nMarkdownファイルの冒頭にある`---`で囲まれた部分はフロントマターと呼ばれ、ページのメタデータを定義します。`title`や`description`は必須項目です。\n\n### Starlight フロントマター完全リファレンス ✨\n\n#### 必須プロパティ\n| プロパティ名 | 型 | 説明 |\n| --- | --- | --- |\n| title | string | ページのタイトル。ブラウザのタブやサイドバーに表示されます。 |\n| description | string | ページの要約。SEOのメタタグとして使用されます。 |\n\n\n#### レイアウトと表示に関するプロパティ\n| プロパティ名 | 型 | 説明 |\n| --- | --- | --- |\n| editUrl | boolean or string | ページ編集リンクの表示を制御します。falseで非表示、trueでデフォルトのGitHubリンク、stringでカスタムURLを設定します。 |\n| tableOfContents | boolean or object | ページの目次（TOC）を表示するか、およびどのレベルの見出しまで表示するかを制御します。 |\n| template | 'doc' or 'splash' | ページのレイアウトテンプレートを指定します。splashはランディングページ用で、ヒーローセクションを表示します。 |\n| head | HeadConfig[] | ページの \u003Chead>\u003C/head> 要素にカスタムタグを追加します。外部スタイルシートやスクリプトの読み込みに便利です。 |\n| hero | HeroConfig | template: 'splash'指定時にヒーローセクションを設定します。titleやtagline、actionsなどを定義できます。 |\n\n#### ナビゲーションに関するプロパティ\n| プロパティ名 | 型 | 説明 |\n| --- | --- | --- |\n| sidebar | object | サイドバーの表示をカスタマイズします。labelで表示名を、orderで表示順を、badgeでバッジを制御します。 |\n| lastUpdated | boolean | ページの最終更新日を表示するかどうかを制御します。 |\n| prev | boolean or SidebarLink | ページ下部に前のページへのリンクを表示するかを制御します。 |\n| next | boolean or SidebarLink | ページ下部に次のページへのリンクを表示するかを制御します。 |\n| pagination | boolean | ページ下部に前後のページリンクを表示するかをまとめて制御します。 |\n\n#### コンテンツのメタデータと表示オプション\n| プロパティ名 | 型 | 説明 |\n| --- | --- | --- |\n| pagefind | boolean | このページを検索インデックスに含めるかどうかを制御します。 |\n| slug | string | ページのURLをカスタマイズします。ファイル名とは異なるURLを設定できます。 |\n| lang | string | ページの言語コードを設定します。多言語サイトで使用します。 |\n\n\n#### サイドバーのカスタマイズ\nサイドバーの表示順やグループ分けは、`src/content/config.ts`で設定します。これにより、ドキュメントの構成を整理できます。\n\n```typescript\nimport { defineCollection } from 'astro:content';\nimport { docsSchema } from '@astrojs/starlight/schema';\n\nexport const collections = {\n  docs: defineCollection({\n    schema: docsSchema({\n      // サイドバーのカスタマイズ\n      sidebar: [\n        {\n          label: 'はじめに',\n          items: [\n            { label: '最初のページ', link: '/first-page/' },\n            { label: 'もう一つのページ', link: '/another-page/' },\n          ],\n        },\n      ],\n    }),\n  }),\n};\n```\n\nStarlightは、ドキュメントの作成と管理を非常に簡単にする強力なツールです。このシンプルなセットアップから始めて、独自のドキュメントサイトを構築しましょう。","src/content/docs/StarLightガイド/01_環境構築.mdx","a76dfcc5ee30a4c6","starlightガイド/00_astroとは",{"id":35,"data":37,"body":42,"filePath":43,"digest":44,"deferredRender":16},{"title":38,"editUrl":16,"head":39,"template":18,"sidebar":40,"pagefind":16,"draft":20},"Astro とは",[],{"hidden":20,"attrs":41},{},"## Astro とは\nAstro は、コンテンツ駆動型のウェブサイトを構築するためのモダンなウェブフレームワークです。静的サイト生成（SSG）を主な得意分野とし、ブログ、マーケティングサイト、ドキュメントサイトなどに最適です。特に、JavaScriptを最小限に抑えることで、非常に高速なウェブサイトを生成できるのが最大の特徴です。\n\n### Astro の主な機能と特徴\n\n1. **コンテンツファースト ✍️**\n   Astro はコンテンツを最優先に設計されています。Markdown、MDX、そしてAstroコンポーネントを使って、直感的にコンテンツを作成できます。\n\n2. **JavaScript ゼロの理念 🚀**\n   デフォルトでは、Astro はクライアントサイドに JavaScript を送りません。これにより、ウェブサイトの読み込み速度が大幅に向上し、パフォーマンスとSEOに大きなメリットをもたらします。\n\n3. **アイランドアーキテクチャ 🏝️**\n   インタラクティブなコンポーネントが必要な場合、Astro はその部分だけを個別の「アイランド」として分離し、JavaScriptを最小限にロードします。これにより、ページ全体がJavaScriptに依存するのを防ぎます。\n\n4. **UIフレームワークのサポート 🧩**\n   React, Vue, Svelte, SolidJS など、お好みの UI フレームワークのコンポーネントを Astro プロジェクト内でシームレスに利用できます。\n\n5. **サーバーサイドレンダリング (SSR) 🖥️**\n   静的サイト生成だけでなく、SSRにも対応しています。これにより、ユーザーごとにパーソナライズされたコンテンツや、リアルタイムなデータを含むページを生成できます。\n\n### Astro コンポーネントの基本\nAstro のUIは、`.astro`拡張子のコンポーネントを使って構築されます。\n\n- **コンポーネントスクリプト**: `---` で囲まれた部分に JavaScript/TypeScript を記述します。データの受け渡しや外部APIからのデータ取得など、ページのロジックを担当します。\n\n- **コンポーネントテンプレート**: スクリプト部分の下に、HTMLやJSXライクな構文でUIを記述します。\n\n- **コンポーネントスタイル**: `\u003Cstyle>` タグで CSS を記述します。デフォルトでスコープ化されるため、他のコンポーネントに影響を与えません。\n\n#### コンポーネントの例\n\n```astro\n---\n// Propsとしてタイトルを受け取ります\nconst { title } = Astro.props;\n---\n\u003Ch1>{title}\u003C/h1>\n\u003Cstyle>\n  h1 {\n    color: #333;\n  }\n\u003C/style>\n```\n\n### Astro でできること\n- **ブログ・ポートフォリオサイト**: 静的サイト生成の強みを活かし、超高速なブログやポートフォリオサイトを構築できます。\n\n- **ドキュメントサイト**: Starlight と呼ばれる公式のフレームワークを使えば、プロフェッショナルなドキュメントサイトを簡単に作成できます。\n\n- **ECサイト・ランディングページ**: JavaScriptを最小限に抑えることで、商品の表示速度を上げ、コンバージョン率を高められます。\n\nAstro は、パフォーマンスと開発者の体験を両立させたい場合に非常に適した選択肢です。この解説で Astro の全体像を掴んでいただければ幸いです。","src/content/docs/StarLightガイド/00_astroとは？.mdx","041b3e1fc25ef575","starlightガイド/02_component_creation",{"id":45,"data":47,"body":52,"filePath":53,"digest":54,"deferredRender":16},{"title":48,"editUrl":16,"head":49,"template":18,"sidebar":50,"pagefind":16,"draft":20},"コンポーネントの作成",[],{"hidden":20,"attrs":51},{},"import Button from './components/Button.tsx';\n\n## Astroコンポーネントの基本\nAstroコンポーネントは、ウェブサイトのUIを再利用可能な部品に分割して構築します。HTML、CSS、JavaScriptを一つのファイルにまとめられるのが特徴です。これにより、コードの再利用性が向上し、保守が容易になります。\n\n### ユースケース：静的なブログカード\nブログ記事の一覧ページを考えてみましょう。各記事のタイトルや概要を表示するカードは、すべての記事で同じデザインと構造になります。このような場合に、`BlogCard.astro`コンポーネントを作成すれば、コードを何度も書く必要がなくなります。\n\n#### src/components/BlogCard.astro\n\n```astro\n---\n// 親から title と description を受け取ります\nconst { title, description } = Astro.props;\n---\n\u003Cdiv class=\"card\">\n  \u003Ch2>{title}\u003C/h2>\n  \u003Cp>{description}\u003C/p>\n\u003C/div>\n\n\u003Cstyle>\n  .card {\n    border: 1px solid #ccc;\n    padding: 1rem;\n    border-radius: 8px;\n  }\n\u003C/style>\n```\n\nこのコンポーネントを、複数の記事で再利用できます。\n\n#### src/pages/index.astro\n\n```astro\n---\nimport BlogCard from '../components/BlogCard.astro';\n---\n\u003Ch1>最新記事\u003C/h1>\n\u003CBlogCard title=\"Astro入門\" description=\"Astroの基本を学びましょう。\" />\n\u003CBlogCard title=\"コンポーネントの作成\" description=\"コンポーネントの作り方を紹介します。\" />\n```\n\nこの方法では、JavaScriptはサーバー側で実行され、最終的なHTMLのみがブラウザに送られます。これにより、ページの表示が高速になります。\n\n### UIフレームワークとの統合とJavaScriptの適用\nAstroの強みは、UIフレームワークのコンポーネントを静的なHTMLに埋め込むことができる点です。しかし、クリックイベントなどのユーザーインタラクションが必要なコンポーネントは、クライアントサイドでJavaScriptを有効にする必要があります。\n\n#### ユースケース：インタラクティブなカウンター\nユーザーがボタンをクリックするたびに数字が増えるカウンターを考えてみましょう。これは、JavaScriptなしでは実現できません。ここでは、Reactコンポーネントを使ってみます。\n\n##### Reactの追加\nまず、`@astrojs/react`インテグレーションを追加します。\n\n```bash\nnpx astro add react\n```\n\n##### Reactコンポーネントの作成\n`src/components/Button.tsx`というファイルに、Reactでカウンターコンポーネントを作成します。\n\n```javascript\nimport { useState } from \"react\"\n\nconst Button = () => {\n    const [count, setCount] = useState(0)\n\n    const handleClick = () => {\n        setCount(count + 1)\n    }\n\n  return (\n    \u003Cdiv>\n      \u003Cbutton onClick={handleClick}>\n        Count{count}\n      \u003C/button>\n      \u003Cp>Count: {count}\u003C/p>\n    \u003C/div>\n  )\n}\n\nexport default Button  \n```\n\n##### Astroページでの利用\n作成した`Button.tsx`をAstroページにインポートし、`client:load`ディレクティブを追加します。これにより、ページが読み込まれた後にJavaScriptが有効になり、インタラクティブな機能が使えるようになります。\n\n#### src/pages/counter-page.astro\n\n```astro\n---\nimport Button from './components/Button.tsx';\n---\n\u003Cbody>\n  \u003Ch1>カウンターページ\u003C/h1>\n  \u003CButton client:load />\n\u003C/body>\n```\n\n### mdxファイルの場合\n\n```mdx\nimport Button from './components/Button.tsx';\n\n// コンテンツの内容\n\n\u003CButton client:load />\n\n```\n\u003CButton client:load />\n\n\nこのように、Astroは静的な部分と動的な部分を分離し、必要な部分にだけJavaScriptを適用することで、パフォーマンスを最適化します。`client:load`以外にも、コンポーネントが画面に入ったときにロードする`client:visible`など、複数のディレクティブがあり、ユースケースに応じて使い分けることができます。","src/content/docs/StarLightガイド/02_component_creation.mdx","2c9b2c926f09d5bf","starlightガイド/04_performance_optimization",{"id":55,"data":57,"body":62,"filePath":63,"digest":64,"deferredRender":16},{"title":58,"editUrl":16,"head":59,"template":18,"sidebar":60,"pagefind":16,"draft":20},"パフォーマンス最適化",[],{"hidden":20,"attrs":61},{},"## パフォーマンス最適化\nAstroのビルドプロセスを最適化するためのベストプラクティスを紹介します。これらの手法を組み合わせることで、ウェブサイトの読み込み速度とユーザーエクスペリエンスを大幅に向上させることができます。\n\n### 1. 画像の最適化\n画像はウェブサイトのパフォーマンスに最も大きな影響を与える要素の一つです。Astroでは公式の`@astrojs/image`インテグレーションを使用することで、画像の最適化を自動化できます。\n\n- **@astrojs/imageの利用**:\n  ```bash\n  npx astro add @astrojs/image\n  ```\n  これにより、画像のサイズ変更、フォーマット変換（WebP, AVIFなど）、遅延ロードを自動的に処理できます。\n\n- **レスポンシブな画像の生成**:\n  `astro:assets`コンポーネントを使うと、異なる画面サイズに対応した`srcset`属性が自動的に生成されます。これにより、ユーザーのデバイスに最適なサイズの画像が配信されます。\n\n  ```astro\n  ---\n  import { Image } from 'astro:assets';\n  import myImage from '../assets/my-image.jpg';\n  ---\n  \u003CImage src={myImage} alt=\"My awesome image\" width={500} height={300} />\n  ```\n\n### 2. コードスプリッティング\nAstroは「アイランドアーキテクチャ」という独自の仕組みを採用しており、デフォルトでページごとにJavaScriptを分割（コードスプリッティング）します。これにより、必要なコンポーネントのJavaScriptだけがロードされ、ページの軽量化が図られます。\n\n- **動的インポート (Dynamic Imports)**:\n  特定の条件下でのみ必要なコンポーネントやライブラリは、動的にインポートすることで、初期ロード時のJavaScriptサイズをさらに削減できます。例えば、ボタンをクリックしたときにだけ表示されるモーダルなどに有効です。\n\n  ```astro\n  ---\n  const HeavyComponent = Astro.Component(() => import('../components/HeavyComponent.astro'));\n  ---\n  \u003Cbutton id=\"show-modal\">Show Modal\u003C/button>\n  \u003CHeavyComponent />\n  ```\n\n### 3. その他の最適化手法\n- **CDN (Contents Delivery Network) の活用**:\n  コンテンツを世界中のサーバーに分散配置することで、ユーザーに最も近いサーバーからコンテンツを配信し、読み込み時間を短縮します。\n\n- **キャッシュの設定**:\n  HTTPヘッダーの`Cache-Control`を設定することで、ブラウザが一度ダウンロードしたアセットを再利用できるようにし、再訪問時の読み込みを高速化します。\n\n- **サードパーティスクリプトの遅延ロード**:\n  Google Analyticsや広告スクリプトなどの外部スクリプトは、ページのレンダリングをブロックする可能性があります。`async`や`defer`属性を使って、これらのスクリプトを非同期で読み込むことで、初期表示速度を改善できます。\n\n- **アセットの圧縮とミニファイ**:\n  CSS、JavaScript、HTMLを圧縮し、不要な空白やコメントを削除することでファイルサイズを削減します。Astroはデフォルトでこれらの処理を自動的に行います。\n\n### 4. サーバーサイドレンダリング (SSR) の活用\nAstro が SSR をサポートしている場合、サーバー側でデータを取得・処理し、完成した HTML をクライアントに送信できます。これにより、ブラウザでの JavaScript 実行を最小限に抑え、ページの初期表示を高速化できます。\n\n- **ユースケース**: API からデータを取得して動的なページを生成する場合。\n\n  例: ブログ記事一覧を API から取得する際、ビルド時にすべての記事を静的に生成する代わりに、SSR を利用してユーザーがアクセスしたときに最新のデータをフェッチしてレンダリングします。これにより、頻繁に更新されるコンテンツでも常に最新の状態を保ちつつ、クライアント側でのデータ取得処理をなくせます。\n\n### 5. プリフェッチ\nAstro では、リンクに`data-astro-prefetch`属性を追加することで、ユーザーが次にアクセスする可能性のあるページを事前に読み込んでおくことができます。これにより、次のページへの遷移が非常に速く感じられます。\n\n- **ユースケース**: ナビゲーションメニューや記事一覧ページなど、ユーザーが次にクリックする可能性が高いリンクに使用します。\n\n  ```html\n  \u003Ca href=\"/about\" data-astro-prefetch>About Us\u003C/a>\n  ```\n\n  ユーザーがこのリンクにマウスオーバーするか、一定時間アイドル状態になると、Astro は `/about` ページの HTML とアセットをバックグラウンドでプリロードします。\n\n### 6. HTTP/2 または HTTP/3 の利用\n現代のウェブサーバーは、HTTP/2 や HTTP/3 をサポートしており、従来の HTTP/1.1 よりも効率的にデータを転送できます。これらのプロトコルは、単一の接続で複数のリクエストを同時に処理するため、アセットの並列ダウンロードが可能です。\n\n- **ユースケース**: 多くの画像やスクリプトをロードするページで、ブラウザが一度にすべてのリソースをダウンロードできるようになります。\n\n- **設定**: ほとんどのモダンなホスティングサービス（Vercel, Netlify, Cloudflare など）は、デフォルトで HTTP/2 をサポートしています。サーバーを自分で設定する場合は、ウェブサーバー（Nginx, Apache など）で HTTP/2 を有効にする必要があります。\n\n### 7. Web フォントの最適化\nウェブフォントはデザインに不可欠ですが、適切に扱わないとページの読み込みを遅くする原因になります。\n\n- **対策**:\n  - **フォントのサブセット化**: 必要な文字だけを含むようにフォントをサブセット化することで、ファイルサイズを削減できます。\n  - **font-display プロパティの使用**: CSS の `@font-face` ルールに `font-display: swap;` を追加することで、ウェブフォントが読み込まれるまでの間、代替フォントを表示し、コンテンツの表示をブロックしないようにできます。\n\n### 8. PWA (Progressive Web Apps) の導入\nPWAは、ウェブサイトにネイティブアプリのような体験を提供する技術です。\n\n- **サービスワーカーの活用**:\n  PWAの中核となるサービスワーカーを利用することで、ウェブサイトをオフラインでも利用できるようにしたり、初回訪問時のアセットをキャッシュして再訪問時の読み込みを高速化したりできます。Astroでは、`astro-pwa`のようなインテグレーションを使ってPWA機能を簡単に追加できます。\n\nこれらの手法を組み合わせることで、ユーザーに高速で快適なウェブ体験を提供することができます。","src/content/docs/StarLightガイド/04_performance_optimization.mdx","4519bab194bf45c9","starlightガイド/05_seo_optimization",{"id":65,"data":67,"body":72,"filePath":73,"digest":74,"deferredRender":16},{"title":68,"editUrl":16,"head":69,"template":18,"sidebar":70,"pagefind":16,"draft":20},"SEO対策",[],{"hidden":20,"attrs":71},{},"## AstroサイトのSEO完全ガイド\nAstroは、デフォルトで超高速なサイトを生成するため、SEO（検索エンジン最適化）において非常に有利です。ここでは、Astroプロジェクトの検索エンジン順位をさらに向上させるための具体的な設定方法を詳しく解説します。\n\n### 1. 基本的なメタタグの設定\nメタタグは、ページの内容を検索エンジンやSNSに伝えるための重要な情報です。これらを一元管理するために、再利用可能な`SEO.astro`コンポーネントを作成するのが最も効率的です。\n\n#### SEOコンポーネントの作成\n`src/components/SEO.astro` に以下のファイルを作成します。\n\n```astro\n---\nimport type { GetImageResult } from 'astro:assets';\n\ninterface Props {\n  title: string;\n  description: string;\n  image?: GetImageResult;\n}\n\nconst { title, description, image } = Astro.props;\nconst canonicalUrl = new URL(Astro.url.pathname, Astro.site);\n---\n\u003Cmeta charset=\"utf-8\" />\n\u003Cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n\u003Ctitle>{title}\u003C/title>\n\u003Cmeta name=\"description\" content={description} />\n\u003Clink rel=\"canonical\" href={canonicalUrl} />\n\n\u003Cmeta property=\"og:title\" content={title} />\n\u003Cmeta property=\"og:description\" content={description} />\n\u003Cmeta property=\"og:url\" content={canonicalUrl} />\n\u003Cmeta property=\"og:type\" content=\"website\" />\n{image && \u003Cmeta property=\"og:image\" content={new URL(image.src, Astro.site)} />}\n\n\u003Cmeta name=\"twitter:card\" content=\"summary_large_image\" />\n\u003Cmeta name=\"twitter:title\" content={title} />\n\u003Cmeta name=\"twitter:description\" content={description} />\n{image && \u003Cmeta name=\"twitter:image\" content={new URL(image.src, Astro.site)} />}\n```\n\n#### SEOコンポーネントの利用\n作成したコンポーネントを、各ページの`\u003Chead>`内で呼び出します。\n\n```astro\n---\nimport SEO from '../components/SEO.astro';\n---\n\u003Chtml lang=\"ja\">\n  \u003Chead>\n    \u003CSEO\n      title=\"私のAstroサイト | トップページ\"\n      description=\"Astroで作ったサイトのトップページです。SEO対策をしています。\"\n    />\n  \u003C/head>\n  \u003Cbody>\n    \u003Cslot />\n  \u003C/body>\n\u003C/html>\n```\n\n### 2. サイトマップとrobots.txt\nサイトマップは、サイト内の全ページのリストを検索エンジンに伝え、クロール（情報収集）を効率化させるためのファイルです。`robots.txt`は、どのページをクロールしてよいかを指示します。\n\n#### サイトマップの自動生成\nAstroでは、`@astrojs/sitemap`インテグレーションを使って簡単にサイトマップを自動生成できます。\n\n- **インストール**: `npx astro add sitemap`を実行します。\n- **設定**: `astro.config.mjs`にサイトの公開ドメインを設定します。\n\n```javascript\n// astro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport sitemap from '@astrojs/sitemap';\n\nexport default defineConfig({\n  site: 'https://www.example.com',\n  integrations: [sitemap()],\n});\n```\n\n#### robots.txtの設置\n`public/`ディレクトリに`robots.txt`というファイルを作成し、サイトマップの場所を通知します。\n\n```plaintext\nUser-agent: *\nAllow: /\n\nSitemap: https://www.example.com/sitemap-index.xml\n```\n\n### 3. コアウェブバイタルの最適化\nGoogleは、ユーザー体験を測る指標であるコアウェブバイタルをSEOランキングの要因としています。Astroはデフォルトで高速ですが、これらの指標を意識することで、さらに有利になります。\n\n- **LCP (Largest Contentful Paint)**: ページの主要なコンテンツが読み込まれるまでの時間。\n  - **対策**: `\u003CImage />`コンポーネントで画像を最適化し、ヒーロー画像にはプリロードを検討します。\n\n- **FID (First Input Delay)**: 最初のユーザー入力に対する応答時間。\n  - **対策**: `client:load`ではなく、`client:visible`や`client:idle`ディレクティブを使い、JavaScriptのロードを遅延させることで、初期の応答性を高めます。\n\n- **CLS (Cumulative Layout Shift)**: ページの読み込み中に予期せぬレイアウトのずれがないか。\n  - **対策**: 画像や広告には必ず`width`と`height`を指定し、スペースを確保します。\n\n### 4. 構造化データとコンテンツ戦略\nテクニカルな設定だけでなく、コンテンツそのものも重要です。\n\n- **構造化データ (JSON-LD)**: ページの内容をより詳細に検索エンジンに伝え、リッチリザルト（検索結果に星マークや価格などが表示される）を期待できます。\n  - **対策**: ブログ記事や商品ページなど、コンテンツタイプに応じた`\u003Cscript type=\"application/ld+json\">`をページの`\u003Chead>`に追加します。\n\n- **内部リンク**: サイト内のページ同士を関連性の高いアンカーテキストで結びつけ、クローラーが効率的に巡回できるようにします。\n\n- **パンくずリスト**: ナビゲーションを分かりやすくすることで、ユーザー体験が向上し、検索エンジンにもサイトの階層構造を伝えることができます。\n\n### 5. SEOの監視と分析\n設定が完了したら、その効果を測定し、改善を繰り返すことが不可欠です。\n\n- **Google Search Console**: サイトマップの提出、クローラーのエラーチェック、検索キーワードの分析など、SEOの状況を把握するための必須ツールです。\n\n- **Google Analytics**: ユーザーの行動を分析し、コンテンツの改善に役立てます。\n\n- **ページスピードインサイト**: コアウェブバイタルやパフォーマンスに関する具体的な改善点を指摘してくれます。","src/content/docs/StarLightガイド/05_seo_optimization.mdx","3961114b249fbb06","starlightガイド/06_クローラの補足",{"id":75,"data":77,"body":82,"filePath":83,"digest":84,"deferredRender":16},{"title":78,"editUrl":16,"head":79,"template":18,"sidebar":80,"pagefind":16,"draft":20},"SEO対策(クローラ)",[],{"hidden":20,"attrs":81},{},"SEO対策(クローラ)統合版\n\n## robots.txtの基本\n\n### robots.txtサンプルの各行の解説\n\n```txt\nUser-agent: *\nDisallow: /private/\nAllow: /public/\n\nSitemap: http://example.com/sitemap.xml\n```\n\n- **User-agent: \\***\n  - このルールがすべてのクローラー（ユーザーエージェント）に適用されることを意味します。*はワイルドカードです。特定のクローラー（例：User-agent: Googlebot）を指定することもできます。\n- **Disallow: /private/**\n  - /private/ディレクトリとその中のすべてのファイルについて、クロールしないよう指示しています。これにより、検索結果に表示されたくないページ（例：管理ページ、ユーザー専用ページ）を保護できます。\n- **Allow: /public/**\n  - /public/ディレクトリのクロールを許可する指示です。Disallowルールがより広範なディレクトリを対象としている場合（例：Disallow: /）に、特定のサブディレクトリだけを例外的に許可するために使用されます。\n- **Sitemap: http://example.com/sitemap.xml**\n  - このサイトのXMLサイトマップファイルの場所をクローラーに伝えます。サイトマップは、クローラーがサイトのすべての重要なページを効率的に発見し、インデックスに登録するのに役立ちます。\n\n**注意**: robots.txtはあくまで「リクエスト」（お願い）であり、強制力はありません。悪意のあるクローラーや、robots.txtのルールを無視するように設定されたクローラーは、指定されたディレクトリにアクセスする可能性があります。機密性の高い情報は、パスワード保護や他の認証メカニズムで保護する必要があります。\n\n## XMLサイトマップとは？\n\nXMLサイトマップは、ウェブサイト上の重要なURLをリストアップしたファイルです。サイトマップをGoogle Search Consoleに登録することで、クローラーが効率的にサイトを巡回し、新しいページや更新されたページを見つけやすくなります。これにより、インデックス登録が促進されます。\n\n### なぜXMLサイトマップが必要なのか？\n\n- **クローラーに新しいページや更新を伝える**: サイト内に新しいコンテンツを追加したり、既存のページを更新したりした場合、サイトマップを更新することで、クローラーにその変更を迅速に伝えることができます。\n- **サイト構造を理解させる**: サイトの階層が複雑な場合でも、サイトマップはクローラーにすべての重要なページを教える地図のような役割を果たします。これにより、内部リンクが少ないページでも発見されやすくなります。\n- **大規模サイトのクロール効率を上げる**: 数千、数万ページもあるような大規模サイトでは、すべてのページをクローラーに発見させるのは困難です。サイトマップはクロールバジェットを最適化する上で不可欠なツールとなります。\n\n## robots.txt以外のクローラー制御\n\n### X-Robots-Tag\n\nHTTPレスポンスヘッダーでクローラーへの指示を伝える方法です。robots.txtがファイルやディレクトリ単位でしか制御できないのに対し、X-Robots-Tagはファイル単位でより細かく、強制力のある指示を出せます。\n\n- **noindex**: このページを検索エンジンのインデックスに登録しないよう指示\n- **nofollow**: このページにあるリンクをたどらないよう指示\n\n#### Apache (.htaccess) の設定例\n\n```apache\n\u003CIfModule mod_headers>\n  Header set X-Robots-Tag \"noindex, nofollow\"\n\u003C/IfModule>\n```\n\n#### Node.js (Express) での適用例\n\n```javascript\napp.get('/admin', (req, res) => {\n  res.setHeader('X-Robots-Tag', 'noindex, nofollow');\n  res.send('管理ページです。');\n});\n```\n\n### meta robotsタグ\n\nHTMLの`\u003Chead>\u003C/head>`セクションにmetaタグを挿入することで、特定のページに対するクロール指示を出すことができます。\n\n```html\n\u003Chead>\n  \u003Cmeta name=\"robots\" content=\"noindex, nofollow\" />\n\u003C/head>\n```\n\n## 制御方法の使い分け\n\n| 方法          | 制御範囲                | 目的                          | 強制力     |\n|---------------|-------------------------|-------------------------------|------------|\n| robots.txt    | ドメイン全体、ディレクトリ | クロールの制御（サーバー負荷軽減） | 弱い（お願い） |\n| X-Robots-Tag  | ファイル単位、ページ単位  | インデックス登録の制御（検索結果からの除外） | 強い（強制） |\n| meta robots   | ページ単位              | インデックス登録の制御（検索結果からの除外） | 強い（強制） |\n\n## クロールバジェット（Crawl Budget）\n\nクロールバジェットは、検索エンジンのクローラーが特定のサイトで1日にクロールできるURLの数の上限を指します。\n\n### 最適化の方法\n\n- **無駄なURLを排除**: フィルタリングやセッションIDなど、重複または重要ではないURLをrobots.txtでDisallowに設定\n- **サイトマップの更新**: 主要なページをすべて含んだサイトマップを常に最新の状態に保つ\n- **内部リンクの最適化**: 重要なページには、サイト内の他のページから多くの内部リンクを設置\n\n## URL正規化（Canonicalization）\n\n複数のURLで同じコンテンツにアクセスできる場合に、検索エンジンにどのURLが正規であるかを伝えるプロセス。\n\n### rel=\"canonical\"タグ\n\n```html\n\u003Chead>\n    \u003Clink rel=\"canonical\" href=\"http://example.com/product/item1\">\n\u003C/head>\n```\n\n### 301リダイレクト\n\n#### Apache (.htaccess) の設定例\n\n```apache\nRewriteEngine On\nRewriteCond %{HTTPS} off\nRewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]\n```\n\n#### Node.js (Express) でのリダイレクト例\n\n```javascript\napp.get('/about', (req, res) => {\n  res.redirect(301, '/about/');\n});\n```\n\n## SEOの分類\n\n### 1. 内部対策（On-Page SEO）\n\n- **キーワードの最適化**: タイトル、見出し、URL、本文に適切なキーワードを含める\n- **メタ情報の最適化**: titleタグ、meta descriptionの設定\n- **内部リンクの最適化**: 関連性の高いページ同士をリンクでつなぐ\n- **サイトの階層構造**: 論理的で分かりやすいサイト構造を構築\n\n### 2. 外部対策（Off-Page SEO）\n\n- **被リンクの獲得**: 他の信頼できるサイトからのリンクを増やす\n- **サイテーション**: サイト名や会社名が他のサイトで言及されること\n\n### 3. Googleが重視するその他の要素\n\n- **E-E-A-T（経験・専門性・権威性・信頼性）**\n  - **Experience（経験）**: 実際にそのトピックを体験した人が書いているか\n  - **Expertise（専門性）**: そのトピックに関して専門的な知識を持っているか\n  - **Authoritativeness（権威性）**: 業界やユーザーから権威と認められているか\n  - **Trust（信頼性）**: 情報が正確で信頼できるか\n\n- **Core Web Vitals**\n  - **LCP (Largest Contentful Paint)**: ページの主要なコンテンツが表示されるまでの時間\n  - **FID (First Input Delay)**: ユーザーが最初に操作した際の応答速度\n  - **CLS (Cumulative Layout Shift)**: ページの読み込み中にレイアウトがどれだけずれるか\n\n## 技術的な最適化\n\n### 1. ページスピードの最適化\n\n- **画像の最適化**: WebP形式、遅延読み込み（Lazy Load）\n- **レンダリングブロックリソースの削減**: CSSのインライン化、JavaScriptの非同期化\n\n### 2. 構造化データの利用\n\n- リッチリザルトの獲得により、検索結果での視認性を向上\n\n### 3. セキュリティとHTTPS化\n\n- HTTPS（SSL/TLS）は、Googleがランキング要因として公式に発表\n\n## サイトの技術的な健全性（Technical SEO）\n\n- **XMLサイトマップ**\n  - サイト内の重要なページのURLをリスト化し、Google Search Consoleに送信\n- **HTTPS化**\n  - サイトの通信を暗号化し、ユーザーの個人情報を保護\n\n## ローカルSEO\n\n- **Googleビジネスプロフィール**: 営業時間、住所、電話番号、レビューを管理\n- **NAP情報の統一**: Name（名称）、Address（住所）、Phone（電話番号）を統一\n- **ローカルキーワードの最適化**: 地域名とサービスを組み合わせたキーワード\n\n## ユーザーエンゲージメントの向上\n\n### 主要指標\n\n- **直帰率（Bounce Rate）**: ユーザーが最初のページを見ただけでサイトを離れる割合\n- **滞在時間（Dwell Time）**: ユーザーがサイトに滞在する時間\n- **クリック率（CTR）**: 検索結果に表示された際のクリック率\n\n## 高度なSEO戦略\n\n### 1. 国際SEO（International SEO）\n\n- **hreflangタグ**: 同じコンテンツの別言語版や別地域版のURLを指定\n- **地域ターゲティング**: 国別ドメインやGoogle Search Consoleでの設定\n\n### 2. ログファイルの分析\n\n- **クロール状況の把握**: クローラーの挙動を直接的に理解\n- **無駄なクロールの発見**: クロールバジェットの最適化\n- **新しいページの発見速度**: 改善策の実施\n\n### 3. 生成AIとの連携\n\n- **音声検索の最適化**: 会話的なキーワードの利用、強調スニペットの獲得\n- **セマンティック・サーチへの対応**: 関連キーワードや概念を網羅的に含む\n\n## まとめ\n\nSEO対策は、技術的な設定だけでなく、ユーザーにとって価値のあるコンテンツを提供し、サイト全体の品質を高めることが最も重要です。robots.txtはクロールの交通整理係であり、metaタグやX-Robots-Tagは検索エンジンへの強制的な指示だと考えると分かりやすいでしょう。\n\n最終的に、SEOは「検索エンジンは、ユーザーの役に立つサイトを評価する」という根本原則に立ち返り、ユーザーに最高の体験を提供することに注力することが、最も強力なSEO対策になります。","src/content/docs/StarLightガイド/06_クローラの補足.mdx","e1159f610101f352","typescriptガイド/00_setup",{"id":85,"data":87,"body":92,"filePath":93,"digest":94,"deferredRender":16},{"title":88,"editUrl":16,"head":89,"template":18,"sidebar":90,"pagefind":16,"draft":20},"setup",[],{"label":88,"hidden":20,"attrs":91},{},"## 1. TypeScriptのインストール 🛠️\n\nまず、プロジェクトのルートディレクトリでTypeScriptをグローバルまたはローカルにインストールします。プロジェクトごとにバージョンを管理するため、ローカルインストールが推奨されます。\n\n```bash\nnpm install -g typescript  # グローバルインストール\nnpm install --save-dev typescript  # ローカルインストール（推奨）\n```\n\n次に、以下のコマンドでTypeScriptの設定ファイル `tsconfig.json` を生成します。\n\n```bash\ntsc --init\n```\n\n`tsconfig.json` には、コンパイルオプション（出力ディレクトリ、ESバージョンなど）を設定します。\n\n## 2. バックエンド (BE) のセットアップ ⚙️\n\nバックエンドでは、主にNode.jsとExpress.js環境でのセットアップを想定して解説します。\n\n### a. プロジェクトの初期化\n\nまず、新しいディレクトリを作成し、`package.json` ファイルを生成します。\n\n```bash\nmkdir my-ts-backend\ncd my-ts-backend\nnpm init -y\n```\n\n### b. 必要なパッケージのインストール\n\nExpress.js、型定義ファイル、そしてビルドツールをインストールします。\n\n- `express`: Webサーバーフレームワーク\n- `@types/express`, `@types/node`: ExpressとNode.jsの型定義ファイル\n- `ts-node`: TypeScriptを直接実行するためのランタイム\n- `nodemon`: 開発中のファイル変更を監視してサーバーを自動再起動\n\n```bash\nnpm install express\nnpm install --save-dev @types/express @types/node ts-node nodemon\n```\n\n### c. tsconfig.json の設定\n\n`tsconfig.json` を開いて、TypeScriptがコンパイルしたJavaScriptファイルを保存するディレクトリを設定します。\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"./dist\",  // コンパイルされたJSファイルの出力先\n    \"strict\": true,\n    \"esModuleInterop\": true\n  },\n  \"include\": [\"src/**/*\"] // コンパイル対象のファイルを指定\n}\n```\n\n### d. 開発スクリプトの追加\n\n`package.json` に開発用スクリプトを追加します。\n\n```json\n\"scripts\": {\n  \"start\": \"node dist/index.js\",\n  \"dev\": \"nodemon --watch 'src/**/*.ts' --exec 'ts-node' src/index.ts\",\n  \"build\": \"tsc\"\n}\n```\n\n- `dev`: 開発中にファイルが変更されると、`nodemon`が`ts-node`を使って自動的にサーバーを再起動します。\n- `build`: TypeScriptファイルをJavaScriptにコンパイルし、`dist`ディレクトリに出力します。\n\n## 3. フロントエンド (FE) のセットアップ 🖥️\n\nフロントエンドでは、ReactとVue.jsでのセットアップを想定して解説します。\n\n### a. React + TypeScript\n\n`create-react-app` を使用すると、TypeScript環境が最初からセットアップされたプロジェクトを簡単に作成できます。\n\n```bash\nnpx create-react-app my-ts-react --template typescript\n```\n\nこのコマンドを実行すると、必要な依存関係と `tsconfig.json` が自動的に生成されます。プロジェクトをそのまま開始できます。\n\n### b. Vue.js + TypeScript\n\nVue CLIを使って、TypeScriptをサポートするプロジェクトを作成できます。\n\n```bash\nvue create my-ts-vue\n```\n\nコマンド実行後、プロンプトが表示されるので、「Manually select features」を選択し、TypeScriptを有効にしてください。\n\n## 4. まとめ\n\nバックエンドのTypeScript環境は、コンパイル設定と開発用スクリプトの追加が中心となります。一方、フロントエンドの主要なフレームワークでは、CLIツールがほとんどのセットアップを自動的に行ってくれるため、より簡単に開発を開始できます。\n\n提示されたTypeScriptのセットアップ手順は非常に詳細で適切です。バックエンドとフロントエンドの両方を網羅しており、特に`tsconfig.json`の設定や開発用スクリプトの追加まで言及している点が優れています。\n\nこのドキュメントをさらに改善するため、以下の2つの点を追加することを提案します。\n\n## 5. VS Codeのセットアップ 💻\n\n多くの開発者がVS Codeを使用しているため、TypeScript開発をより効率的に進めるための設定を追加します。\n\n### a. 必要な拡張機能のインストール\n\n- `TSLint` または `ESLint`: コーディングスタイルを統一し、潜在的なエラーを早期に発見します。\n- `Prettier`: コードフォーマッターとして、ファイルを保存するたびに自動でコードを整形します。\n\n### b. VS Codeの設定 (`settings.json`)\n\nプロジェクトルートの`.vscode/settings.json`ファイルに以下の設定を追加することで、`TSLint`や`Prettier`を自動で適用できます。\n\n```json\n{\n  \"editor.formatOnSave\": true,\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": \"explicit\"\n  }\n}\n```\n\n## 6. その他のフレームワークとツール 🌐\n\nReactとVue.js以外の人気のあるフレームワークやツールにおけるTypeScriptのセットアップ方法を追加します。\n\n### a. Next.js\n\nNext.jsは、公式にTypeScriptをサポートしており、セットアップは非常に簡単です。\n\n```bash\nnpx create-next-app@latest --typescript\n```\n\nこのコマンドを実行するだけで、TypeScript環境が完全に構成されたNext.jsプロジェクトが生成されます。\n\n### b. Vite\n\nViteは、高速な開発サーバーとバンドルツールで、TypeScriptのサポートも組み込まれています。\n\n```bash\nnpm create vite@latest my-ts-app -- --template react-ts\n# または vue-ts\n```\n\nこのコマンドで、ReactやVue.jsなど様々なフレームワークのテンプレートを、TypeScriptでセットアップできます。\n\nこれらの追加情報を盛り込むことで、ドキュメントはより包括的になり、多様な開発環境に対応できるようになります。\n\nこの包括的なドキュメントに加えて、以下のような点を追加するとさらに役立ちます。\n\n## 7. 型定義ファイル (Type Definitions) の管理 📦\n\nTypeScriptはJavaScriptライブラリの型情報を利用して型安全性を確保します。`@types`というスコープで管理されている型定義ファイルについて説明すると、ユーザーが既存のライブラリとTypeScriptを組み合わせる際に役立ちます。\n\n### 型定義ファイルのインストール:\n\n`lodash`や`axios`といったライブラリには、通常、対応する型定義ファイルが`@types/`として提供されています。これを`--save-dev`でインストールします。\n\n```bash\nnpm install axios\nnpm install --save-dev @types/axios\n```\n\n### 型定義ファイルがない場合:\n\nもし`@types`に型定義ファイルが存在しない場合は、`d.ts`（Declaration File）を自分で作成する必要があります。これにより、TypeScriptコンパイラにそのライブラリの型情報を伝えることができます。\n\n```typescript\n// types/my-library/index.d.ts\ndeclare module 'my-library' {\n  export function myfunction(): string;\n}\n```\n\n## 8. tsconfig.jsonの高度な設定 🔧\n\n`tsconfig.json`のより詳細なオプションを解説することで、ユーザーはプロジェクトの要件に合わせて設定を最適化できます。\n\n### pathsとエイリアス:\n\n長い相対パス（例: `../../components/Button`）をエイリアス（例: `@components/Button`）に置き換える設定です。これにより、コードの可読性が向上します。\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@components/*\": [\"src/components/*\"]\n    }\n  }\n}\n```\n\n### strictモード:\n\n`tsconfig.json`の`\"strict\": true`は、より厳格な型チェックを有効にします。これには`noImplicitAny`や`strictNullChecks`などが含まれます。`strict`モードを有効にすることで、多くの潜在的なバグを防ぐことができます。\n\n### jsxオプション:\n\nReactやPreactなどのJSXを使用するフレームワークでのコンパイル方法を設定します。\n\n```json\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react\"\n  }\n}\n```\n\nこれらのセクションを追加することで、ドキュメントは単なるセットアップ手順を超え、実践的な開発で直面するであろう課題への解決策を提供する、より価値のあるリソースになります。","src/content/docs/TypeScriptガイド/00_setup.mdx","f886a47741b6ce23","typescriptガイド/01_環境構築とビルドツール",{"id":95,"data":97,"body":102,"filePath":103,"digest":104,"deferredRender":16},{"title":98,"editUrl":16,"head":99,"template":18,"sidebar":100,"pagefind":16,"draft":20},"ビルドツール",[],{"hidden":20,"attrs":101},{},"## 2. ビルドツールの選定と連携\n\n本番環境にデプロイする際には、TypeScriptコードをJavaScriptにコンパイルし、最適化する必要があります。\n\n### TypeScriptのコンパイラ (`tsc`)\n\nTypeScriptに標準で付属するコンパイラです。ビルドの基本となります。\n\n#### `package.json` の設定:\n\n```json\n\"scripts\": {\n  \"build\": \"tsc\"\n}\n```\n\nこのコマンドは、`tsconfig.json`の設定に従って、TypeScriptファイルをJavaScriptにコンパイルし、`outDir`で指定されたディレクトリに出力します。\n\n### 高速バンドラー (Vite / esbuild)\n\n大規模なアプリケーションでは、`tsc`のコンパイル速度が開発のボトルネックになることがあります。Viteやesbuildは、圧倒的な速度でビルドを行う次世代のツールです。\n\n- **Vite**: 開発時にESモジュールをネイティブに利用し、超高速な開発体験を提供します。\n- **esbuild**: Go言語で書かれており、非常に高速なバンドルとトランスパイルが可能です。\n\n#### Viteでのプロジェクト構築例:\n\n```bash\nnpm create vite@latest my-ts-app -- --template react-ts\n# または vue-ts\n```\n\nこのコマンドは、TypeScriptとReact（またはVue）の環境をViteを使って瞬時にセットアップします。\n\n## 3. リンターとフォーマッターの統合\n\nコードの品質と一貫性を保つために、リンターとフォーマッターは不可欠です。\n\n### ESLint と Prettier\n\n- **ESLint**: コード内の問題（構文エラーやスタイル違反）を静的に解析します。\n- **Prettier**: 決められたルールに従ってコードを自動で整形します。\n\n#### インストール:\n\n```bash\nnpm install --save-dev eslint prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-config-prettier\n```\n\n#### 設定:\n\n`eslint.json`と`.prettierrc`ファイルでルールを定義します。そして、`package.json`に以下のスクリプトを追加します。\n\n```json\n\"scripts\": {\n  \"lint\": \"eslint 'src/**/*.ts'\",\n  \"format\": \"prettier --write 'src/**/*.ts'\"\n}\n```\n\nVS Codeなどのエディタで、ファイルを保存するたびに自動で整形・修正されるように設定することで、手動での作業をなくし、開発効率を最大化できます。","src/content/docs/TypeScriptガイド/01_環境構築とビルドツール.mdx","1954d43e28a3e1ce","typescriptガイド/02_tsconfigjsonの詳細設定",{"id":105,"data":107,"body":112,"filePath":113,"digest":114,"deferredRender":16},{"title":108,"editUrl":16,"head":109,"template":18,"sidebar":110,"pagefind":16,"draft":20},"tsconfig.json の詳細な設定",[],{"hidden":20,"attrs":111},{},"## tsconfig.json の主要な設定項目 ⚙️\n\n`tsconfig.json`ファイルは、TypeScriptコンパイラにどのようなファイルをコンパイルするか、そしてどのようにコンパイルするかを指示するものです。プロジェクトのルートディレクトリに配置することで、`tsc`コマンドやエディタが自動で設定を読み込みます。\n\n### 1. コンパイラオプション (`compilerOptions`)\n\nこのセクションは、コンパイルの振る舞いを制御する最も重要な部分です。\n\n- `target`: 出力されるJavaScriptのECMAScriptバージョンを指定します。新しい言語機能（例：`async/await`）は、指定されたターゲットに合わせてトランスパイルされます。\n  - `\"es5\"`: 広くサポートされているバージョン。古いブラウザや環境向け。\n  - `\"es2020\"`: 最新の機能を含むモダンな環境向け。\n\n- `module`: 出力されるJavaScriptコードで使用するモジュールシステムを指定します。\n  - `\"commonjs\"`: Node.js環境で一般的に使用されます。\n  - `\"esnext\"`: ブラウザや最新のNode.js環境で使われるESモジュール。\n\n- `outDir`: コンパイルされたJavaScriptファイルが出力されるディレクトリです。通常は、`dist`や`build`などの名前が使われます。\n\n- `rootDir`: ソースコードのルートディレクトリを指定します。`outDir`と組み合わせて使うことで、元のディレクトリ構造を保ったまま出力できます。\n\n- `esModuleInterop`: ESモジュールとCommonJSモジュールの間で相互運用性を確保するための設定です。これを`true`にすることで、`import * as React from 'react'`のような記述が`import React from 'react'`のようにシンプルになります。\n\n### 2. 厳格性 (Strictness) 🛡️\n\n`strict`モードは、潜在的なバグを早期に発見するために、TypeScriptが提供する最も強力な機能の一つです。\n\n- `\"strict\": true`: この一つを設定するだけで、以下のすべての厳格なオプションが有効になります。\n  - `\"noImplicitAny\"`: 型注釈がないまま、コンパイラが`any`型と推論するのを禁止します。\n  - `\"strictNullChecks\"`: `null`や`undefined`を厳密にチェックします。これにより、予期せぬ実行時エラーを防ぐことができます。\n  - `\"strictFunctionTypes\"`: 関数の引数の型チェックをより厳密にします。\n  - `\"strictPropertyInitialization\"`: クラスのプロパティがコンストラクタで初期化されているかをチェックします。\n\n### 3. パス解決とエイリアス (paths) 🗺️\n\n大規模なプロジェクトでは、深いディレクトリ階層を持つことがあります。`paths`オプションを使用することで、長い相対パスを短く、分かりやすいエイリアスに変換できます。\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // baseUrl は paths オプションを使用するために必須\n    \"baseUrl\": \".\",\n    \"paths\": {\n      // @/components を src/components にマッピング\n      \"@/components/*\": [\"src/components/*\"],\n      // @/utils を src/utils/index.ts にマッピング\n      \"@/utils\": [\"src/utils/index.ts\"]\n    }\n  }\n}\n```\n\n利用例:\n../../../../components/Buttonという記述を、**@/components/Button**という簡潔な記述に置き換えることができます。これにより、コードの可読性が大幅に向上し、リファクタリングも容易になります。\n\n注意: この設定を有効にするには、Node.jsのモジュール解決ツール（例：Webpack, Jest）にも同様の設定が必要です。","src/content/docs/TypeScriptガイド/02_tsconfig.jsonの詳細設定.mdx","d3c3acfb110333e9","typescriptガイド/03_型定義",{"id":115,"data":117,"body":122,"filePath":123,"digest":124,"deferredRender":16},{"title":118,"editUrl":16,"head":119,"template":18,"sidebar":120,"pagefind":16,"draft":20},"型定義",[],{"label":118,"hidden":20,"attrs":121},{},"## 1. プリミティブ型と基本型 🧱\n\nTypeScriptの型定義の基本となるものです。\n\n- `string`: 文字列型です。\"hello\"や\"world\"などのテキストデータに使用します。\n- `number`: 数値型です。100や3.14などの整数、浮動小数点数に使用します。\n- `boolean`: 真偽値型です。`true`または`false`のどちらかです。\n- `null` と `undefined`: それぞれ、`null`と`undefined`を表します。\n- `any`: どのような型でも受け入れます。型チェックを無効にするため、できるだけ使用を避けるべきです。\n- `void`: 関数の戻り値がないことを示します。\n\n## 2. 配列とオブジェクト 📦\n\n複数の値を扱うための型定義です。\n\n### 配列\n\n要素の型を角括弧 `[]` で指定します。\n\n- `string[]`: 文字列の配列。例: `['a', 'b', 'c']`\n- `number[]`: 数値の配列。例: `[1, 2, 3]`\n\n### オブジェクト\n\nオブジェクトの各プロパティに型を定義します。\n\n```typescript\ntype User = {\n  id: number;\n  name: string;\n  isLogin: boolean;\n};\n\nconst user: User = {\n  id: 1,\n  name: 'Alice',\n  isLogin: true,\n};\n```\n\n- `?` (オプショナルプロパティ): プロパティ名の後ろに`?`を付けると、そのプロパティはあってもなくてもよくなります。\n\n```typescript\ntype OptionalUser = {\n  id: number;\n  name?: string; // 名前は任意\n};\n```\n\n## 3. 関数 🤖\n\n関数の引数と戻り値に型を定義します。\n\n- **引数**: 引数名の後に `: 型` を指定します。\n- **戻り値**: 引数リストの後に `: 型` を指定します。\n\n```typescript\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n\nconst result = add(1, 2); // result は number 型\n```\n\n## 4. 複合型と高度な型 🧠\n\n複数の型を組み合わせたり、より柔軟な型を定義したりする方法です。\n\n### ユニオン型 (`|`)\n\n複数の型のいずれかであることを示します。\n\n```typescript\nlet value: string | number;\nvalue = 'hello'; // OK\nvalue = 123;     // OK\n```\n\n### インターセクション型 (`&`)\n\n複数の型のすべてのプロパティを結合します。\n\n```typescript\ntype Admin = { role: string };\ntype Employee = { id: number };\n\ntype AdminEmployee = Admin & Employee;\n\nconst admin: AdminEmployee = {\n  role: 'admin',\n  id: 1,\n};\n```\n\n### 型エイリアス (`type`)\n\n既存の型に新しい名前を付けます。繰り返し使う複雑な型を簡潔に記述できます。\n\n### インターフェース (`interface`)\n\n主にオブジェクトの構造を定義するために使用します。型エイリアスと似ていますが、拡張（`extends`）や実装（`implements`）など、オブジェクト指向的な使い方ができます。\n\n```typescript\n// 型エイリアス\ntype Point = { x: number; y: number };\n\n// インターフェース\ninterface Shape {\n  width: number;\n  height: number;\n}\n```\n\n## 5. ジェネリクス (Generics) 🤖\n\nジェネリクスは、再利用可能なコンポーネントを作成するための強力なツールです。特定の型に縛られることなく、複数の型に対応できる関数やクラスを定義できます。これにより、コードの柔軟性と型安全性の両方を高めることができます。\n\nジェネリクスは、通常、山括弧 `\u003C >` を使って定義し、型を表すために大文字のアルファベット（例：`T`）を使用します。\n\n### 例：ジェネリクス関数\n\n以下の関数は、引数として受け取った値をそのまま返す関数ですが、ジェネリクスを使うことで、入力と出力の型を動的に設定できます。\n\n```typescript\nfunction identity\u003CT>(arg: T): T {\n  return arg;\n}\n\n// string 型として推論される\nlet output1 = identity\u003Cstring>(\"myString\");\n\n// number 型として推論される\nlet output2 = identity\u003Cnumber>(100);\n```\n\n## 6. ユーティリティ型 (Utility Types) 🛠️\n\nTypeScriptが標準で提供するユーティリティ型は、既存の型を変換して新しい型を生成するのに役立ちます。\n\n- `Partial\u003CT>`: `T`のすべてのプロパティをオプショナル（任意）にします。\n- `Required\u003CT>`: `T`のすべてのプロパティを必須にします。\n- `Readonly\u003CT>`: `T`のすべてのプロパティを読み取り専用にします。\n- `Pick\u003CT, K>`: `T`のプロパティから、指定した`K`のプロパティだけを抜き取って新しい型を作成します。\n\n### 例：Pickの使用\n\n`User`型から`id`と`name`だけを抜き取って`UserInfo`型を定義します。\n\n```typescript\ntype User = {\n  id: number;\n  name: string;\n  age: number;\n};\n\n// User型からidとnameプロパティを抜き取る\ntype UserInfo = Pick\u003CUser, 'id' | 'name'>;\n\nconst userInfo: UserInfo = {\n  id: 1,\n  name: 'Alice',\n};\n```\n\n## 7. 型推論 (Type Inference) と型アサーション (Type Assertion) 🧠\n\n### 型推論\n\nTypeScriptは、変数の初期値から自動的に型を推論します。\n\n```typescript\nlet message = \"Hello\"; // string 型と推論される\nlet count = 100;      // number 型と推論される\n```\n\n明示的な型定義をしなくても、型安全性が保たれるため、コーディングの効率が向上します。\n\n### 型アサーション\n\n開発者がコンパイラよりも型の情報を持っている場合に、`as`キーワードを使って型を上書きします。ただし、型安全性を損なう可能性があるため、慎重に使用すべきです。\n\n```typescript\nconst element = document.getElementById('my-element') as HTMLInputElement;\n// この時点でelementはHTMLInputElement型として扱われる\nelement.value = \"newValue\";\n```\n\n## 8. enumとリテラル型 🔖\n\nこれらの型は、特定の値を厳密に制限したい場合に役立ちます。\n\n### enum (列挙型)\n\n関連する定数をまとめて定義します。`enum`を使用すると、マジックナンバーや文字列リテラルを避けることができ、コードの可読性を向上させます。\n\n```typescript\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nconst direction = Direction.Up; // directionは `0` になる\n```\n\n`enum`のメンバーには、デフォルトで数値が割り当てられますが、文字列を割り当てることもできます。\n\n### リテラル型\n\n厳密に特定の文字列、数値、または真偽値のみを受け入れるようにします。\n\n```typescript\ntype Status = \"pending\" | \"success\" | \"error\";\n\nlet currentStatus: Status = \"pending\";\ncurrentStatus = \"success\"; // OK\ncurrentStatus = \"failure\"; // エラー: '\"failure\"' 型は 'Status' 型に割り当てられません。\n```\n\nこれは、ユニオン型の一種で、特定の文字列の集合だけを許可したい場合に非常に便利です。\n\n## 9. 構造的部分型 (Structural Subtyping) 🦢\n\nTypeScriptの型システムは、構造的部分型に基づいています。これは、オブジェクトが特定の型として認識されるために、その構造が一致していればよいという概念です。\n\n例えば、`Point`というインターフェースがあるとします。\n\n```typescript\ninterface Point {\n  x: number;\n  y: number;\n}\n```\n\nそして、`Vector`というオブジェクトがあります。\n\n```typescript\nconst vector = { x: 10, y: 20, z: 30 };\n```\n\n`Vector`には`z`プロパティがありますが、`Point`インターフェースが持つ`x`と`y`のプロパティも持っているため、`Vector`は**`Point`型として扱えます**。\n\n```typescript\nfunction printPoint(p: Point) {\n  console.log(p.x, p.y);\n}\n\nprintPoint(vector); // エラーにならない\n```\n\nこの柔軟な型チェックは、TypeScriptの大きな特徴であり、JavaScriptとの互換性を保つ上で重要な役割を果たします。\n\n## 10. unknownと型ガード 🛡️\n\n`any`型は型チェックを完全に無効にしますが、`unknown`型はより安全な代替手段を提供します。\n\n### unknown\n\n`unknown`型の変数は、型を特定しない限り、プロパティへのアクセスや操作ができません。これにより、型安全性を強制します。\n\n```typescript\nlet value: unknown;\nvalue = 'hello';\n\n// エラー: 'value' は unknown です。\n// value.toUpperCase(); \n\nif (typeof value === 'string') {\n  // ここでは value は string 型として認識される\n  console.log(value.toUpperCase()); // OK\n}\n```\n\n### 型ガード\n\n`typeof`や`instanceof`といった条件文を使って、実行時に変数の型を絞り込むことを「型ガード」と呼びます。これは、`unknown`型を安全に扱うために不可欠です。\n\n## 11. 条件型 (Conditional Types) 🤔\n\n条件型は、ある型が別の型に割り当て可能であるかどうかに基づいて、異なる型を返すことができる高度な機能です。三項演算子に似た構文を使用します。これは、特にジェネリクスと組み合わせて使用され、非常に柔軟な型を定義する際に役立ちます。\n\n```typescript\ntype IsString\u003CT> = T extends string ? 'yes' : 'no';\n\ntype Result1 = IsString\u003Cstring>; // Result1 は 'yes' になる\ntype Result2 = IsString\u003Cnumber>; // Result2 は 'no' になる\n```\n\nこの機能は、複雑なライブラリやフレームワークの型定義でよく見られます。\n\n## 12. マッピング型 (Mapped Types) 🗺️\n\nマッピング型は、既存の型に基づいて新しい型を作成する際に使用されます。オブジェクトの各プロパティをループ処理し、新しい型に変換することができます。\n\n```typescript\ntype User = {\n  name: string;\n  age: number;\n};\n\n// Userのすべてのプロパティを読み取り専用にする\ntype ReadonlyUser = {\n  readonly [P in keyof User]: User[P];\n};\n\nconst user: ReadonlyUser = {\n  name: 'Alice',\n  age: 30,\n};\n\n// エラー: 'name' は読み取り専用プロパティであるため、割り当てできません。\n// user.name = 'Bob'; \n```\n\nこの例では、`Readonly\u003CT>`ユーティリティ型を自作していますが、このように既存の型を変換する処理を一般化することができます。\n\n## 13. デコレーター (Decorators) 🎨\n\nデコレーターは、クラスやプロパティ、メソッドなどに特別な動作をアタッチする機能です。実験的な機能ですが、AngularやNestJSといったフレームワークで広く使われています。\n\nデコレーターは`@`シンボルを使って適用されます。\n\n```typescript\nfunction log(target, key, descriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function(...args: any[]) {\n    console.log(`Calling ${key} with`, args);\n    return originalMethod.apply(this, args);\n  };\n  return descriptor;\n}\n\nclass Calculator {\n  @log\n  add(x: number, y: number) {\n    return x + y;\n  }\n}\n```\n\nこのコードでは、`add`メソッドが呼び出されるたびに、自動的に引数がログ出力されます。デコレーターは、ロギング、認証、トランザクション管理といった横断的な関心を、コードを汚すことなく実装するのに役立ちます。\n\nこれらのトピックを追加することで、ドキュメントはTypeScriptの型システムに関する非常に高度で包括的なリソースになります。","src/content/docs/TypeScriptガイド/03_型定義.mdx","a57a53303f16ee2c","typescriptガイド/04_open-api仕様書からの転用",{"id":125,"data":127,"body":132,"filePath":133,"digest":134,"deferredRender":16},{"title":128,"editUrl":16,"head":129,"template":18,"sidebar":130,"pagefind":16,"draft":20},"openapi-ts定義",[],{"label":128,"hidden":20,"attrs":131},{},"## OpenAPI仕様書からTypeScriptの型を自動生成 🤖\n\nOpenAPIは、REST APIの設計を記述するための標準的な仕様です。この仕様書には、エンドポイント、リクエスト/レスポンスのスキーマ、認証方法などが定義されています。このスキーマ情報を活用することで、APIのクライアントコード（リクエスト関数や型定義）を自動生成できます。\n\n### ツール: openapi-typescript-codegen\n\n`openapi-typescript-codegen` は、OpenAPI仕様書からTypeScriptクライアントを自動生成するための人気の高いツールです。このツールは、型定義だけでなく、APIを呼び出すためのクライアントコード（`fetch`など）も生成してくれます。\n\n#### インストール:\n\nプロジェクトにツールをインストールします。\n\n```bash\nnpm install --save-dev openapi-typescript-codegen\n```\n\n#### `package.json` にスクリプトを追加:\n\n`package.json`の`scripts`に生成コマンドを追加します。\n\n```json\n\"scripts\": {\n  \"generate:api\": \"openapi --input ./api-spec.json --output ./src/api --client fetch\"\n}\n```\n\n- `--input`: OpenAPI仕様書ファイルへのパスを指定します。\n- `--output`: 生成されたコードを出力するディレクトリを指定します。\n- `--client`: 使用するHTTPクライアント（`fetch`、`axios`など）を指定します。\n\n#### 実行:\n\nコマンドを実行すると、指定したディレクトリにAPIクライアントと型定義ファイルが自動で生成されます。\n\n```bash\nnpm run generate:api\n```\n\n### 自動生成されたコードの利用例\n\n生成されたクライアントは、以下のようにTypeScriptコード内で直接利用できます。APIの変更を反映させるには、仕様書を更新して再度コマンドを実行するだけでよいため、手作業によるミスがなくなります。\n\n```typescript\n// src/components/UserList.ts\nimport { UsersService, User } from '../api';\n\nasync function fetchUsers() {\n  try {\n    // APIクライアントの型が保証されている\n    const users: User[] = await UsersService.getUsers();\n    console.log(users);\n  } catch (error) {\n    console.error('Failed to fetch users:', error);\n  }\n}\n\nfetchUsers();\n```","src/content/docs/TypeScriptガイド/04_open-api仕様書からの転用.mdx","42043daace2f94b2","typescriptガイド/05_モノレポとマルチパッケージ管理",{"id":135,"data":137,"body":142,"filePath":143,"digest":144,"deferredRender":16},{"title":138,"editUrl":16,"head":139,"template":18,"sidebar":140,"pagefind":16,"draft":20},"モノレポとマルチパッケージ管理",[],{"hidden":20,"attrs":141},{},"## モノレポとマルチパッケージ管理 🌳\n\nモノレポ（Monorepo）とマルチパッケージ管理は、複数の関連するプロジェクトを一つのGitリポジトリで管理する開発手法です。これにより、コードの共有、依存関係の管理、そしてビルドプロセスを効率化できます。\n\n### 1. モノレポのメリットとデメリット\n\n#### メリット ✅\n\n- **コードの共有**: 共通のUIコンポーネントやユーティリティ関数を一つのパッケージにまとめ、複数のプロジェクトで簡単に再利用できます。これにより、重複コードを削減し、一貫性を保てます。\n- **依存関係の管理**: すべてのプロジェクトの依存関係を一つの場所で管理できるため、依存関係のバージョン衝突を防ぎ、更新を容易にします。\n- **アトミックな変更**: フロントエンドとバックエンドの変更を同時に一つのコミットで行えるため、整合性が保たれます。\n- **ビルドの最適化**: どのプロジェクトが変更されたかをツールが判断し、変更があった部分だけを再ビルドすることで、ビルド時間を大幅に短縮できます。\n\n#### デメリット ❌\n\n- **学習コスト**: モノレポ専用のツールやワークフローを学ぶ必要があります。\n- **初期設定の複雑さ**: プロジェクトのセットアップが複雑になることがあります。\n- **リポジトリのサイズ**: 時間とともにリポジトリが巨大化する可能性があります。\n\n### 2. TypeScriptとモノレポの連携\n\nTypeScriptは、モノレポでの開発と非常に相性が良いです。特に、共通の型定義を一つのパッケージにまとめ、それを複数のアプリケーションで共有するユースケースで真価を発揮します。\n\n**例:**\n\n- `packages/common-types`: 共通のAPIレスポンス型やモデルを定義。\n- `packages/frontend`: `common-types`に依存するReactアプリケーション。\n- `packages/backend`: `common-types`に依存するNode.jsサーバー。\n\nこれにより、フロントエンドとバックエンド間でデータのやり取りをする際に、常に同じ型定義を参照できるため、型エラーをコンパイル時に検出できます。\n\n### 3. 主要なツール\n\nモノレポを効率的に管理するためには、専用のツールが不可欠です。\n\n#### npm/Yarn のワークスペース機能\n\nnpmとYarnには、モノレポを管理するためのワークスペース機能が標準で備わっています。\n\n**`package.json` の設定:**\n\n```json\n{\n  \"name\": \"my-monorepo\",\n  \"version\": \"1.0.0\",\n  \"workspaces\": [\n    \"packages/*\"\n  ]\n}\n```\n\n**依存関係のインストール:**\n\nルートディレクトリで`npm install`を実行すると、すべてのパッケージの依存関係がまとめてインストールされます。\n\n#### 専用のビルドツール\n\n大規模なモノレポでは、ビルドの効率化が重要になります。\n\n- **Turborepo**: 超高速なビルドシステムで、タスクの実行とキャッシュに特化しています。変更のないパッケージは再ビルドせず、キャッシュから結果を再利用することで、ビルド時間を劇的に短縮します。\n- **Nx**: モノレポ管理のための包括的なツールです。ビルド、テスト、リンティングなどのタスクを最適化する機能に加え、プロジェクトの依存関係を視覚化する機能も提供します。\n- **Lerna**: npm/Yarnのワークスペース機能と組み合わせて使用され、複数のパッケージを管理し、公開するプロセスを効率化します。\n\nこれらのツールを導入することで、モノレポのメリットを最大限に引き出し、大規模なTypeScriptプロジェクトを効率的に管理できます。","src/content/docs/TypeScriptガイド/05_モノレポとマルチパッケージ管理.mdx","418255245a23e4ff","typescriptガイド/06_開発ワークフローとcicd-",{"id":145,"data":147,"body":152,"filePath":153,"digest":154,"deferredRender":16},{"title":148,"editUrl":16,"head":149,"template":18,"sidebar":150,"pagefind":16,"draft":20},"開発ワークフローとCI/CD",[],{"hidden":20,"attrs":151},{},"## 開発ワークフローとCI/CD 🚀\n\nTypeScriptプロジェクトをチームで効率的に開発し、本番環境に安全にデプロイするためには、**継続的インテグレーション（CI）と継続的デプロイメント（CD）**のワークフローを構築することが重要です。これにより、コードの品質を維持し、リリースプロセスを自動化できます。\n\n### 1. 継続的インテグレーション（CI）\n\nCIは、開発者が書いたコードを共有リポジトリにマージするたびに、自動的にビルドやテストを実行するプロセスです。これにより、バグや統合の問題を早期に発見できます。\n\n#### CIサービスの利用\n\nGitHub Actions、CircleCI、GitLab CI/CDなどのCIサービスは、プロジェクトのリポジトリに設定ファイルを追加するだけで簡単に導入できます。\n\n#### GitHub Actions の例 (`.github/workflows/ci.yml`):\n\n```yaml\nname: CI on Push\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  build_and_test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Use Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '18'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run TypeScript checks\n        run: npm run type-check\n      - name: Run tests\n        run: npm run test\n```\n\nこのワークフローでは、`main`ブランチにコードがプッシュされるたびに、以下のステップが自動的に実行されます。\n\n- **依存関係のインストール**: `npm ci`で依存関係をインストールします。\n- **型チェック**: `npm run type-check`（通常は`tsc --noEmit`）で型エラーがないかチェックします。\n- **テスト実行**: `npm run test`でテストコードを実行します。\n\nすべてのステップが成功した場合のみ、その変更は安全と見なされ、次のステージに進めます。\n\n### 2. 継続的デプロイメント（CD）\n\nCDは、CIが成功したビルド成果物を、自動的にステージングや本番環境にデプロイするプロセスです。これにより、手動でのデプロイミスをなくし、リリースを迅速に行えます。\n\n#### デプロイの自動化\n\nCIとCDを組み合わせることで、**「コードをプッシュするだけで、本番環境に自動で反映される」**という理想的なワークフローが実現します。\n\n#### 例（GitHub ActionsによるAWS S3へのデプロイ）:\n\n```yaml\nname: CD on successful CI\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy_to_s3:\n    needs: build_and_test # CIジョブが成功した場合のみ実行\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Deploy to S3\n        run: |\n          aws s3 sync ./dist s3://your-s3-bucket-name --delete\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n```\n\nこの例では、CIで設定した`build_and_test`ジョブが成功した場合にのみ、`deploy_to_s3`ジョブが実行されます。`aws s3 sync`コマンドを使用して、ビルド成果物（`dist`ディレクトリ）をAmazon S3バケットに同期します。\n\n## まとめ\n\n開発ワークフローにCI/CDを導入することで、開発者はローカル環境での作業に集中でき、バグの早期発見、コード品質の維持、そして迅速かつ安全なデプロイを実現できます。これは、現代のソフトウェア開発において不可欠なプラクティスです。","src/content/docs/TypeScriptガイド/06_開発ワークフローとCICD .mdx","da99c4d67733eea9","typescriptガイド/07_コード分割とパフォーマンス最適化",{"id":155,"data":157,"body":162,"filePath":163,"digest":164,"deferredRender":16},{"title":158,"editUrl":16,"head":159,"template":18,"sidebar":160,"pagefind":16,"draft":20},"コード分割とパフォーマンス最適化",[],{"hidden":20,"attrs":161},{},"## コード分割とパフォーマンス最適化 ⚡️\n\nTypeScriptを使用する大規模なフロントエンドアプリケーションでは、バンドルサイズとパフォーマンスが重要な課題となります。コード分割は、この課題を解決するための主要なテクニックです。\n\n### 1. コード分割の概念\n\nコード分割は、アプリケーションのJavaScriptコードを複数の小さなチャンク（塊）に分割し、ユーザーが必要とするタイミングで動的にロードする手法です。これにより、初回ロード時にダウンロードされるファイルサイズを大幅に削減し、初期表示速度を向上させることができます。\n\n分割されたコードは、以下の状況でロードされます。\n\n- **ページの遷移時**: ユーザーが新しいページに移動したとき。\n- **特定のコンポーネントの表示時**: モーダルウィンドウやドロップダウンメニューが表示されたとき。\n- **ユーザー操作時**: ボタンのクリックなど、特定のイベントが発生したとき。\n\n### 2. 動的インポート（Dynamic Imports）\n\n動的インポートは、コード分割を実装するための最も一般的な方法です。静的な`import`文とは異なり、`import()`関数はモジュールを非同期的にロードし、`Promise`を返します。\n\n#### 構文\n\n```typescript\nconst module = await import('./my-module');\n```\n\n#### 実装例\n\n以下の例では、ユーザーがボタンをクリックしたときにのみ、大きなデータ処理モジュールがロードされます。\n\n```typescript\n// button.ts\nimport { heavyComputation } from './heavy-computation';\n\ndocument.getElementById('my-button').addEventListener('click', async () => {\n  // ボタンがクリックされたときにのみ、このコードが実行される\n  // WebpackやViteなどのバンドラーが、'./heavy-computation'を別チャンクに分割する\n  const { heavyComputation } = await import('./heavy-computation');\n  const result = heavyComputation(1000);\n  console.log(result);\n});\n```\n\nこのアプローチにより、`heavy-computation`モジュールは、アプリケーションの初期ロード時にはダウンロードされません。\n\n### 3. ツリーシェイキング（Tree Shaking）\n\nツリーシェイキングは、アプリケーションの最終的なバンドルから使用されていないコードを削除するプロセスです。これにより、バンドルサイズをさらに最適化できます。\n\n#### 仕組み\n\nツリーシェイキングは、ESモジュールの静的な性質（`import`と`export`）を利用して、どのコードが実際に使用されているかをビルド時に分析します。\n\n#### 例:\n\n```typescript\n// utils.ts\nexport function usedFunction() {\n  console.log('This function is used.');\n}\n\nexport function unusedFunction() {\n  console.log('This function is not used.');\n}\n\n// app.ts\nimport { usedFunction } from './utils';\n\nusedFunction();\n```\n\nこの場合、`unusedFunction`は`app.ts`から呼び出されていないため、ツリーシェイキングによって最終的なバンドルから削除されます。\n\n#### 設定\n\nツリーシェイキングを最大限に活用するためには、`tsconfig.json`の`module`オプションを**`esnext`や`es2020`**などのESモジュールをサポートする値に設定することが重要です。\n\n```json\n{\n  \"compilerOptions\": {\n    \"module\": \"esnext\",\n    \"target\": \"esnext\"\n  }\n}\n```\n\nこれらの最適化テクニックは、特に大規模なTypeScriptアプリケーションにおいて、ユーザーエクスペリエンスを向上させるために不可欠です。","src/content/docs/TypeScriptガイド/07_コード分割とパフォーマンス最適化.mdx","a7a54c1e6a81df1b","typescriptガイド/08_テストとデバック",{"id":165,"data":167,"body":172,"filePath":173,"digest":174,"deferredRender":16},{"title":168,"editUrl":16,"head":169,"template":18,"sidebar":170,"pagefind":16,"draft":20},"テストとデバック",[],{"hidden":20,"attrs":171},{},"## 1. テスティングフレームワークのセットアップ 🧪\n\nTypeScriptでテストを書く場合、型安全性を活かすために、TypeScriptをネイティブでサポートしているテスティングフレームワークを選択するのが一般的です。\n\n### Jest\n\nJestは、Facebookが開発した広く使われているテスティングフレームワークです。設定が簡単で、モック、スパイ、カバレッジレポートなどの機能が組み込まれています。\n\n#### インストール:\n\nプロジェクトにJestとTypeScriptの型定義ファイルをインストールします。\n\n```bash\nnpm install --save-dev jest @types/jest ts-jest\n```\n\n`ts-jest`は、TypeScriptファイルをJestが理解できるJavaScriptに変換するために必要です。\n\n#### 設定:\n\n`jest.config.js`ファイルを作成し、`ts-jest`をトランスフォーマーとして設定します。\n\n```javascript\n// jest.config.js\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n};\n```\n\n#### テストコードの作成:\n\n`.test.ts`または`.spec.ts`という拡張子のファイルを作成し、テストを記述します。\n\n```typescript\n// math.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\n// math.test.ts\nimport { add } from './math';\n\ntest('add function should return the sum of two numbers', () => {\n  expect(add(1, 2)).toBe(3);\n});\n```\n\n型チェックが行われるため、例えば`add('1', 2)`のような間違いはコンパイル時に検出されます。\n\n## 2. E2Eテストとの連携 🔗\n\nE2Eテストでは、ブラウザ操作の型定義が重要になります。PlaywrightとTypeScriptの組み合わせが、この点で非常に優れています。\n\n### Playwright\n\nPlaywrightは、クロスブラウザのE2Eテストフレームワークで、型安全なAPIを提供しています。\n\n#### インストール:\n\n```bash\nnpm install --save-dev playwright @playwright/test\n```\n\n#### テストコードの作成:\n\nPlaywrightの`test`フィクスチャは、引数として`page`オブジェクトを型付きで提供します。これにより、IDEのオートコンプリートが効き、コードのミスを防げます。\n\n```typescript\nimport { test, expect } from '@playwright/test';\n\ntest('ログインページをテストする', async ({ page }) => {\n  await page.goto('https://example.com/login');\n\n  // 型安全なロケーターの使用\n  const usernameInput = page.getByLabel('Username');\n  const passwordInput = page.getByLabel('Password');\n  const loginButton = page.getByRole('button', { name: 'Log in' });\n\n  // 正しい型を持つpageメソッド\n  await usernameInput.fill('testuser');\n  await passwordInput.fill('password123');\n  await loginButton.click();\n});\n```\n\n## 3. デバッグ 🐞\n\nTypeScriptプロジェクトのデバッグは、VS Codeのような統合開発環境（IDE）を使うことで非常に効率的に行えます。\n\n### VS Codeでのデバッグ設定\n\n`launch.json`ファイルを設定することで、VS CodeのデバッガをTypeScriptコードに直接アタッチできます。\n\n#### launch.jsonの作成:\n\nVS Codeのサイドバーで「実行とデバッグ」をクリックし、「launch.json ファイルを作成します」を選択します。Node.js環境の場合は「Node.js」を選びます。\n\n#### 設定の調整:\n\n生成された設定ファイルを、TypeScriptプロジェクトに合わせて調整します。\n\n```json\n// .vscode/launch.json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Launch Program\",\n      \"skipFiles\": [\"\u003Cnode_internals>/**\"],\n      \"program\": \"${workspaceFolder}/src/index.ts\",\n      \"preLaunchTask\": \"tsc: build - tsconfig.json\", // コンパイルタスクを実行\n      \"outFiles\": [\"${workspaceFolder}/dist/**/*.js\"] // コンパイルされたJSファイルを指定\n    }\n  ]\n}\n```\n\nこれにより、デバッグ実行前にTypeScriptコードが自動でコンパイルされ、`src/index.ts`に設定したブレークポイントで実行が停止します。\n\n## 4. まとめ\n\nTypeScriptプロジェクトでは、JestやPlaywrightといった型安全なテストフレームワークを導入することで、早期にバグを発見し、コードの品質を高めることができます。また、VS Codeのデバッガを適切に設定することで、開発プロセス全体をスムーズに進められます。これらのツールを使いこなすことで、より堅牢でメンテナンスしやすいアプリケーションを構築できます。","src/content/docs/TypeScriptガイド/08_テストとデバック.mdx","fec45dad5e1fa468","typescriptガイド/09_デザインパターンと実践テクニック",{"id":175,"data":177,"body":182,"filePath":183,"digest":184,"deferredRender":16},{"title":178,"editUrl":16,"head":179,"template":18,"sidebar":180,"pagefind":16,"draft":20},"デザインパターンと実践テクニック",[],{"hidden":20,"attrs":181},{},"## デザインパターンと実践テクニック 💡\n\nTypeScriptは、単なるJavaScriptのスーパーセットではなく、アプリケーションの設計を改善するための多くの機能を提供します。ここでは、TypeScriptを最大限に活用するためのデザインパターンと実践的なテクニックを解説します。\n\n### 1. インターフェースと型エイリアスの使い分け\n\n`interface`と`type`はどちらも型を定義できますが、それぞれの特性を理解して使い分けることが重要です。\n\n- **interface**: オブジェクトの構造や、クラスが実装すべきコントラクトを定義するために使います。\n  - **拡張性**: `extends`キーワードを使って、他のインターフェースを拡張できます。\n  - **宣言のマージ**: 同じ名前のインターフェースを複数宣言すると、それらが自動的にマージされます。これは、ライブラリが既存の型に新しいプロパティを追加したい場合に便利です。\n\n- **type (型エイリアス)**: プリミティブ型、ユニオン型、インターセクション型など、任意の型に別名を付けたい場合に最適です。\n  - **柔軟性**: `interface`ではできない複雑な型（例：ユニオン型）を定義できます。\n\n#### 使い分けのベストプラクティス:\n\nオブジェクトの型を定義する場合、クラスのように振る舞う構造を定義するなら`interface`、単なる型の別名として使うなら`type`を検討します。\n\n一般的には、オブジェクトの型定義には**`interface`を優先し、他の型（ユニオン型など）を組み合わせる必要がある場合に`type`を使用**するのが良いでしょう。\n\n### 2. 関数オーバーロード\n\n関数オーバーロードは、同じ関数名で異なる引数の型や数に対応する機能です。TypeScriptは、呼び出し時の引数に基づいて、どの関数の実装が使用されるかをコンパイル時に判断します。\n\n```typescript\n// オーバーロードシグネチャ\nfunction add(x: string, y: string): string;\nfunction add(x: number, y: number): number;\n\n// 実装シグネチャ（より汎用的な型を使用）\nfunction add(x: any, y: any): any {\n  return x + y;\n}\n\n// 呼び出し例\nconst sum1 = add(\"hello\", \" world\"); // string 型と推論\nconst sum2 = add(1, 2);              // number 型と推論\n```\n\nこのテクニックは、柔軟なAPIを設計する際に役立ちます。\n\n### 3. 型ガード (Type Guards)\n\n型ガードは、特定のスコープ内で変数の型を絞り込むための技術です。これにより、`unknown`やユニオン型を安全に扱えます。\n\n- **`typeof` 型ガード**: プリミティブ型をチェックします。\n- **`instanceof` 型ガード**: クラスのインスタンスかどうかをチェックします。\n- **ユーザー定義型ガード**: 開発者が独自の型チェック関数を定義します。\n\n#### ユーザー定義型ガードの例:\n\n```typescript\ninterface Cat { meow(): void; }\ninterface Dog { bark(): void; }\n\ntype Pet = Cat | Dog;\n\n// ユーザー定義型ガード関数\nfunction isCat(pet: Pet): pet is Cat {\n  return (pet as Cat).meow !== undefined;\n}\n\nfunction speak(pet: Pet) {\n  if (isCat(pet)) {\n    pet.meow(); // ここでは pet は Cat 型として扱われる\n  } else {\n    (pet as Dog).bark(); // もしくは pet.bark();\n  }\n}\n```\n\n`pet is Cat`という構文が、この関数が`true`を返す場合に`pet`が`Cat`型であることを保証します。\n\nこれらの実践的なテクニックを習得することで、TypeScriptの強力な型システムをフル活用し、より堅牢で保守しやすいコードを記述できます。","src/content/docs/TypeScriptガイド/09_デザインパターンと実践テクニック.mdx","8279f818fe0a82c3","djangoガイド/01_はじめに/01_setup",{"id":185,"data":187,"body":192,"filePath":193,"digest":194,"deferredRender":16},{"title":188,"editUrl":16,"head":189,"template":18,"sidebar":190,"pagefind":16,"draft":20},"Djangoの環境構築",[],{"hidden":20,"attrs":191},{},"## Djangoの環境構築と基本的なプロジェクト作成、起動までの手順\n\n### Pythonのインストールとバージョン確認\nDjangoを始めるにはPythonが必要です。まだインストールしていない場合は、公式サイトから最新版をダウンロードし、インストールしてください。インストール後、ターミナルやコマンドプロンプトで以下のコマンドを実行し、Pythonが正しくインストールされているか、またそのバージョンを確認します。\n\n```bash\npython --version\n```\n\nもし`python`コマンドが認識されない場合は、代わりに`python3`を試してください。多くのシステムでは、`python`が古いバージョンを指し、`python3`が最新版を指す場合があります。\n\n```bash\npython3 --version\n```\n\n### 仮想環境の作成と有効化\nDjangoプロジェクトは、仮想環境内で管理することを強く推奨します。これにより、プロジェクトごとに異なるライブラリのバージョンを隔離でき、依存関係の競合を防げます。\n\n#### 仮想環境の作成\nプロジェクトを管理するディレクトリに移動し、以下のコマンドで仮想環境を作成します。ここでは仮想環境名を`venv`としています。\n\n```bash\npython -m venv venv\n```\n\n#### 仮想環境の有効化\n作成した仮想環境を有効化するには、オペレーティングシステムによってコマンドが異なります。\n\n- **macOS / Linux**\n\n  ```bash\n  source venv/bin/activate\n  ```\n\n- **Windows (コマンドプロンプト)**\n\n  ```bash\n  venv\\Scripts\\activate\n  ```\n\n- **Windows (PowerShell)**\n\n  ```bash\n  venv\\Scripts\\Activate.ps1\n  ```\n\nコマンドが成功すると、プロンプトの先頭に`(venv)`のような仮想環境名が表示されます。\n\n### Djangoのインストール\n仮想環境が有効化された状態で、以下のコマンドを実行してDjangoをインストールします。このプロジェクトはこれでしか使えないので、好きな時に`pip`で色々インストールできます。\n\n```bash\npip install django\n```\n\n### Djangoプロジェクトの作成とアプリケーションの作成\nDjangoのインストールが完了したら、プロジェクトを作成します。\n\n#### プロジェクトの作成\n以下のコマンドで新しいDjangoプロジェクトを作成します。ここではプロジェクト名を`myproject`とします。\n\n```bash\ndjango-admin startproject myproject .\n```\n\n`startproject`コマンドの後の`.`（ドット）は、現在のディレクトリにプロジェクトを作成することを意味します。ドットを付けない場合、さらに`myproject`というディレクトリが作成され、その中にファイルが配置されます。\n\n#### アプリケーションの作成\n一つのプロジェクトには複数のアプリケーションを含めることができます。例えば、ブログサイトなら「ブログ機能」「ユーザー管理機能」といったように、機能を分割して管理するのが一般的です。`myproject`ディレクトリに入り、以下のコマンドでアプリケーションを作成します。ここではアプリケーション名を`myapp`とします。\n\n```bash\npython manage.py startapp myapp\n```\n\n### 開発用サーバーの起動\n最後に、作成したプロジェクトが正しく動作するか確認するために、開発用サーバーを起動します。\n\n`myproject`ディレクトリ内で以下のコマンドを実行します。\n\n```bash\npython manage.py runserver\n```\n\nサーバーが起動すると、`http://127.0.0.1:8000/`でDjangoの初期画面が表示されます。これで基本的な環境構築とプロジェクトのセットアップは完了です。","src/content/docs/Djangoガイド/01_はじめに/01_setup.mdx","db2378415683e90a","djangoガイド/01_はじめに/02_project_creation",{"id":195,"data":197,"body":202,"filePath":203,"digest":204,"deferredRender":16},{"title":198,"editUrl":16,"head":199,"template":18,"sidebar":200,"pagefind":16,"draft":20},"新規プロジェクトの作成",[],{"hidden":20,"attrs":201},{},"## Djangoでの新規プロジェクトの作成\nDjangoをインストールしたら、以下のコマンドを使って新しいプロジェクトを作成できます。\n\n```bash\ndjango-admin startproject mysite\n```\n\nこのコマンドを実行すると、現在のディレクトリに`mysite`という新しいディレクトリが作成されます。このディレクトリ内には、Djangoプロジェクトの骨格となる以下のようなファイルとディレクトリが含まれます。\n\n```\nmysite/\n├── manage.py\n└── mysite/\n    ├── __init__.py\n    ├── asgi.py\n    ├── settings.py\n    ├── urls.py\n    └── wsgi.py\n```\n\n- **manage.py**: このファイルは、プロジェクトを管理するためのコマンドラインユーティリティです。開発サーバーの起動や、データベースのマイグレーション、アプリケーションの作成など、あらゆる管理タスクで使います。\n\n- **mysite/ (内部ディレクトリ)**: このディレクトリは、プロジェクトのPythonパッケージです。プロジェクトの構成設定ファイルが含まれています。\n\n- **`__init__.py`**: このファイルは、このディレクトリがPythonパッケージであることを示します。\n\n- **settings.py**: プロジェクトのすべての設定が含まれています。データベースの設定、インストールするアプリケーション、静的ファイルの場所など、プロジェクトの動作をここでカスタマイズします。\n\n- **urls.py**: プロジェクトのURLディスパッチャです。どのURLがどのビュー（処理）に対応するかを定義します。\n\n- **asgi.py**: ASGI（Asynchronous Server Gateway Interface）互換のWebサーバーが、プロジェクトを提供するためのエントリポイントです。非同期処理の際に使われます。\n\n- **wsgi.py**: WSGI（Web Server Gateway Interface）互換のWebサーバーが、プロジェクトを提供するためのエントリポイントです。\n\n### プロジェクト作成時のポイント\n`startproject`コマンドには、プロジェクトのディレクトリ構造を柔軟に制御できるオプションがあります。\n\n- **現在のディレクトリに作成する場合**:\n  ```bash\n  django-admin startproject mysite .\n  ```\n  コマンドの最後に`.`（ドット）を付けると、`mysite`ディレクトリではなく、現在のディレクトリにプロジェクトのファイル（`manage.py`や`mysite`ディレクトリ）が直接作成されます。この方法は、プロジェクトのルートディレクトリをシンプルに保ちたい場合に便利です。\n\n- **特定の場所に作成する場合**:\n  ```bash\n  django-admin startproject mysite /path/to/myproject\n  ```\n  このようにプロジェクト名に続いてパスを指定すると、指定した場所にプロジェクトが作成されます。\n\nプロジェクト作成後、まずは`python manage.py runserver`コマンドで開発サーバーを起動し、初期画面が表示されることを確認しましょう。","src/content/docs/Djangoガイド/01_はじめに/02_project_creation.mdx","b695e1750fbcf458","djangoガイド/01_はじめに/03_server_start",{"id":205,"data":207,"body":212,"filePath":213,"digest":214,"deferredRender":16},{"title":208,"editUrl":16,"head":209,"template":18,"sidebar":210,"pagefind":16,"draft":20},"サーバーの起動",[],{"hidden":20,"attrs":211},{},"## サーバーの起動とアクセス\nDjangoプロジェクトを作成したら、開発中にアプリケーションの動作を確認するために、開発用サーバーを起動します。このサーバーは、`manage.py`というファイルを使って制御します。\n\nまず、作成したプロジェクトのルートディレクトリ（`manage.py`がある場所）に移動します。\n\n```bash\ncd mysite\n```\n\n次に、以下のコマンドを実行します。\n\n```bash\npython manage.py runserver\n```\n\nこのコマンドが正常に実行されると、以下のようなメッセージがターミナルに表示されます。\n\n```plaintext\nWatching for file changes with StatReloader\nPerforming system checks...\n\nSystem check identified no issues (0 silenced).\n\nYou can now view your project at http://127.0.0.1:8000/\n\nJuly 01, 2025 - 12:00:00\nDjango version 5.0, using settings 'mysite.settings'\nStarting development server at http://127.0.0.1:8000/\nQuit the server with CTRL-C.\n```\n\nこのメッセージが表示されたら、ウェブブラウザを開き、表示されているURL（通常は`http://127.0.0.1:8000/`または`http://localhost:8000/`）にアクセスしてください。Djangoの初期ウェルカムページが表示されれば、サーバーは正しく起動しています。\n\n### runserverコマンドの補足\n`runserver`コマンドは、いくつかの便利なオプションを持っています。\n\n- **ポート番号の変更**: デフォルトのポート8000が使用できない場合や、別のポートで起動したい場合は、ポート番号を指定できます。\n\n  ```bash\n  python manage.py runserver 8080\n  ```\n\n- **外部からのアクセスを許可**: デフォルトでは、サーバーはローカルマシンからのみアクセス可能です。他のデバイス（同じネットワーク内のスマートフォンなど）からアクセスしたい場合は、IPアドレスを指定します。\n\n  ```bash\n  python manage.py runserver 0.0.0.0:8000\n  ```\n\n  これにより、ローカルネットワーク内のすべてのデバイスから、あなたのコンピューターのローカルIPアドレス（例: `http://192.168.1.5:8000/`）経由でアクセスできるようになります。\n\n開発用サーバーは、コードの変更を自動で検知し、再読み込みしてくれるため、開発効率が非常に高いです。サーバーを停止したい場合は、ターミナルで**Ctrl + C**を押してください。","src/content/docs/Djangoガイド/01_はじめに/03_server_start.mdx","601757f0159bfa9e","djangoガイド/01_はじめに/08_best_practices",{"id":215,"data":217,"body":222,"filePath":223,"digest":224,"deferredRender":16},{"title":218,"editUrl":16,"head":219,"template":18,"sidebar":220,"pagefind":16,"draft":20},"ベストプラクティス",[],{"hidden":20,"attrs":221},{},"## Django開発のベストプラクティス 🚀\n\nDjangoは、大規模なアプリケーションを効率的に構築するための強力なフレームワークです。これらのベストプラクティスを遵守することで、プロジェクトの管理が容易になり、長期的な成功につながります。\n\n### 1. コードの再利用性と構成管理\n\n#### アプリケーションの分割 🧩\n\nDjangoのプロジェクトを独立したアプリケーションに分割することで、コードの再利用性と管理の容易性が向上します。\n\n**例:**\n\n```bash\n# プロジェクトを作成\ndjango-admin startproject myproject .\n\n# ユーザー管理アプリを作成\npython manage.py startapp users\n\n# ブログ投稿管理アプリを作成\npython manage.py startapp blogs\n```\n\nこの構成では、usersとblogsがそれぞれの機能に専念するため、変更による影響範囲を最小限に抑えられます。\n\n#### 設定の分離：環境ごとの柔軟な管理 ⚙️\n\n本番環境と開発環境で異なる設定を複数のファイルに分けることで、デプロイが安全かつ簡単になります。\n\n**構成例:**\n\n```\nmyproject/\n├── settings/\n│   ├── __init__.py\n│   ├── base.py       # 共通設定\n│   ├── development.py  # 開発用設定\n│   └── production.py   # 本番用設定\n└── manage.py\n```\n\n**コード例:**\n\n`settings/development.py`では、`base.py`の設定をインポートした上で、`DEBUG = True`や開発用データベースの設定を上書きします。`settings/production.py`では、`DEBUG = False`とし、本番用のデータベースや`ALLOWED_HOSTS`を設定します。\n\n### 2. 品質保証とパフォーマンス\n\n#### テストの自動化：継続的な品質保証 ✅\n\nDjangoは、Pythonのunittestをベースにした強力なテストフレームワークを内蔵しています。\n\n**コード例:** `blogs/tests.py`にテストケースを記述し、`python manage.py test`で自動実行します。\n\n```python\nfrom django.test import TestCase\nfrom django.urls import reverse\nfrom blogs.models import Post\n\nclass PostViewTests(TestCase):\n    def test_post_list_view(self):\n        Post.objects.create(title='Test Post', content='Hello, World!')\n        response = self.client.get(reverse('blogs:post_list'))\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, 'Test Post')\n```\n\n#### セキュリティの強化 🔒\n\nDjangoは多くのセキュリティ対策をデフォルトで提供しています。\n\n- **CSRF/XSS**: フォームには`{% csrf_token %}`タグを含め、悪意あるスクリプトを防ぐため、常にHTMLエスケープがされていることを確認しましょう。\n\n- **SQLインジェクション**: DjangoのORMは自動的にクエリをエスケープします。生SQLを使う際は、ユーザー入力を直接クエリに連結せず、プレースホルダーを使いましょう。\n\n- **パスワード**: Userモデルの`set_password()`メソッドを使い、パスワードを安全にハッシュ化して保存します。\n\n#### パフォーマンスの最適化 ⚡\n\nユーザー体験を向上させるために、パフォーマンス最適化は欠かせません。\n\n- **データベースクエリ**:\n  - `select_related()`と`prefetch_related()` を使って、リレーションを持つデータの取得クエリ数を減らしましょう。これはN+1問題を解決するのに特に有効です。\n\n- **キャッシュ**: `django.core.cache`モジュールを利用し、頻繁にアクセスされるデータをキャッシュすることで、データベースへの負荷を軽減します。\n\n- **非同期処理**: Django 3.1以降の非同期ビューは、I/Oバウンドなタスク（外部API呼び出しなど）をブロックせずに並行処理できるため、APIサーバーのパフォーマンス向上に役立ちます。\n\n### 3. 開発プロセスの改善\n\n#### コードスタイルの統一 ✨\n\nチーム開発では、一貫したコードスタイルが重要です。\n\n- **PEP 8の遵守** と **自動フォーマッター (Black, isort)** を導入し、フォーマットの不統一をなくしましょう。\n\n- **リンター (Flake8)** を使って、コードの品質を自動でチェックします。\n\n#### デプロイメントの自動化 🚀\n\nアプリケーションのデプロイプロセスを自動化することで、人的ミスを減らし、安定した運用を実現します。\n\n- **コンテナ化 (Docker)**: 開発・テスト・本番環境の差異をなくし、デプロイを容易にします。\n\n- **CI/CDパイプライン (GitHub Actions, GitLab CI/CD)**: コードコミット時に自動でテストを実行し、品質が保証されたら自動でデプロイします。\n\n- **環境変数**: 機密情報（APIキーなど）をコードに直接書かず、`.env`ファイルや環境変数として管理しましょう。","src/content/docs/Djangoガイド/01_はじめに/08_best_practices.mdx","7e9cc18a41ef7c7f","djangoガイド/02_基本/04_mvc_architecture",{"id":225,"data":227,"body":232,"filePath":233,"digest":234,"deferredRender":16},{"title":228,"editUrl":16,"head":229,"template":18,"sidebar":230,"pagefind":16,"draft":20},"MVCアーキテクチャ",[],{"hidden":20,"attrs":231},{},"## DjangoのMTVアーキテクチャ\nDjangoは、一般的なMVC（Model-View-Controller）アーキテクチャに似たMTV（Model-Template-View）アーキテクチャを採用しています。これは、ウェブアプリケーションのコンポーネントを3つの明確な役割に分離することで、コードの管理や再利用を容易にする設計パターンです。\n\n### Model（モデル）\nモデルは、アプリケーションのデータ構造と、そのデータを操作するビジネスロジックを定義します。Djangoでは、モデルはデータベースのテーブルに対応します。モデルクラスを定義することで、SQLを直接書かずにPythonのオブジェクトとしてデータベースを操作できます。\n\n- **機能**: データの取得、保存、更新、削除（CRUD操作）\n- **例**: ユーザー、ブログ記事、商品などのデータ構造を定義します。\n\n### Template（テンプレート）\nテンプレートは、ユーザーに表示されるユーザーインターフェースを担当します。HTML、CSS、JavaScriptなどを含み、モデルから取得したデータを動的に埋め込むことができます。これにより、表示とロジックを分離し、デザイナーと開発者が協調して作業しやすくなります。\n\n- **機能**: データのレンダリング、表示ロジックの定義\n- **例**: ブログ記事の一覧ページ、お問い合わせフォームなど、ユーザーが目にするウェブページ\n\n### View（ビュー）\nビューは、ユーザーからのリクエストを受け付け、適切なレスポンスを返す役割を担います。ビューはビジネスロジックの中心であり、以下のタスクを実行します。\n\n- **リクエスト処理**: ユーザーからのURLリクエストを解析します。\n- **モデルとの連携**: 必要なデータをモデルから取得したり、モデルにデータを保存したりします。\n- **テンプレートの選択**: 取得したデータを適切なテンプレートに渡し、レンダリングを指示します。\n- **レスポンス生成**: レンダリングされたHTMLをユーザーに返します。\n\n- **機能**: リクエストの受付、ビジネスロジックの実行、テンプレートとモデルの連携\n- **例**: 「/articles/」というURLへのリクエストに対して、すべての記事をデータベースから取得し、テンプレートに渡してHTMLを生成し返すといった処理です。\n\n### MVCとMTVの違い\n一般的なMVCの「Controller」にあたる部分が、Djangoでは「View」と「URLディスパッチャ」によって分担されています。DjangoのViewはビジネスロジックとデータベースとのやり取りを扱い、URLディスパッチャはリクエストを適切なビューにルーティングする役割を担います。これにより、各コンポーネントの役割がより明確になります。\n\n### DjangoのMTVアーキテクチャの主なメリット\n\n1. **役割の明確化と分離**\n   MTVアーキテクチャは、各コンポーネント（モデル、テンプレート、ビュー）の役割を明確に分離します。\n   - モデルはデータ操作のみを担当。\n   - テンプレートは見た目（プレゼンテーション）のみを担当。\n   - ビューはビジネスロジックのみを担当。\n   この分離により、開発者は特定の役割に集中でき、コードの重複を防ぎ、可読性を高めることができます。例えば、データベーススキーマの変更が、テンプレートやビューのコードに影響を与える可能性が低くなります。\n\n2. **協業の促進**\n   役割が明確に分かれているため、チーム内での協業が円滑になります。\n   - バックエンド開発者はモデルとビューのロジックに集中。\n   - フロントエンド開発者やデザイナーはテンプレートのHTMLとCSSに集中。\n   このように役割を分担することで、お互いの作業を妨げることなく、並行して開発を進めることが可能になります。\n\n3. **再利用性の向上**\n   各コンポーネントが独立しているため、コードの再利用性が高まります。\n   - ビューは、複数のテンプレートを使って異なる表示形式を生成できます（例：同じデータをウェブページとモバイルアプリのAPIレスポンスとして返す）。\n   - 一つのテンプレートを複数のビューで使用することもできます（例：異なるモデルのデータを同じレイアウトで表示する）。\n   この特性により、コードのメンテナンスが容易になり、新しい機能の追加も迅速に行えます。\n\n4. **拡張性とメンテナンス性**\n   MTVアーキテクチャは、大規模なプロジェクトでも拡張しやすく、メンテナンスしやすい構造を提供します。\n   コンポーネントが独立しているため、新しい機能を追加する際も、既存のコード全体を理解する必要がありません。問題が発生した場合も、役割ごとに切り分けられているため、原因の特定が容易になります。","src/content/docs/Djangoガイド/02_基本/04_mvc_architecture.mdx","7e0f3f8e6615aaf7","djangoガイド/02_基本/05_validation",{"id":235,"data":237,"body":242,"filePath":243,"digest":244,"deferredRender":16},{"title":238,"editUrl":16,"head":239,"template":18,"sidebar":240,"pagefind":16,"draft":20},"バリデーション",[],{"hidden":20,"attrs":241},{},"## Djangoにおけるバリデーション\nDjangoでは、データの整合性と品質を確保するために、複数のレベルでバリデーションを実施します。これにより、無効なデータがデータベースに保存されるのを防ぎます。\n\n### 1. フィールドレベルのバリデーション\nモデルのフィールドを定義する際、引数として最も基本的なバリデーションルールを指定できます。これは、Djangoのモデルシステムに組み込まれており、開発者がコードをほとんど書くことなく利用できます。\n\n- **max_length**: `CharField`や`TextField`などの文字列フィールドに適用され、入力可能な最大文字数を制限します。\n\n  ```python\n  name = models.CharField(max_length=100) # 名前は100文字以内\n  ```\n\n- **unique=True**: このフィールドの値がデータベース全体で一意であることを保証します。同じ値を持つレコードが複数存在することは許されません。\n\n  ```python\n  email = models.EmailField(unique=True) # メールアドレスは一意\n  ```\n\n- **null=False, blank=False**: `null=False`はデータベースレベルでNULL値が許可されないことを意味し、`blank=False`はフォームで空欄が許可されないことを意味します。これにより、フィールドが必須項目であることを強制できます。\n\n  ```python\n  title = models.CharField(max_length=200, blank=False) # タイトルは必須項目\n  ```\n\n### 2. モデルレベルのバリデーション\n特定のフィールドだけでなく、複数のフィールドにまたがる複雑なバリデーションルールを適用したい場合、**`clean()`**メソッドを使います。このメソッドは、`forms.ModelForm`や管理画面でデータを保存する直前に呼び出されます。\n\n```python\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\n\nclass Event(models.Model):\n    start_date = models.DateField()\n    end_date = models.DateField()\n\n    def clean(self):\n        # 終了日が開始日より前ではないかを確認\n        if self.end_date \u003C self.start_date:\n            raise ValidationError('End date cannot be before start date.')\n```\n\nこの例では、`clean()`メソッド内で`start_date`と`end_date`の値を比較し、無効な場合は`ValidationError`を発生させています。\n\n### ユースケース\nDjangoのバリデーションは、様々なシナリオでデータの品質を保つために利用されます。\n\n- **ユーザー登録**: ユーザー登録フォームで、メールアドレスが既に登録されていないか（`unique=True`）、パスワードが一定の長さ以上か、あるいはパスワードとパスワード確認が一致するか（`clean()`メソッドで確認）を検証します。\n\n- **イベント管理**: イベントの開始日と終了日が正しく設定されているか（前述の`clean()`メソッドの例）、予約人数が最大定員を超えていないかを検証します。\n\n- **オンラインストア**: 商品の在庫数が負の値にならないように検証したり、価格が0より大きいことを確認したりします。\n\n- **ブログ記事**: 記事のタイトルや本文が空でないこと、あるいは特定の文字数制限を超えていないことを検証します。\n\n### フォームレベルのバリデーション\nDjangoには、モデルだけでなく、フォームにもバリデーションを追加する仕組みがあります。これは、ユーザーからの入力データを処理する際に特に重要です。フォームのバリデーションは、モデルに保存する前の段階でエラーをキャッチするため、より効率的なユーザーエクスペリエンスを提供できます。\n\n`forms.Form` や `forms.ModelForm` を使用してフォームを定義し、フィールドごとのバリデーション（例：`clean_field_name`）やフォーム全体のバリデーション（`clean`メソッド）を実装できます。\n\nこの段階でエラーを検出すると、ユーザーに即座にフィードバックを返すことができます。たとえば、「パスワードが短すぎます」といったメッセージをフォームの横に表示することが可能です。\n\n### バリデーションのトリガー\n`clean()`メソッドは、必ずしも自動で実行されるわけではありません。\n\n- **Model.full_clean()**: モデルのインスタンスを手動で保存する前に、すべてのバリデーションルール（フィールドおよび`clean()`メソッド）を実行したい場合は、`full_clean()`メソッドを呼び出す必要があります。\n\n- **ModelForm**: Djangoの管理画面や、`ModelForm`クラスを通じてデータを保存する場合、これらのバリデーションは自動的に呼び出されます。\n\nDjangoのバリデーションシステムは、開発者がデータの整合性を複数の段階で確保できるように設計されており、柔軟性が高いのが特徴です。","src/content/docs/Djangoガイド/02_基本/05_validation.mdx","76f5edd26098999f","djangoガイド/02_基本/07_rest_framework",{"id":245,"data":247,"body":252,"filePath":253,"digest":254,"deferredRender":16},{"title":248,"editUrl":16,"head":249,"template":18,"sidebar":250,"pagefind":16,"draft":20},"Django REST Framework",[],{"hidden":20,"attrs":251},{},"## Django REST Framework (DRF) の概要\n**Django REST Framework（DRF）**は、DjangoでRESTful APIを迅速に構築するためのフレームワークです。APIの構築に必要な多くの機能を標準で提供しており、シリアライゼーション、ビュー、ルーティング、認証、パーミッションなどを簡単に実装できます。DRFはDjangoの哲学である「バッテリー付属」に準拠しており、多くの一般的なAPI開発タスクを簡素化します。\n\n### 1. インストールと設定\nまず、`pip`コマンドでDRFをインストールします。\n\n```bash\npip install djangorestframework\n```\n\n次に、プロジェクトの**`settings.py`**ファイルに`'rest_framework'`を`INSTALLED_APPS`に追加します。\n\n```python\n# settings.py\nINSTALLED_APPS = [\n    ...\n    'rest_framework',\n]\n```\n\nこれで、DRFをプロジェクトで利用する準備が整いました。\n\n### 2. シリアライザーの作成\nシリアライザーは、Djangoモデルのインスタンス（Pythonオブジェクト）を、JSONやXMLのようなAPIで扱えるデータ形式に変換（シリアライズ）する役割を担います。また、その逆の変換（デシリアライズ）も行い、受信したデータを検証し、データベースに保存可能な形式に変換します。\n\n- **`serializers.ModelSerializer`**: 最もよく使われるシリアライザーです。モデルのフィールドからシリアライザーフィールドを自動的に生成し、バリデーションも自動で行います。提供された例のように、`Meta`クラスで変換対象の`model`と`fields`を指定するだけで簡単に利用できます。\n\n```python\nfrom rest_framework import serializers\nfrom myapp.models import User\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'name', 'email']\n```\n\nこのシリアライザーは、`User`モデルのインスタンスを、`id`, `name`, `email`というキーを持つJSONデータに変換します。\n\n### 3. ビューの作成\nシリアライザーを定義したら、次にビューを作成します。ビューは、APIリクエストを処理し、シリアライザーを使ってレスポンスを生成する役割を担います。DRFは、一般的なAPI操作を簡素化するために、いくつかの汎用ビューを提供しています。\n\n- **`generics.ListCreateAPIView`**: データのリスト表示と新規作成を一つのビューで処理します。\n- **`generics.RetrieveUpdateDestroyAPIView`**: 特定のデータ取得、更新、削除を処理します。\n\n```python\n# myapp/views.py\nfrom rest_framework import generics\nfrom .models import User\nfrom .serializers import UserSerializer\n\nclass UserListCreate(generics.ListCreateAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\nclass UserRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n```\n\nこれらのビューは、`queryset`で対象のモデルのデータセットを、`serializer_class`でデータ変換に使うシリアライザーを指定するだけで機能します。\n\n### 4. URLルーティングの設定\n最後に、作成したビューにアクセスするためのURLを設定します。\n\n```python\n# myproject/urls.py\nfrom django.urls import path\nfrom myapp.views import UserListCreate, UserRetrieveUpdateDestroy\n\nurlpatterns = [\n    path('users/', UserListCreate.as_view(), name='user-list'),\n    path('users/\u003Cint:pk>/', UserRetrieveUpdateDestroy.as_view(), name='user-detail'),\n]\n```\n\nこれで、`http://localhost:8000/users/`にアクセスするとユーザー一覧を取得でき、`http://localhost:8000/users/1/`にアクセスするとIDが1のユーザー情報を取得できるようになります。","src/content/docs/Djangoガイド/02_基本/07_rest_framework.mdx","8600c4c803d63fdc","djangoガイド/03_中級/09_orm",{"id":255,"data":257,"body":262,"filePath":263,"digest":264,"deferredRender":16},{"title":258,"editUrl":16,"head":259,"template":18,"sidebar":260,"pagefind":16,"draft":20},"Django ORM",[],{"hidden":20,"attrs":261},{},"## Django ORMの概要\nDjango ORMは、Pythonのコードを使ってデータベースを操作するための強力なツールです。生のSQLクエリを書くことなく、オブジェクト指向の考え方でデータを扱うことが可能になります。\n\n### Django ORMの概要とメリット\nORM（Object-Relational Mapper：オブジェクト関係マッパー）は、データベースのテーブルを行と列で管理するリレーショナルデータベースと、Pythonのようなオブジェクト指向プログラミング言語の間の橋渡しをします。\n\n- **直感的で安全**: 生のSQLを書く代わりに、Pythonのクラスとメソッドを使ってデータを操作できるため、コードが直感的で理解しやすくなります。また、SQLインジェクションのようなセキュリティ上の脆弱性を防ぐことができます。\n\n- **移植性**: データベースの種類（PostgreSQL、MySQL、SQLiteなど）が異なっていても、同じPythonコードでデータベースを操作できます。データベースを変更する際も、設定ファイルを少し変更するだけで済みます。\n\n- **簡潔なコード**: データの取得、フィルタリング、更新といった一般的な操作を、短いコードで簡単に実行できます。\n\n### モデルの定義\nDjango ORMを使うには、まず`django.db.models.Model`を継承したクラスを作成します。このクラスが、データベースのテーブルに対応するモデルとなります。\n\n```python\nfrom django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=200)\n    author = models.CharField(max_length=100)\n    published_date = models.DateField()\n```\n\n- **`models.Model`**: このクラスを継承することで、Django ORMの機能を利用できるようになります。\n- **フィールド**: クラス内の変数は、データベースの列（カラム）に対応します。`CharField`や`DateField`のようなフィールドタイプは、その列にどのような種類のデータが格納されるかを定義します。\n\n### モデル操作の基本\nモデルを定義したら、`manage.py`を使ってデータベースのマイグレーション（スキーマの変更を適用すること）を行い、Pythonのシェルやビューからデータを操作できます。\n\n#### データの取得（クエリ）\n`objects`マネージャを使って、データを取得します。\n\n- **全件取得**: `all()`メソッドでテーブルの全データを取得します。\n\n  ```python\n  books = Book.objects.all()\n  # 取得したデータはクエリセット（リストのようなオブジェクト）になる\n  ```\n\n- **フィルタリング**: `filter()`メソッドを使って、特定の条件に一致するデータを抽出します。\n\n  ```python\n  # 2023年以降に出版された本を検索\n  recent_books = Book.objects.filter(published_date__year__gte=2023)\n  # タイトルに'Django'を含む本を検索（__icontainsは部分一致で大文字小文字を区別しない）\n  django_books = Book.objects.filter(title__icontains='Django')\n  ```\n\n- **単一のデータ取得**: `get()`メソッドで、条件に一致する単一のオブジェクトを取得します。\n\n  ```python\n  book = Book.objects.get(title='Django for Beginners')\n  ```\n\n#### データの作成と更新\n新しいデータを作成したり、既存のデータを更新したりすることも簡単です。\n\n- **新規作成**: オブジェクトをインスタンス化し、`save()`メソッドで保存します。\n\n  ```python\n  new_book = Book(title='ORM Essentials', author='Jane Doe', published_date='2024-01-01')\n  new_book.save()\n  ```\n\n- **更新**: 既存のオブジェクトを取得し、フィールドの値を変更してから`save()`メソッドを呼び出します。\n\n  ```python\n  book = Book.objects.get(title='ORM Essentials')\n  book.author = 'John Smith'\n  book.save()\n  ```\n\nDjango ORMを使うことで、これらの操作を簡潔かつ安全に行うことができます。\n\n### 高度なクエリと関連モデルの操作\nDjango ORMの真価は、複数のテーブルにまたがる複雑なクエリを、Pythonのコードで簡潔に記述できる点にあります。\n\n#### リレーションシップ\nDjangoは、モデル間のリレーションシップ（一対多、多対多、一対一）を簡単に定義できます。これにより、関連するデータを効率的に取得・操作できます。\n\n- **一対多リレーションシップ**: `ForeignKey`フィールドを使って定義します。例えば、一人の著者が複数の本を執筆する場合、`Book`モデルに`Author`モデルへの外部キーを追加します。\n\n  ```python\n  # models.py\n  from django.db import models\n\n  class Author(models.Model):\n      name = models.CharField(max_length=100)\n\n  class Book(models.Model):\n      title = models.CharField(max_length=200)\n      author = models.ForeignKey(Author, on_delete=models.CASCADE)\n  ```\n\n- **関連データの操作**: 関連モデルのデータは、`.`（ドット）を使ってアクセスできます。\n\n  ```python\n  # 著者名を使って本を検索\n  books_by_jane = Book.objects.filter(author__name='Jane Doe')\n\n  # 特定の本の著者の名前を取得\n  book = Book.objects.get(title='ORM Essentials')\n  author_name = book.author.name\n  ```\n\nまた、`related_name`オプションを使うと、逆方向のリレーションシップを分かりやすい名前でアクセスできます。\n\n```python\n# Authorモデルにrelated_nameを追加\nclass Book(models.Model):\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')\n\n# 著者オブジェクトからその著者の全本を取得\njane = Author.objects.get(name='Jane Doe')\nall_books_by_jane = jane.books.all()\n```\n\n#### アノテーションとアグリゲーション\nDjango ORMは、SQLの集計関数（COUNT, SUM, AVGなど）をPythonで実行するための機能を提供します。\n\n- **アグリゲーション（集計）**: `aggregate()`を使って、クエリセット全体に対して集計を行います。\n\n  ```python\n  from django.db.models import Count, Avg\n\n  # 全本の数を数える\n  total_books = Book.objects.count()\n  # または\n  total_books = Book.objects.aggregate(total=Count('id'))\n\n  # 各著者が書いた本の数をカウント\n  author_book_counts = Author.objects.annotate(num_books=Count('books'))\n  ```\n\n- **アノテーション（注釈）**: `annotate()`を使って、クエリセットの各オブジェクトに新しい集計フィールドを追加します。これはグループ化（GROUP BY）の操作を伴う場合に特に役立ちます。\n\n#### データのバルク操作\n個々のオブジェクトをループして`save()`を呼び出すのではなく、複数のオブジェクトを一括で作成、更新、削除するためのバルク操作メソッドもあります。\n\n- **一括作成**: `bulk_create()`メソッドで、複数のオブジェクトを一つのクエリで作成できます。これは、大量のデータをデータベースに投入する際にパフォーマンスを大幅に向上させます。\n\n  ```python\n  Book.objects.bulk_create([\n      Book(title='Book 1', author=jane),\n      Book(title='Book 2', author=jane)\n  ])\n  ```\n\n- **一括更新**: `update()`メソッドで、フィルタリングされたすべてのオブジェクトを一括で更新できます。\n\n  ```python\n  # 2023年以前に出版された本の著者を変更\n  Book.objects.filter(published_date__year__lt=2023).update(author=new_author)\n  ```\n\n#### クエリセットの遅延評価 (Lazy Evaluation)\nDjango ORMのクエリセットは、すぐにデータベースを操作するわけではありません。クエリセットは遅延評価されます。これは、`filter()`や`all()`のようなメソッドを呼び出しても、実際にデータが必要になるまでデータベースクエリが実行されないことを意味します。これにより、不要なデータベースアクセスを防ぎ、パフォーマンスが向上します。\n\n- **具体例**\n\n  ```python\n  # この時点ではデータベースクエリは実行されない\n  recent_books = Book.objects.filter(published_date__year__gte=2023)\n\n  # この時点で初めてクエリが実行される\n  for book in recent_books:\n      print(book.title)\n  ```\n\nこの例では、`filter()`メソッドが呼び出されただけではデータベースアクセスは発生せず、`for`ループでデータを反復処理する際に初めてデータベースクエリが実行されます。この特性を理解することで、クエリを効率的にチェーン（連結）して記述できます。\n\n#### サブクエリ\nDjango ORMでは、サブクエリを簡潔に記述できます。これにより、より複雑な条件に基づいてデータをフィルタリングしたり、アノテーションを付けたりできます。\n\n- **OuterRef と Subquery**: `OuterRef`は外側のクエリセットのフィールドを参照するために使い、`Subquery`はサブクエリを埋め込むために使います。\n\n  ```python\n  from django.db.models import OuterRef, Subquery\n\n  # 各著者が書いた最新の本を取得するサブクエリ\n  latest_books = Book.objects.filter(\n      author=OuterRef('pk')\n  ).order_by('-published_date')\n\n  # 各著者に最新の本のタイトルをアノテーションする\n  authors_with_latest_book = Author.objects.annotate(\n      latest_book_title=Subquery(latest_books.values('title')[:1])\n  )\n  ```\n\nこの例は、各著者オブジェクトに、その著者が書いた最新の本のタイトルをアノテーションとして追加しています。これにより、関連テーブルのデータを効率的に取得できます。\n\n#### 生のSQLの実行\nほとんどのユースケースではDjango ORMで十分ですが、ORMでは表現が難しい複雑なクエリや、パフォーマンスが重要なクエリの場合は、生のSQLを実行することも可能です。\n\n- **`raw()`**: モデルのクエリセットを使って、生のSQLクエリを実行し、結果をモデルのインスタンスとして受け取ります。\n\n  ```python\n  # 生のSQLクエリを実行\n  for book in Book.objects.raw('SELECT * FROM myapp_book WHERE author_id = %s', [1]):\n      print(book.title)\n  ```\n\n- **`connection`**: `django.db.connection`オブジェクトを使って、より低レベルでSQLクエリを直接実行できます。\n\n  ```python\n  from django.db import connection\n\n  with connection.cursor() as cursor:\n      cursor.execute(\"SELECT COUNT(*) FROM myapp_book\")\n      row = cursor.fetchone()\n      print(f'Total books: {row[0]}')\n  ```\n\n生のSQLを使用する場合、ORMの利点（データベース移植性、セキュリティ）の一部が失われるため、注意が必要です。しかし、パフォーマンスがクリティカルな場合に強力な選択肢となります。\n\n#### トランザクション管理\nデータベース操作の完全な実行（コミット）または完全な取り消し（ロールバック）を保証するトランザクションは、データの整合性を維持するために重要です。Django ORMは、このトランザクションを簡単に管理するための機能を提供しています。\n\n1. **自動コミット**\n   Djangoでは、デフォルトで各データベース操作が単一のトランザクションとして自動的にコミットされます。これは、シンプルな操作には便利ですが、複数の操作を一つのまとまりとして扱いたい場合には適していません。\n\n2. **手動トランザクション管理**\n   複数のデータベース操作を一つのアトミックな（不可分な）トランザクションとして実行したい場合は、`atomic()`デコレータまたはコンテキストマネージャを使用します。これにより、途中でエラーが発生した場合、すべての操作がロールバックされ、データの一貫性が保たれます。\n\n   - **例: 複数の書籍情報を一度に保存するトランザクション**\n\n     ```python\n     from django.db import transaction\n\n     # @transaction.atomic\n     # def save_multiple_books():\n     #     # 複数のデータベース操作\n     #     ...\n\n     with transaction.atomic():\n         Book.objects.create(title='Book A', author=jane, published_date='2024-01-01')\n         Book.objects.create(title='Book B', author=jane, published_date='2024-01-02')\n         # 何らかのエラーが発生した場合、両方の操作がロールバックされる\n     ```\n\nこのコードブロック内のすべての操作は、ブロックの最後にエラーなく到達した場合にのみコミットされます。\n\n#### パフォーマンス最適化：select_related と prefetch_related\n関連モデルのデータを取得する際、Django ORMはデフォルトで、関連オブジェクトが必要になるたびに新しいデータベースクエリを実行します。これは「N+1クエリ問題」として知られ、パフォーマンスのボトルネックとなります。この問題を解決するために、`select_related`と`prefetch_related`が用意されています。\n\n1. **`select_related()` (一対一、一対多)**\n   `select_related()`は、単一のデータベースクエリで、指定された関連オブジェクトのデータを取得します。これにより、追加のクエリが不要になります。このメソッドは、外部キーや一対一の関係に最適です。\n\n   - **例: すべての書籍とその著者を一つのクエリで取得する**\n\n     ```python\n     # 通常のアクセス：N+1クエリが発生\n     books = Book.objects.all()\n     for book in books:\n         print(book.author.name) # ループごとに新しいクエリが発生\n\n     # select_relatedを使用：単一のクエリに結合される\n     books = Book.objects.select_related('author').all()\n     for book in books:\n         print(book.author.name) # データベースアクセスなし\n     ```\n\n   この場合、`select_related('author')`はBookとAuthorのテーブルを**SQLのJOIN**で結合し、効率的にデータを取得します。\n\n2. **`prefetch_related()` (多対多、リバースフォワードキー)**\n   `prefetch_related()`は、関連するオブジェクトのデータを別のクエリで取得し、Pythonのメモリ内で関連付けを行います。これは、多対多や、ForeignKeyの逆方向の関係など、より複雑な関係に最適です。\n\n   - **例: 各著者が書いた本を効率的に取得する**\n\n     ```python\n     # related_name='books'が定義されているAuthorモデル\n     # N+1クエリが発生\n     authors = Author.objects.all()\n     for author in authors:\n         print(author.books.all()) # ループごとに新しいクエリが発生\n\n     # prefetch_relatedを使用：2つのクエリで処理される\n     authors = Author.objects.prefetch_related('books').all()\n     for author in authors:\n         print(author.books.all()) # データベースアクセスなし\n     ```\n\n   `prefetch_related('books')`は、まずAuthorのクエリを実行し、次にすべての関連するBookのクエリを一つで実行します。その後、Python側で各著者にその本を紐付けます。\n\nこれらの機能は、Djangoアプリケーションのパフォーマンスを大きく左右するため、大規模なデータセットを扱う際には不可欠な知識となります。\n\n#### カスタムマネージャとクエリセットメソッド\nDjangoのマネージャ（`objects`など）は、データベース操作のためのインターフェースです。独自のカスタムマネージャを作成することで、特定のモデルに特化した再利用可能なクエリメソッドを追加できます。これにより、コードの重複を減らし、より簡潔なコードを記述できます。\n\n- **カスタムマネージャの作成**\n  - `models.Manager`を継承したクラスを作成します。\n  - そのクラスをモデルにアタッチ（関連付け）します。\n\n  - **例: `published`というカスタムマネージャを作成し、公開済みの記事を簡単に取得できるようにする**\n\n    ```python\n    # myapp/managers.py\n    from django.db import models\n\n    class PublishedArticleManager(models.Manager):\n        def get_queryset(self):\n            # 親クラスのクエリセットをオーバーライド\n            return super().get_queryset().filter(is_published=True)\n\n    # myapp/models.py\n    from django.db import models\n    from .managers import PublishedArticleManager\n\n    class Article(models.Model):\n        title = models.CharField(max_length=200)\n        content = models.TextField()\n        is_published = models.BooleanField(default=False)\n        \n        # カスタムマネージャをアタッチ\n        objects = models.Manager() # デフォルトのマネージャ\n        published = PublishedArticleManager() # カスタムマネージャ\n    ```\n\n  これで、`Article.published.all()`のように呼び出すだけで、公開済みの記事のみを取得できます。\n\n- **カスタムクエリセットメソッド**\n  カスタムマネージャをさらに拡張して、カスタムクエリセットクラスを作成することもできます。これにより、チェーン可能な新しいメソッドをクエリセットに追加できます。\n\n  - **例: `with_authors()`というメソッドを追加し、著者の情報も一緒に取得できるようにする**\n\n    ```python\n    # myapp/models.py\n    from django.db import models\n\n    class ArticleQuerySet(models.QuerySet):\n        def with_authors(self):\n            # select_relatedを使って著者の情報をプリフェッチ\n            return self.select_related('author')\n\n    class Article(models.Model):\n        ...\n        # カスタムクエリセットをマネージャにアタッチ\n        objects = models.Manager.from_queryset(ArticleQuerySet)()\n    ```\n\n  この設定後、`Article.objects.with_authors().filter(is_published=True)`のように、他のメソッドと組み合わせて使うことができます。\n\n#### マイグレーションの高度な管理\n`makemigrations`と`migrate`は、Django ORMの変更をデータベースに適用する基本的なコマンドですが、より複雑なシナリオに対応するための高度な機能も持っています。\n\n1. **データマイグレーション**\n   モデルのスキーマ変更だけでなく、データ自体を変更するマイグレーションを作成することもできます。これは、既存のデータを新しいスキーマに合わせて変換する場合に便利です。`migrations.RunPython`を使って、Pythonコードでデータの移行ロジックを記述できます。\n\n   - **例: 既存のユーザーの`first_name`と`last_name`を`full_name`フィールドに結合する**\n\n     ```python\n     # 0002_user_full_name.py (マイグレーションファイル)\n     from django.db import migrations, models\n\n     def combine_names(apps, schema_editor):\n         User = apps.get_model('myapp', 'User')\n         for user in User.objects.all():\n             user.full_name = f'{user.first_name} {user.last_name}'\n             user.save()\n\n     class Migration(migrations.Migration):\n         dependencies = [\n             ('myapp', '0001_initial'),\n         ]\n\n         operations = [\n             migrations.AddField(\n                 model_name='user',\n                 name='full_name',\n                 field=models.CharField(max_length=200, null=True),\n             ),\n             migrations.RunPython(combine_names),\n         ]\n     ```\n\n2. **マイグレーションの管理**\n   - `--empty`: 何も変更せずに空のマイグレーションファイルを作成します。データマイグレーションのロジックを手動で追加する際に使います。\n   - `--name`: マイグレーションファイルに分かりやすい名前を付けられます。\n   - `squashmigrations`: 複数のマイグレーションファイルを一つにまとめることで、プロジェクトの履歴を整理できます。\n   - `showmigrations`: マイグレーションの適用状況を確認できます。\n\n#### モデル継承\nDjango ORMでは、Pythonのクラス継承の仕組みを利用して、モデル間で共通のフィールドやメソッドを共有できます。これにより、コードの重複を減らし、メンテナンス性を向上させられます。\n\n1. **抽象基底クラス (Abstract Base Classes)**\n   抽象基底クラスは、それ自体がデータベーステーブルを作成せず、その子モデルにフィールドを継承させるためのモデルです。これは、複数のモデルで共通のフィールド（例：作成日時、更新日時）を持たせたい場合に最適です。\n\n   - `abstract=True` を`Meta`クラスで設定します。\n\n     ```python\n     # models.py\n     from django.db import models\n\n     class CommonInfo(models.Model):\n         name = models.CharField(max_length=100)\n         created_at = models.DateTimeField(auto_now_add=True)\n\n         class Meta:\n             abstract = True\n\n     class Student(CommonInfo):\n         age = models.IntegerField()\n\n     class Teacher(CommonInfo):\n         subject = models.CharField(max_length=50)\n     ```\n\n   この例では、`Student`と`Teacher`モデルが`name`と`created_at`フィールドを継承し、それぞれ独自のフィールド（`age`と`subject`）を持っています。\n\n2. **多重テーブル継承 (Multi-table Inheritance)**\n   多重テーブル継承は、子モデルが親モデルのフィールドを継承し、独自のデータベーステーブルを持つ形式です。各モデルが独自のテーブルを持つため、親モデルと子モデルの間で一対一の関係が自動的に構築されます。\n\n   ```python\n   class Place(models.Model):\n       name = models.CharField(max_length=100)\n\n   class Restaurant(Place):\n       serves_pizza = models.BooleanField(default=False)\n   ```\n\n   `Restaurant`オブジェクトを保存すると、`Place`テーブルと`Restaurant`テーブルの両方にデータが保存されます。\n\n3. **プロキシモデル (Proxy Models)**\n   プロキシモデルは、既存のモデルの振る舞いを変更するために使用されますが、独自のデータベーステーブルは作成しません。これは、元のモデルの列（カラム）やテーブル構造を変更せずに、新しいメソッドやデフォルトのマネージャを追加したい場合に非常に役立ちます。\n\n   - `proxy=True` を`Meta`クラスで設定します。\n\n     ```python\n     # models.py\n     from django.db import models\n\n     class Article(models.Model):\n         title = models.CharField(max_length=200)\n         is_published = models.BooleanField(default=False)\n         \n     class PublishedArticleManager(models.Manager):\n         def get_queryset(self):\n             return super().get_queryset().filter(is_published=True)\n\n     class PublishedArticle(Article):\n         objects = PublishedArticleManager() # カスタムマネージャを追加\n\n         class Meta:\n             proxy = True\n\n         def publish_now(self):\n             self.is_published = True\n             self.save()\n     ```\n\n   `PublishedArticle`モデルは、`Article`モデルのプロキシとして機能します。これは、`Article`テーブルのデータをそのまま使用しつつ、`is_published=True`のオブジェクトのみを扱うカスタムマネージャや、`publish_now`のような新しいメソッドを追加できます。\n\nこれらの高度な機能は、より複雑なアプリケーションを設計し、管理する際に、コードの整理と再利用を強力にサポートします。","src/content/docs/Djangoガイド/03_中級/09_orm.mdx","a0c9672fc2f651ca","djangoガイド/03_中級/apiモード",{"id":265,"data":267,"body":272,"filePath":273,"digest":274,"deferredRender":16},{"title":268,"editUrl":16,"head":269,"template":18,"sidebar":270,"pagefind":16,"draft":20},"APIモード",[],{"hidden":20,"attrs":271},{},"## DjangoのAPIモードとは\nDjangoには、デフォルトで「APIモード」という特別な設定があるわけではありません。DjangoをAPIとして機能させるためには、**Django REST Framework（DRF）**のようなライブラリを組み合わせて使用することが一般的です。これにより、ウェブサイトの機能とAPI機能を共存させたり、API専用のバックエンドを構築したりすることができます。\n\n### APIモードの主要コンポーネント\nDjangoでAPIを構築する際は、以下の主要なコンポーネントを理解することが重要です。\n\n1. **シリアライザー（Serializer）**\n   シリアライザーは、Djangoのモデルインスタンス（Pythonオブジェクト）と、APIで扱うJSONやXMLなどのデータ形式との間で変換を行う役割を担います。\n\n   - **シリアライゼーション**: モデルインスタンスをJSON形式に変換し、レスポンスとして返す。\n   - **デシリアライゼーション**: JSON形式のデータを受信し、モデルインスタンスに変換してデータベースに保存する。\n   - **バリデーション**: 受信したデータが正しい形式かどうかを検証する。\n\n2. **ビュー（View）**\n   ビューは、APIリクエストを処理し、シリアライザーを使ってレスポンスを生成します。DRFでは、API開発を効率化するために、一般的な操作を簡潔に記述できる汎用ビューが提供されています。\n\n   - **リクエスト処理**: GET、POST、PUT、DELETEなどのHTTPリクエストを処理。\n   - **データ取得・保存**: モデルを操作してデータベースからデータを取得したり、保存したりする。\n   - **レスポンス生成**: シリアライザーを使ってデータを整形し、レスポンスを返す。\n\n3. **ルーティング（Routing）**\n   ルーティングは、特定のURLがどのビューによって処理されるかを定義します。これにより、APIのエンドポイントを整理し、構造化されたURLを設計できます。\n\n   - **URLパターンとビューを結びつける。**\n   - **エンドポイントを論理的にグループ化する。**\n\n### APIモードのユースケース\nDjangoをAPIとして利用する主なユースケースは以下の通りです。\n\n- **SPA（Single Page Application）のバックエンド**: React、Vue.js、Angularといったフロントエンドフレームワークと連携し、データを提供するAPIサーバーとして機能します。\n- **モバイルアプリケーションのバックエンド**: iOSやAndroidアプリにデータを供給するためのAPIを構築します。\n- **マイクロサービス**: 複数のサービスが連携するアーキテクチャにおいて、他のサービスにデータや機能を提供するAPIとして利用されます。\n\nこれらのコンポーネントを組み合わせることで、Djangoは柔軟かつ強力なAPIバックエンドとして機能し、多様なクライアントからのデータ要求に応えることができます。\n\nここでは、簡単なブログアプリケーションを想定し、「記事（Article）」データを操作するAPIを作成します。\n\n1. **モデルの定義**\n   まず、APIで扱うデータを定義するDjangoモデルを作成します。\n\n   ```python\n   # blog/models.py\n   from django.db import models\n\n   class Article(models.Model):\n       title = models.CharField(max_length=200)\n       content = models.TextField()\n       is_published = models.BooleanField(default=False)\n       created_at = models.DateTimeField(auto_now_add=True)\n       updated_at = models.DateTimeField(auto_now=True)\n\n       def __str__(self):\n           return self.title\n   ```\n\n2. **シリアライザーの作成**\n   次に、モデルをJSON形式に変換するためのシリアライザーを作成します。`ModelSerializer`を使うと、モデルのフィールドを自動的にマッピングしてくれます。\n\n   ```python\n   # blog/serializers.py\n   from rest_framework import serializers\n   from .models import Article\n\n   class ArticleSerializer(serializers.ModelSerializer):\n       class Meta:\n           model = Article\n           fields = ['id', 'title', 'content', 'is_published', 'created_at']\n   ```\n\n3. **ビューの作成**\n   APIのリクエストを処理するビューを作成します。ここでは、DRFの汎用ビューを使用し、CRUD（作成、読み取り、更新、削除）操作を簡潔に実装します。\n\n   ```python\n   # blog/views.py\n   from rest_framework import generics\n   from .models import Article\n   from .serializers import ArticleSerializer\n\n   # 記事のリスト表示と新規作成\n   class ArticleListCreateView(generics.ListCreateAPIView):\n       queryset = Article.objects.all()\n       serializer_class = ArticleSerializer\n\n   # 特定の記事の取得、更新、削除\n   class ArticleRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):\n       queryset = Article.objects.all()\n       serializer_class = ArticleSerializer\n   ```\n\n4. **URLルーティングの設定**\n   最後に、APIのエンドポイントを定義します。これにより、特定のURLパターンが対応するビューと紐付けられます。\n\n   ```python\n   # myproject/urls.py\n   from django.urls import path\n   from blog.views import ArticleListCreateView, ArticleRetrieveUpdateDestroyView\n\n   urlpatterns = [\n       # APIのルートエンドポイント\n       path('api/articles/', ArticleListCreateView.as_view(), name='article-list'),\n       \n       # IDを指定して特定の記事を操作するエンドポイント\n       path('api/articles/\u003Cint:pk>/', ArticleRetrieveUpdateDestroyView.as_view(), name='article-detail'),\n   ]\n   ```\n\nこのコードをデプロイすると、以下のAPIエンドポイントが利用可能になります。\n\n```bash\n- **GET /api/articles/**: すべての記事をリストで取得します。\n- **POST /api/articles/**: 新しい記事を作成します。\n- **GET /api/articles/\u003Cid>/**: 特定の記事を取得します。\n- **PUT /api/articles/\u003Cid>/**: 特定の記事を更新します。\n- **DELETE /api/articles/\u003Cid>/**: 特定の記事を削除します。\n```\n\nDRFのブラウザブルAPI機能のおかげで、これらのエンドポイントにウェブブラウザから直接アクセスし、簡単に動作を確認できます。","src/content/docs/Djangoガイド/03_中級/APIモード.mdx","ba0dbe0766e98a77","djangoガイド/03_中級/頻出ライブラリ",{"id":275,"data":277,"body":282,"filePath":283,"digest":284,"deferredRender":16},{"title":278,"editUrl":16,"head":279,"template":18,"sidebar":280,"pagefind":16,"draft":20},"頻出ライブラリ",[],{"hidden":20,"attrs":281},{},"Djangoは単体でも強力なフレームワークですが、エコシステムを構成する頻出ライブラリと組み合わせることで、開発効率とアプリケーションの機能を大幅に向上させることができます。\n\n1. Django REST Framework (DRF)\nDjango REST Frameworkは、DjangoでRESTful APIを構築するためのデファクトスタンダードです。API開発に必要なほとんどの機能（シリアライゼーション、ビュー、認証、パーミッションなど）を提供し、DRFなしでAPIを開発するのは非常に非効率的です。ブラウザブルAPI機能により、開発中のデバッグも容易になります。\n\nユースケース: SPA（Single Page Application）のバックエンド、モバイルアプリケーションのAPI、外部サービスとの連携ポイントなど、APIを必要とするあらゆる場面で利用します。\n\n2. Django Debug Toolbar\nDjango Debug Toolbarは、開発中に発生するパフォーマンスの問題を特定するための強力なツールです。ウェブページの下部に表示されるパネルで、データベースクエリの数、テンプレートのレンダリング時間、キャッシュの使用状況などをリアルタイムに確認できます。これにより、「N+1クエリ問題」のようなパフォーマンスのボトルネックを素早く見つけ出し、修正できます。\n\nユースケース: アプリケーション開発中のパフォーマンス最適化、非効率なクエリの特定、メモリ使用量の監視など。\n\n3. Pillow\nPillowは、Pythonで画像を扱うためのライブラリです。Djangoでは、ユーザーがアップロードした画像をリサイズしたり、サムネイルを生成したりする際にPillowを頻繁に利用します。DjangoのImageFieldと組み合わせて使うことで、画像のアップロードから加工までをスムーズに実装できます。\n\nユースケース: ユーザープロフィール画像の自動リサイズ、ブログ記事のサムネイル画像生成、画像ファイルの形式変換など。\n\n4. django-crispy-forms\n**django-crispy-forms**は、Djangoのフォームを素早く美しくレンダリングするためのライブラリです。HTMLを手動で書くことなく、BootstrapやTailwind CSSなどのCSSフレームワークに準拠したフォームを簡単に作成できます。これにより、フロントエンドの作業を大幅に削減できます。\n\nユースケース: ユーザー登録フォーム、お問い合わせフォーム、検索フォームなど、ウェブアプリケーションのほぼ全てのフォーム要素。\n\n5. Celery\nCeleryは、非同期タスクキューを扱うためのライブラリです。Djangoのウェブサーバーが、時間のかかる処理（例：メール送信、画像の大量処理、レポート生成）でブロックされないように、これらのタスクをバックグラウンドで非同期に実行します。これにより、ユーザーインターフェースがスムーズに保たれ、アプリケーションの応答性が向上します。\n\nユースケース: ユーザー登録時のウェルカムメール送信、複雑なデータ処理、定期的なバッチジョブなど。\n\n6. django-allauth\ndjango-allauthは、ソーシャル認証やアカウント管理機能を統合的に扱うためのライブラリです。一般的なユーザー名・パスワード認証だけでなく、Google、GitHub、Twitterなどのソーシャルアカウントを使った認証機能も簡単に実装できます。アカウント登録、パスワードリセット、メールアドレスの確認といった一連のワークフローが事前に用意されているため、開発時間を大幅に短縮できます。\n\nユースケース: ユーザーが複数のソーシャルメディアアカウントでログインできるようにする、会員登録・ログイン機能を迅速に構築する。\n\n7. django-storages\ndjango-storagesは、ファイルストレージのバックエンドを簡単に切り替えるためのライブラリです。ローカルファイルシステムだけでなく、Amazon S3やGoogle Cloud Storageなどのクラウドストレージにファイルを保存する際に役立ちます。設定ファイルを少し変更するだけで、ストレージ先を本番環境と開発環境でシームレスに切り替えることができます。\n\nユースケース: 大量のユーザーアップロードファイルを効率的に管理する、サーバーのディスク容量を節約する、スケーラビリティを確保する。\n\n8. Gunicorn / uWSGI\nGunicornやuWSGIは、Djangoアプリケーションを本番環境で運用するために不可欠なWSGIサーバーです。Djangoの開発用サーバーはテストや開発には便利ですが、本番環境でのパフォーマンスやセキュリティには向きません。これらのサーバーは、複数のリクエストを同時に処理でき、Webサーバー（Nginx, Apacheなど）と連携してアプリケーションの安定した稼働を支えます。\n\nユースケース: Djangoアプリケーションを本番環境でデプロイする。\n\n9. django-filter\ndjango-filterは、DjangoのビューやREST APIでデータのフィルタリング機能を簡単に実装するためのライブラリです。URLのクエリパラメータ（例: /products?category=electronics&price=20000）に基づいて、データベースのデータを絞り込むことができます。これにより、カスタムコードを書くことなく、高度な検索機能を提供できます。\n\nユースケース: Eコマースサイトの商品検索、ブログ記事のカテゴリ別表示、ユーザーリストのフィルタリングなど。","src/content/docs/Djangoガイド/03_中級/頻出ライブラリ.mdx","0bcfc6125550dab5","dockerガイド/02_基本/dockerfileの中身",{"id":285,"data":287,"body":292,"filePath":293,"digest":294,"deferredRender":16},{"title":288,"editUrl":16,"head":289,"template":18,"sidebar":290,"pagefind":16,"draft":20},"Docker構成",[],{"hidden":20,"attrs":291},{},"# Rails アプリケーションの Dockerfile 構成\n\nRails アプリケーションの Dockerfile は、Ruby の実行環境と、必要なライブラリ、データベースクライアントなどを構築します。\n\n## 1. ベースイメージの指定\n\n- **FROM:** ベースとなるイメージを指定します。`ruby:3.2.2` のようにバージョンを明示することで、環境の再現性を高めます。\n\n## 2. 作業ディレクトリの設定\n\n- **WORKDIR:** コンテナ内で作業を行うディレクトリを設定します。これにより、以降のコマンドはこのディレクトリ内で実行されます。\n\n## 3. 必要なパッケージのインストール\n\n- **RUN:** コンテナ内でコマンドを実行します。ここでは、Node.js や yarn、データベースクライアント（例：postgresql-client）といった、Rails アプリケーションに必要な依存関係をインストールします。複数の RUN コマンドをまとめることで、レイヤー数を減らし、イメージサイズを最適化できます。\n\n## 4. ファイルのコピーとインストール\n\n- **COPY:** ローカルのファイルをコンテナ内にコピーします。`Gemfile` と `Gemfile.lock` を先にコピーして `bundle install` を実行することで、コードが変更されても Gem のインストールレイヤーを再利用できます。\n\n## 5. サーバー起動コマンド\n\n- **CMD:** コンテナが起動したときに実行されるコマンドを定義します。開発環境では `rails s -b 0.0.0.0` のようにサーバーを起動するコマンド、本番環境では `bundle exec rails s -e production` などが一般的です。\n\n### Dockerfile\n\n```dockerfile\n# ベースイメージは、Ruby と Node.js が含まれるものを使用\nFROM ruby:3.2.2\n\n# 必要なパッケージをインストール\nRUN apt-get update && apt-get install -y \\\n    postgresql-client \\\n    git \\\n    build-essential \\\n    libpq-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# 作業ディレクトリを設定\nWORKDIR /app\n\n# Gemfile と Gemfile.lock をコピーして bundle install を実行\nCOPY Gemfile Gemfile.lock ./\nRUN bundle install\n\n# ソースコード全体をコピー\nCOPY . .\n\n# サーバー起動コマンド\nCMD [\"rails\", \"s\", \"-b\", \"0.0.0.0\"]\n```\n\n# Next.js アプリケーションの Dockerfile 構成\n\nNext.js の Dockerfile は、マルチステージビルドを使用するのが一般的です。これにより、開発環境に必要なツール（npm など）を含まず、本番環境で必要なファイルのみを含む軽量なイメージを作成できます。\n\n## 第一ステージ（builder）\n\n- **FROM:** ビルド用のベースイメージを指定します。\n- **WORKDIR:** 作業ディレクトリを設定します。\n- **COPY:** `package.json` と `package-lock.json` をコピーして、`npm install` を実行します。\n- **RUN:** `npm run build` を実行し、本番環境用の Next.js アプリケーションをビルドします。\n\n## 第二ステージ（本番環境）\n\n- **FROM:** 本番環境用のベースイメージを指定します。通常はより軽量な Node.js イメージを使用します。\n- **WORKDIR:** 作業ディレクトリを設定します。\n- **COPY --from=builder:** 第一ステージでビルドした成果物（`.next`、`public`、`node_modules` など）をコピーします。これにより、本番環境のイメージにビルドツールを含める必要がなくなります。\n- **CMD:** アプリケーションを本番モードで起動するコマンドを定義します。\n\n### Dockerfile\n\n```dockerfile\n# 第一ステージ: ビルド\nFROM node:18-alpine AS builder\n\nWORKDIR /app\n\nCOPY package.json package-lock.json ./\nRUN npm install\n\nCOPY . .\nRUN npm run build\n\n# 第二ステージ: 本番環境\nFROM node:18-alpine\n\nWORKDIR /app\n\n# .env.production や public フォルダをコピー\nCOPY --from=builder /app/.next ./.next\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/public ./public\nCOPY --from=builder /app/package.json ./package.json\n\n# ポートを公開\nEXPOSE 3000\n\n# 本番環境で起動\nCMD [\"npm\", \"start\"]\n```\n\nこれらの構成は一般的なものであり、各プロジェクトの要件に合わせてカスタマイズできます。","src/content/docs/Dockerガイド/02_基本/Dockerfileの中身.mdx","0240245f655a5445","dockerガイド/01_はじめに/dockerとは",{"id":295,"data":297,"body":302,"filePath":303,"digest":304,"deferredRender":16},{"title":298,"editUrl":16,"head":299,"template":18,"sidebar":300,"pagefind":16,"draft":20},"Dockerとは",[],{"hidden":20,"attrs":301},{},"# Dockerとは\n\nDocker とは、アプリケーションとその実行環境をコンテナとしてパッケージ化し、開発から本番環境まで同じように動作させるためのプラットフォームです。これにより、「私の環境では動くのに」といった問題を解消し、開発者がアプリケーションの構築に集中できるようになります。\n\n## 1. コンテナとは何か 📦\n\nコンテナは、アプリケーションと、そのアプリケーションが動作するために必要なすべてのもの（ライブラリ、依存関係、設定ファイルなど）を軽量で独立したパッケージにまとめたものです。仮想マシン（VM）と似ていますが、OS 全体を仮想化する VM とは異なり、コンテナはホスト OS のカーネルを共有するため、より軽量かつ高速に動作します。\n\n## 2. Docker の主要な構成要素\n\nDocker は、以下の3つの主要な要素で構成されています。\n\n### Dockerfile\n\nDockerfile は、Docker イメージを作成するための設計図です。ファイルには、ベースとなる OS、必要なソフトウェアのインストール、環境設定、そしてアプリケーションの実行コマンドなど、イメージを構築する手順がステップバイステップで記述されています。\n\n### Docker Image\n\nDocker Image は、Dockerfile の内容に基づいて構築された実行可能なテンプレートです。このイメージを元に、コンテナを何度でも同じ状態で生成することができます。イメージは Docker Hub などのレジストリに保存し、共有することが可能です。\n\n### Docker Container\n\nDocker Container は、Docker Image から生成された実行中のインスタンスです。コンテナは互いに隔離されており、それぞれが独立した環境で動作します。これにより、同じサーバー上で複数のコンテナを動かしても、互いに影響を与えることはありません。\n\n## 3. なぜ Docker を使うのか\n\n- **環境の統一:** 開発、テスト、本番環境で同じコンテナを使用することで、「環境の違いによるバグ」を防ぎます。\n\n- **再現性の向上:** Dockerfile を共有することで、誰でも同じ開発環境を簡単に構築できます。\n\n- **スケーラビリティ:** 複数のコンテナを簡単に複製してスケールアウトできるため、高負荷なアプリケーションにも対応しやすくなります。\n\n- **軽量性:** 仮想マシンよりも軽量で起動が速いため、リソースの効率的な利用が可能です。\n\n## 4. Docker Hub\n\nDocker Hub は、Docker イメージを共有・管理するためのクラウドサービスです。GitHub がソースコードのリポジトリであるように、Docker Hub は Docker イメージのリポジトリとして機能します。\n\n- **共有と再利用:** 作成したイメージを Docker Hub にプッシュすることで、他の開発者と簡単に共有できます。また、公式イメージやコミュニティが公開しているイメージ（例：ubuntu、nginx、mongo など）をプルして、ベースとして利用することも可能です。\n\n- **バージョン管理:** イメージにはタグを付けてバージョン管理ができます。これにより、特定のバージョンの環境を正確に再現できます。\n\n## 5. Docker Compose\n\nDocker Compose は、複数のコンテナをまとめて管理するためのツールです。特に、データベース、バックエンド API、フロントエンドといった複数のサービスで構成されるアプリケーションを扱う際に非常に便利です。\n\n- **docker-compose.yml:** この YAML ファイルに、各コンテナのイメージ、ポート、ボリューム、ネットワークなどを定義します。\n\n- **一括管理:** `docker-compose up` コマンド一つで、定義されたすべてのサービスを一度に起動・停止できます。これにより、複雑な環境構築の手順を簡略化し、開発者がアプリケーションの開発に集中できるメリットがあります。\n\nDocker Hub と Docker Compose は、Docker のエコシステムを支える重要なツールであり、効率的な開発ワークフローに不可欠な要素です。","src/content/docs/Dockerガイド/01_はじめに/Dockerとは.mdx","5ba7ea1e010b30a1","dockerガイド/01_はじめに/環境構築",{"id":305,"data":307,"body":312,"filePath":313,"digest":314,"deferredRender":16},{"title":308,"editUrl":16,"head":309,"template":18,"sidebar":310,"pagefind":16,"draft":20},"Docker 環境構築",[],{"hidden":20,"attrs":311},{},"# Docker 環境構築\n\nDocker の基本的な環境構築について説明します。Docker を利用することで、開発環境を簡単に再現・共有できます。\n\n## 1. Docker Desktop のインストール\n\nDocker を利用するためには、まず Docker Desktop をインストールする必要があります。お使いの OS に応じて、以下の公式ページからダウンロードしてください。\n\n- **Windows:** Docker Desktop for Windows\n- **macOS:** Docker Desktop for Mac\n- **Linux:** Docker Desktop for Linux\n\n## 2. Dockerfile の作成\n\nDockerfile は、Docker イメージを構築するための手順を記述したテキストファイルです。プロジェクトのルートディレクトリに Dockerfile という名前でファイルを作成します。\n\n### 例: Node.js 環境\n\n```dockerfile\n# ベースイメージの指定\nFROM node:18-alpine\n\n# 作業ディレクトリの設定\nWORKDIR /app\n\n# アプリケーションの依存関係をコピー\nCOPY package.json ./\n\n# 依存関係のインストール\nRUN npm install\n\n# アプリケーションのソースコードをコピー\nCOPY . .\n\n# アプリケーションの実行コマンド\nCMD [\"npm\", \"start\"]\n```\n\n## 3. Docker Compose の利用\n\n複数のコンテナを連携させてアプリケーションを構築する場合、Docker Compose を利用するのが一般的です。`docker-compose.yml` ファイルをプロジェクトのルートディレクトリに作成します。\n\n### 例: Node.js と MongoDB の連携\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - .:/app\n    depends_on:\n      - db\n\n  db:\n    image: mongo:latest\n    volumes:\n      - db-data:/data/db\n\nvolumes:\n  db-data:\n```\n\n## 4. コンテナのビルドと実行\n\n`docker-compose.yml` があるディレクトリで以下のコマンドを実行すると、コンテナがビルドされて起動します。\n\n```bash\ndocker-compose up -d --build\n```\n\n- **up:** コンテナを起動します。\n- **-d:** バックグラウンドで実行します。\n- **--build:** イメージを再ビルドします。\n\nコンテナを停止する場合は、以下のコマンドを実行します。\n\n```bash\ndocker-compose down\n```\n\nこの内容を参考に、ご自身のプロジェクトに合わせて Dockerfile や Docker Compose ファイルをカスタマイズしてください。","src/content/docs/Dockerガイド/01_はじめに/環境構築.mdx","c2b0946bb84358c8","djangoガイド/04_上級最適化/06_admin_interface",{"id":315,"data":317,"body":322,"filePath":323,"digest":324,"deferredRender":16},{"title":318,"editUrl":16,"head":319,"template":18,"sidebar":320,"pagefind":16,"draft":20},"管理インターフェース",[],{"hidden":20,"attrs":321},{},"## Djangoの管理インターフェース\nDjangoの管理インターフェースは、開発者がアプリケーションのデータを簡単に管理できるよう、自動生成されるウェブアプリケーションです。モデルを定義するだけで、データの追加、編集、削除、閲覧ができる強力な管理画面が手に入ります。これは、開発初期段階でのデータ入力や、顧客やコンテンツを管理するためのツールとして非常に役立ちます。\n\n### 管理ユーザーの作成\n管理インターフェースにアクセスするには、まず管理者権限を持つユーザーを作成する必要があります。以下のコマンドを実行してください。\n\n```bash\npython manage.py createsuperuser\n```\n\nこのコマンドを実行すると、ユーザー名、メールアドレス、パスワードの入力を求められます。これらの情報を入力し、管理者ユーザーを作成します。\n\n### 管理インターフェースへのアクセス\n開発サーバーが起動している状態で、ブラウザから以下のURLにアクセスします。\n\n```\nhttp://localhost:8000/admin\n```\n\n先ほど作成した管理者ユーザーの認証情報（ユーザー名とパスワード）を入力してログインすると、管理画面にアクセスできます。初期状態では、ユーザーとグループの管理セクションのみが表示されます。\n\n### モデルを管理画面に登録する\n作成したカスタムモデル（例：BlogアプリのArticleモデル）を管理画面に表示するには、そのモデルを管理サイトに登録する必要があります。\n\n1. **admin.pyファイルの編集**\n   アプリケーションディレクトリ内にある`admin.py`ファイルを以下のように編集します。\n\n   ```python\n   from django.contrib import admin\n   from .models import Article\n\n   admin.site.register(Article)\n   ```\n\n   このコードは、`Article`モデルをDjangoの管理サイトに登録するシンプルな方法です。\n\n2. **開発サーバーの再起動**\n   ファイルを保存後、開発サーバーを再起動するか、自動でリロードされるのを確認します。\n   管理画面を再読み込みすると、`Article`モデルが新しいセクションとして追加されているのが確認できます。これで、管理画面から`Article`モデルのデータの追加や編集ができるようになります。\n\nDjangoの管理インターフェースは、開発者がビジネスロジックに集中できるよう、バックエンドの管理ツールを迅速に提供してくれる非常に強力な機能です。\n\n### 管理者ユーザーを作成するメリット\n管理者ユーザーを作成する主なメリットは、開発や運用フェーズでデータの管理を効率化できる点にあります。\n\n- **開発初期のデータ投入**: アプリケーション開発の初期段階では、テスト用のデータをデータベースに手動で入力する必要があります。管理者ユーザーを作成し、管理インターフェースを利用することで、SQLコマンドを直接書くことなく、視覚的に簡単にデータを追加・編集・削除できます。\n\n- **非エンジニアでも利用可能**: 誰でも簡単に扱えるGUI（グラフィカルユーザーインターフェース）を通じて、アプリケーションのデータを管理できるため、技術的な知識がないマーケティング担当者やコンテンツ管理者でも、ブログ記事の投稿や顧客情報の管理などができます。これにより、開発者はアプリケーションのコア機能開発に集中できます。\n\n- **セキュリティと権限管理**: Djangoの管理インターフェースは、ユーザー、グループ、権限の管理機能を標準で備えています。これにより、特定のユーザーに特定のモデルのデータ編集権限だけを与えるなど、きめ細かなアクセス制御が可能です。これは、チームでプロジェクトを運営する際に非常に重要です。\n\n### 管理ユーザー作成時の補足情報\n`createsuperuser`コマンドは、いくつか追加の機能も持っています。\n\n- **非対話モード**: オプションを使って、コマンド実行時にユーザー名やパスワードを入力せずにスーパーユーザーを作成できます。これは、自動テストやデプロイメントのスクリプトで非常に役立ちます。\n\n  ```bash\n  python manage.py createsuperuser --username=admin --email=admin@example.com --noinput\n  ```\n\n  このコマンドはパスワードを自動生成するため、別途`setpassword`コマンドでパスワードを設定する必要があります。\n\n- **権限設定**: `createsuperuser`で作成されるユーザーは、`is_staff`と`is_superuser`が`True`に設定されます。`is_staff`は管理インターフェースへのログイン権限を付与し、`is_superuser`はすべての権限を持つことを意味します。\n\n### 管理画面のカスタマイズ\nDjangoの管理インターフェースは非常に強力ですが、デフォルトのままだとシンプルすぎることがあります。`admin.py`ファイルを編集することで、管理画面の表示や機能をカスタマイズできます。これにより、データの視認性や操作性を向上させ、管理者にとってさらに使いやすいツールになります。\n\n1. **リスト表示のカスタマイズ**\n   モデルのリスト表示（一覧画面）をカスタマイズすることで、必要な情報を一目で確認できます。\n\n   - **`list_display`**: 一覧画面で表示したいフィールドを指定します。\n   - **`list_filter`**: サイドバーにフィルタリング機能を追加し、特定の値でデータを絞り込めるようにします。\n   - **`search_fields`**: 検索ボックスを追加し、指定したフィールドのテキストでデータを検索できるようにします。\n\n   - **例: BlogアプリのArticleモデルの管理画面をカスタマイズする例。**\n\n     ```python\n     from django.contrib import admin\n     from .models import Article\n\n     @admin.register(Article)\n     class ArticleAdmin(admin.ModelAdmin):\n         list_display = ('title', 'author', 'created_at', 'is_published')\n         list_filter = ('author', 'is_published', 'created_at')\n         search_fields = ('title', 'content')\n     ```\n\n   このコードでは、`Article`モデルの管理画面に「タイトル」「著者」「作成日」「公開状況」を一覧表示し、著者や公開状況などでデータをフィルタリングできるようにしています。\n\n2. **詳細画面のカスタマイズ**\n   モデルのデータ編集画面もカスタマイズできます。\n\n   - **`fields`**: 詳細画面で表示するフィールドの順序を指定します。\n   - **`readonly_fields`**: 編集不可のフィールドを指定します。\n   - **`fieldsets`**: フィールドをグループ化し、見出しを付けて整理します。\n\n   - **例: Articleモデルの詳細画面を整理する例。**\n\n     ```python\n     from django.contrib import admin\n     from .models import Article\n\n     @admin.register(Article)\n     class ArticleAdmin(admin.ModelAdmin):\n         fieldsets = (\n             (None, {\n                 'fields': ('title', 'author', 'content')\n             }),\n             ('公開設定', {\n                 'fields': ('is_published', 'published_at'),\n                 'classes': ('collapse',) # このグループを初期状態で非表示にする\n             })\n         )\n         readonly_fields = ('published_at',)\n     ```\n\n   この設定により、フィールドが論理的なグループに分けられ、ユーザーの操作がより直感的になります。\n\n### 管理画面のセキュリティ強化\n管理インターフェースは機密情報を含む可能性があるため、セキュリティを強化することが重要です。\n\n- **URLの変更**: デフォルトの`/admin/`というURLは攻撃者にとってわかりやすいため、`urls.py`で変更することをお勧めします。\n\n  ```python\n  # myproject/urls.py\n  from django.contrib import admin\n  from django.urls import path\n\n  urlpatterns = [\n      path('custom_admin_panel/', admin.site.urls), # URLを変更\n      # ... その他のURL\n  ]\n  ```\n\n- **HTTPSの強制**: 本番環境では、管理画面へのアクセスは必ずHTTPS経由で行うように設定します。これにより、パスワードなどの情報が暗号化され、通信の盗聴を防げます。\n\n- **強固なパスワードポリシー**: `createsuperuser`コマンドでパスワードを作成する際に、より複雑なパスワードを要求するよう設定できます。これは、`settings.py`の`AUTH_PASSWORD_VALIDATORS`で設定します。\n\nこれらのカスタマイズやセキュリティ対策を行うことで、Djangoの管理インターフェースをより強力で安全なツールとして活用できます。","src/content/docs/Djangoガイド/04_上級・最適化/06_admin_interface.mdx","ede5be3d28fc8ac5","djangoガイド/04_上級最適化/パフォーマンスチューニング",{"id":325,"data":327,"body":332,"filePath":333,"digest":334,"deferredRender":16},{"title":328,"editUrl":16,"head":329,"template":18,"sidebar":330,"pagefind":16,"draft":20},"パフォーマンスチューニング",[],{"hidden":20,"attrs":331},{},"## パフォーマンスチューニング\nDjangoアプリケーションのパフォーマンスを最適化するための方法を、絵文字を使って親しみやすく解説します。\n\n### 1. データベースの最適化 📊\nデータベースは、パフォーマンスのボトルネックになりがちです。\n\n- **インデックスの活用 🔍**: `db_index=True`を設定すると、検索が速くなります。これは、よく検索するフィールドに設定することで、クエリ速度を劇的に向上させます。\n\n- **N+1クエリ問題の解決 🐢➡️🚀**: 関連データを取得するたびに何度もデータベースにアクセスしてしまう「N+1クエリ問題」は、アプリケーションを遅くします。\n  - `select_related()` は、JOINを使って関連データを1回のクエリでまとめて取得します。\n  - `prefetch_related()` は、複数のクエリを使い、Pythonのメモリ内で関連付けを行います。\n\n```python\nfrom django.db import models\n\nclass MyModel(models.Model):\n    # 頻繁に検索されるフィールドにインデックスを設定\n    name = models.CharField(max_length=100, db_index=True)\n```\n\n```python\n# 通常のアクセス（N+1クエリが発生）\nbooks = Book.objects.all()\nfor book in books:\n    print(book.author.name) # ループごとにクエリが発生\n\n# select_relatedを使用（単一のJOINクエリに最適化）\nbooks = Book.objects.select_related('author').all()\nfor book in books:\n    print(book.author.name) # 追加クエリなし\n```\n\n### 2. キャッシュの活用 💾\n頻繁にアクセスされるデータを一時的に保存し、データベースへのアクセスを減らします。\n\n- **フレームワークレベルのキャッシュ 🖼️**: ビューやテンプレートの出力をキャッシュできます。`@cache_page`デコレータを使えば、簡単に実装できます。\n\n- **ORMレベルのキャッシュ 🧠**: `django-cachalot`のようなライブラリを使うと、同じクエリが再実行されるのを防ぎ、処理を高速化します。\n\n```python\n# settings.py\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django.core.cache.backends.locmem.LocMemCache\",\n        \"LOCATION\": \"unique-snowflake\",\n    }\n}\n\n# myapp/views.py\nfrom django.views.decorators.cache import cache_page\nfrom django.shortcuts import render\n\n@cache_page(60 * 15) # 15分間キャッシュ\ndef my_view(request):\n    return render(request, 'my_template.html', {'data': 'Some expensive data'})\n```\n\n### 3. 非同期処理とタスクキュー 📧\n時間のかかる処理（メール送信や画像リサイズなど）をバックグラウンドに回し、ユーザーを待たせないようにします。\n\n- **Celery**は、これらのタスクを非同期に実行するのに役立ちます。これにより、アプリの応答性が向上し、ユーザー体験がスムーズになります。\n\n```python\n# tasks.py (Celeryタスクの定義)\nfrom celery import shared_task\nfrom django.core.mail import send_mail\n\n@shared_task\ndef send_welcome_email(user_email):\n    send_mail(\n        'Welcome to MySite',\n        'Thank you for signing up!',\n        'from@example.com',\n        [user_email],\n        fail_silently=False,\n    )\n\n# views.py (タスクを呼び出す)\nfrom .tasks import send_welcome_email\n\ndef user_signup(request):\n    ...\n    user = User.objects.create(...)\n    send_welcome_email.delay(user.email) # タスクを非同期で実行\n    return redirect('success')\n```\n\n### 4. 静的ファイルとメディアファイルの最適化 🌐\nファイルのロード時間を短縮することで、ウェブサイトをより速く感じさせます。\n\n- **静的ファイル (CSS, JSなど)** は`collectstatic`で一元管理し、CDNを通じて配信することで、世界中のどこからでも高速にアクセスできます。\n\n- **メディアファイル (画像や動画)** は、Amazon S3のようなクラウドストレージに保存し、サーバーの負担を軽減します。\n\n```python\n# settings.py\nSTATIC_ROOT = '/var/www/myproject/static/'\nSTATIC_URL = 'https://cdn.example.com/static/' # CDNのURL\nMEDIA_ROOT = '/var/www/myproject/media/'\nMEDIA_URL = 'https://s3.amazonaws.com/myproject-media/' # クラウドストレージのURL\n```\n\n### 5. QuerySetの最適化 📈\nQuerySetを賢く使うことで、データベースへの不要なアクセスを減らします。\n\n- **`values()` と `values_list()`**: モデルインスタンス全体ではなく、必要なフィールドの値だけを取得します。\n\n- **`only()` と `defer()`**: フィールドを部分的にロードすることで、メモリ使用量を抑えます。\n\n- **`count()` vs `len()`**: 要素数を数えるだけなら、`count()`メソッドを使います。Pythonの`len()`を使うと、クエリセット全体がロードされてしまうので注意が必要です。\n\n```python\n# values() と values_list() の例\n# 特定のフィールドの値だけを取得\ntitles_and_authors = Book.objects.values('title', 'author__name')\n# 単一のフィールドのリストとして取得\ntitles = Book.objects.values_list('title', flat=True)\n\n# only() と defer() の例\n# titleとcontentだけをロード\narticles = Article.objects.only('title', 'content')\n# contentフィールドを遅延ロード\narticles_without_content = Article.objects.defer('content')\n\n# count() vs len() の例\nqueryset = Article.objects.all()\n# 高速なデータベースCOUNT\narticle_count = queryset.count()\n# 全データをロードしてからPythonでカウント\n# article_count = len(queryset) # 非推奨\n```\n\n### 6. テンプレートの最適化 🖌️\nテンプレートのレンダリングを高速化します。\n\n- **`cached_template_loader`**: テンプレートをメモリにキャッシュし、読み込みを高速化します。\n\n- **`with`タグの活用**: テンプレート内で複雑なロジックをキャッシュして再利用します。\n\n### 7. HTTPレベルでの最適化 📦\nアプリケーションの外側でもパフォーマンスは改善できます。\n\n- **HTTP圧縮（Gzip/Brotli）**: ファイルサイズを小さくして、ロード時間を短縮します。\n\n- **CDN (Content Delivery Network)**: ファイルをユーザーの近くのサーバーから配信し、遅延を最小限に抑えます。\n\n### 8. WSGIサーバーの設定 ⚙️\n本番環境では、開発サーバーは使えません。GunicornやuWSGIのようなWSGIサーバーを正しく設定することが不可欠です。\n\n- ワーカープロセスの数やタイムアウト設定を最適化し、サーバーの処理能力を最大限に引き出します。\n\n### 9. データベース接続の持続化 🔗\nリクエストごとにデータベース接続を確立・切断するオーバーヘッドをなくします。\n\n- **`CONN_MAX_AGE`** を設定することで、接続を再利用し、レイテンシを減少させます。\n\n```python\n# settings.py\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        # その他の設定...\n        'CONN_MAX_AGE': 600,  # 600秒間（10分間）接続を再利用\n    }\n}\n```\n\n### 10. プロファイリングとモニタリング 🔬\nどこが遅いのかを正確に把握することが、パフォーマンス改善の第一歩です。\n\n- **`django-silk` や `cProfile`** などのツールを使って、コードのボトルネックを特定し、データに基づいた最適化を行います。","src/content/docs/Djangoガイド/04_上級・最適化/パフォーマンスチューニング.mdx","90c5ae12aef9b890","elixirガイド/01_はじめに/elixirとは",{"id":335,"data":337,"body":342,"filePath":343,"digest":344,"deferredRender":16},{"title":338,"editUrl":16,"head":339,"template":18,"sidebar":340,"pagefind":16,"draft":20},"Elixir とは？",[],{"hidden":20,"attrs":341},{},"# Elixir とは？\n\nElixir は、関数型、動的型付けのプログラミング言語で、スケーラブルで保守性に優れたアプリケーションを構築するために設計されています。Ruby に似た分かりやすい構文を持ちながら、並行処理と分散システムに非常に優れているのが特徴です。\n\n## 1. Elixir の特徴\n\n- **関数型:** Elixir は関数型のパラダイムを採用しており、データの不変性（イミュータブル）を重視します。これにより、予期せぬ副作用（side effect）を防ぎ、コードの予測可能性を高めます。パイプ演算子（|>）を使うことで、関数の連鎖を直感的に記述できるのが特徴です。\n\n- **並行処理:** アクターモデルという考え方に基づいています。これは、軽量なプロセスを多数生成し、メッセージをやり取りすることで並行処理を実現するものです。これにより、リソースを効率的に利用し、高負荷なアプリケーションでも高いパフォーマンスを維持できます。\n\n- **フォールトトレランス:** Elixir が動作する Erlang VM (BEAM) には、障害が発生したプロセスを自動的に再起動する**監視ツリー（Supervision Tree）**という機能が組み込まれています。これにより、アプリケーション全体が停止することなく、高い可用性を実現します。\n\n- **Ruby に似た構文:** Ruby から大きな影響を受けており、直感的で読みやすい構文が特徴です。Ruby 開発者にとっては学習コストが低く、スムーズに Elixir の世界に入ることができます。\n\n## 2. Elixir の利用シーン\n\nElixir は、特に以下の分野で強みを発揮します。\n\n- **リアルタイム通信:** チャットアプリケーションや IoT デバイスなど、多数の同時接続を処理する必要がある場合に最適です。Phoenix フレームワークの Phoenix Channels は、リアルタイム通信を簡単に実装するための強力なツールです。\n\n- **ウェブ開発:** Phoenix という、高速で機能豊富なウェブフレームワークが存在します。リアルタイム通信機能だけでなく、HTML の差分のみを送信して高速な UI を実現する LiveView といった画期的な機能も提供しています。\n\n- **分散システム:** 複数のサーバーにわたって処理を分散させる必要があるシステム（マイクロサービスなど）の構築に適しています。Erlang VM の強力な分散機能により、ノード間の通信や状態の共有を容易に行うことができます。\n\n## 3. Elixir のエコシステム\n\nElixir のエコシステムは非常に活発で、多くの便利なツールやライブラリが提供されています。\n\n- **Mix:** Elixir プロジェクトの標準的なビルドツール、タスクランナー、依存関係管理ツールです。新しいプロジェクトの作成、テストの実行、パッケージのインストールなど、あらゆる開発タスクを mix コマンド一つで実行できます。\n\n- **Phoenix:** 「ウェブ開発」セクションで言及した通り、高速で機能豊富なウェブフレームワークです。Rails のような MVC アーキテクチャをベースとしながら、リアルタイムな機能を標準でサポートしています。\n\n- **Hex:** Elixir と Erlang のための公式パッケージマネージャーです。Ruby の RubyGems や Node.js の npm のような役割を担い、豊富なライブラリを簡単にプロジェクトに追加できます。\n\n## 4. Elixir の学び方\n\n- **公式ドキュメント:** Elixir 公式サイトのドキュメントは非常に充実しており、初心者から上級者まで役立つ情報が揃っています。\n\n- **オンラインリソース:** Elixir School や Phoenix Framework の公式サイトには、チュートリアルやガイドが豊富に用意されています。\n\nこれらのツールと Elixir の強力な機能を組み合わせることで、開発者は堅牢でスケーラブルなアプリケーションを迅速に構築できます。","src/content/docs/elixirガイド/01_はじめに/elixirとは.mdx","89b3e8aed266241f","elixirガイド/01_はじめに/インストール",{"id":345,"data":347,"body":352,"filePath":353,"digest":354,"deferredRender":16},{"title":348,"editUrl":16,"head":349,"template":18,"sidebar":350,"pagefind":16,"draft":20},"Elixir のインストール",[],{"hidden":20,"attrs":351},{},"# Elixir のインストール\n\nElixir をインストールするには、まず Elixir が依存している Erlang/OTP をインストールする必要があります。Elixir は Erlang VM（仮想マシン）上で動作するため、Erlang が必須となります。\n\n## 必要なツール\n\n- **Erlang/OTP:** Elixir が動作するための基盤となる仮想マシンです。\n- **Elixir:** プログラミング言語本体です。\n\n## インストール手順（macOS の場合）\n\nmacOS の場合、パッケージマネージャーの Homebrew を使うのが最も簡単で推奨される方法です。\n\n### Homebrew のインストール\n\nまだ Homebrew をインストールしていない場合は、以下のコマンドをターミナルで実行してインストールしてください。\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n### Erlang と Elixir のインストール\n\nHomebrew を使って Erlang と Elixir を一度にインストールできます。\n\n```bash\nbrew install elixir\n```\n\nこのコマンドは、Elixir が依存している Erlang も自動的にインストールしてくれます。\n\n## インストール手順（その他の OS の場合）\n\n### Windows\n\n- **Chocolatey を利用:** Chocolatey をインストール後、`choco install erlang elixir` でインストールできます。\n- **公式インストーラーを利用:** Elixir 公式サイトからインストーラーをダウンロードしてインストールします。\n\n### Linux (Ubuntu/Debian)\n\n公式リポジトリからインストールできます。\n\n```bash\nsudo apt-get update\nsudo apt-get install erlang elixir\n```\n\n## インストールの確認\n\nインストールが完了したら、以下のコマンドをターミナルで実行して、バージョン情報が表示されるか確認しましょう。\n\n```bash\nelixir --version\n```\n\nバージョン情報が正しく表示されれば、インストールは完了です。これで Elixir を使った開発を始める準備ができました。","src/content/docs/elixirガイド/01_はじめに/インストール.mdx","5512440a7411e029","elixirガイド/01_はじめに/基本概念",{"id":355,"data":357,"body":362,"filePath":363,"digest":364,"deferredRender":16},{"title":358,"editUrl":16,"head":359,"template":18,"sidebar":360,"pagefind":16,"draft":20},"基本概念",[],{"hidden":20,"attrs":361},{},"# 基本概念\n\nElixir は、Ruby に似た直感的な構文と、並行処理に特化した強力な機能を併せ持つプログラミング言語です。ここでは、Elixir の開発を始めるにあたって知っておきたい基本的な概念を解説します。\n\n## 1. データ型\n\nElixir のデータ型は、一般的なプログラミング言語と似ていますが、いくつかの独自の特徴があります。\n\n### 数値\n\n整数と浮動小数点数があります。`1_000_000` のようにアンダースコアを使って読みやすく記述できます。\n\n### 文字列\n\nダブルクォーテーション `\"\"` で囲みます。UTF-8 がデフォルトで、日本語も問題なく扱えます。文字列の連結には `\u003C>` 演算子を使います。\n\n```elixir\n\"hello\" \u003C> \" world\" # => \"hello world\"\n```\n\n### アトム\n\n名前がその値そのものとなる定数のようなデータ型です。コロン `:` から始まります。パターンマッチングや一意な識別子としてよく使われます。\n\n```elixir\n:ok\n:error\n```\n\n### リスト\n\n順序付けられた値の集合で、角括弧 `[]` で囲みます。異なるデータ型を混在させることができます。\n\n```elixir\n[1, 2, \"three\", :four]\n```\n\n### タプル\n\n順序付けられた値の集合で、波括弧 `{}` で囲みます。タプルは要素数が多いとパフォーマンスが低下するため、一般的に少数の要素を扱う際に使われます。\n\n```elixir\n{:ok, \"success\"}\n```\n\n### マップ\n\nキーと値のペアを格納するデータ型です。波括弧 `%{}` を使って記述します。JavaScript のオブジェクトや Python の辞書に相当します。\n\n```elixir\n%{\"name\" => \"Alice\", \"age\" => 30}\n```\n\n## 2. 基本構文\n\nElixir の構文は非常に簡潔で、読みやすさを重視しています。\n\n### 関数の定義\n\ndef キーワードを使って関数を定義します。\n\n```elixir\ndef add(a, b) do\n  a + b\nend\n```\n\n### モジュール\n\n関数はすべてモジュールに属します。関連する関数を一つのモジュールにまとめることで、コードを整理できます。\n\n```elixir\ndefmodule Math do\n  def add(a, b) do\n    a + b\n  end\nend\n```\n\n定義した関数は `モジュール名.関数名` の形式で呼び出します。\n\n```elixir\nMath.add(1, 2) # => 3\n```\n\n### パイプ演算子 `|>`\n\n前の関数の結果を、次の関数の第一引数に渡すための演算子です。複数の関数をチェーンでつなぎ、データの流れを直感的に記述できます。\n\n```elixir\n\"hello\"\n|> String.upcase()\n|> String.length()\n# => 5\n```\n\n### パターンマッチング\n\nElixir の最も重要な特徴の一つです。`=` 演算子は、代入ではなく「パターンマッチング」を意味します。左辺のパターンが右辺の値と一致するかどうかを評価します。\n\n```elixir\n[a, b, 3] = [1, 2, 3] # => aは1, bは2にマッチ\n```\n\nこれらの基本的な概念を理解することで、Elixir の開発をスムーズに始めることができます。","src/content/docs/elixirガイド/01_はじめに/基本概念.mdx","bbcdf3e46a4a2544","elixirガイド/03_中級/06_deployment",{"id":365,"data":367,"body":372,"filePath":373,"digest":374,"deferredRender":16},{"title":368,"editUrl":16,"head":369,"template":18,"sidebar":370,"pagefind":16,"draft":20},"デプロイメントの詳細",[],{"hidden":20,"attrs":371},{},"Elixirアプリケーションのデプロイメント方法をさらに詳しく解説します。\n\n## Kubernetesを使用したデプロイメント\n\nKubernetesを使用して、Elixirアプリケーションをデプロイします。Kubernetesは、コンテナ化されたアプリケーションのデプロイ、スケーリング、管理を行うためのオープンソースプラットフォームです。\n\n### デプロイメントの設定\n\n以下に、Kubernetesでのデプロイメント設定の例を示します。\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      containers:\n      - name: myapp\n        image: myapp:latest\n        ports:\n        - containerPort: 4000\n```\n\n- **`replicas: 3`**: アプリケーションのインスタンスを3つ作成します。\n- **`image: myapp:latest`**: 使用するDockerイメージを指定します。\n\n### 使用例\n\nこの設定により、Kubernetesは3つのインスタンスを作成し、負荷分散を行います。これにより、アプリケーションの可用性とスケーラビリティが向上します。\n\n## 高度なデプロイメント\n\nElixirアプリケーションのデプロイメントを自動化するために、CI/CDパイプラインを構築します。以下に、GitHub Actionsを使用したCI/CDパイプラインの例を示します。\n\n```yaml\nname: Elixir CI\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Elixir\n      uses: actions/setup-elixir@v1\n      with:\n        elixir-version: '1.11'\n    - name: Install dependencies\n      run: mix deps.get\n    - name: Run tests\n      run: mix test\n    - name: Build release\n      run: mix release\n```\n\n- **`GitHub Actions`**: CI/CDパイプラインを構築して、デプロイメントを自動化します。\n\n### 使用例\n\nこの設定により、コードがプッシュされるたびに自動的にテストが実行され、リリースがビルドされます。CI/CDパイプラインを使用することで、デプロイメントプロセスを効率化し、エラーを減らすことができます。","src/content/docs/elixirガイド/03_中級/06_deployment.mdx","5dd285d146837dff","elixirガイド/03_中級/05_testing",{"id":375,"data":377,"body":382,"filePath":383,"digest":384,"deferredRender":16},{"title":378,"editUrl":16,"head":379,"template":18,"sidebar":380,"pagefind":16,"draft":20},"テストの実装方法の詳細",[],{"hidden":20,"attrs":381},{},"Elixirでのテストの実装方法をさらに詳しく解説します。\n\n## Mockingを使用したテスト\n\nElixirでは、Mockingを使用して依存関係を模擬することができます。これにより、外部サービスやデータベースに依存せずに、ユニットテストを実行することができます。\n\n以下に、Mockingを使用したテストの例を示します。\n\n```elixir\ndefmodule MyApp.MyModuleTest do\n  use ExUnit.Case, async: true\n  import Mox\n\n  setup :verify_on_exit!\n\n  test \"example test\" do\n    MyApp.MyModule.Mock\n    |> expect(:my_function, fn -> :ok end)\n\n    assert MyApp.MyModule.my_function() == :ok\n  end\nend\n```\n\n- **`use ExUnit.Case, async: true`**: 非同期でテストを実行します。\n- **`import Mox`**: Moxライブラリをインポートして、Mockingをサポートします。\n- **`setup :verify_on_exit!`**: テスト終了時にMockの期待を検証します。\n\n### 使用例\n\nこのテストでは、`MyApp.MyModule.my_function/0`が`:ok`を返すことを期待しています。Mockingを使用することで、テストの信頼性を高め、外部依存を排除することができます。","src/content/docs/elixirガイド/03_中級/05_testing.mdx","f64b0d96aa1c4ce5","elixirガイド/03_中級/api利用法",{"id":385,"data":387,"body":392,"filePath":393,"digest":394,"deferredRender":16},{"title":388,"editUrl":16,"head":389,"template":18,"sidebar":390,"pagefind":16,"draft":20},"API利用法",[],{"hidden":20,"attrs":391},{},"## ElixirでのAPIプロジェクトの作成\n\nElixirのPhoenixフレームワークを使用して、API専用のプロジェクトを作成する方法を紹介します。以下の手順で、データベースを使用する場合と使用しない場合のプロジェクトを作成できます。\n\n### データベースありのAPIモード\n\nデータベースに接続してデータの永続化を伴うAPIを作成する場合、PhoenixプロジェクトはEctoをデフォルトで含みます。\n\n1. **プロジェクトの作成**\n   - コマンド: `mix phx.new my_api --no-html --no-webpack`\n   - 説明: HTMLやフロントエンドのビルドツールを含めず、バックエンドAPIに特化した構造を作成します。EctoとPostgreSQLへの接続設定も含まれます。\n\n2. **リソースの生成とデータベース操作**\n   - `mix ecto.create`: config/dev.exsの設定に基づいて、データベースを作成します。\n   - `mix phx.gen.json Accounts User users name:string`: APIエンドポイントの作成を自動化します。Accountsというコンテキスト、Userというモデル、およびusersテーブルのマイグレーションファイルを生成します。\n   - `mix ecto.migrate`: データベースマイグレーションを実行し、usersテーブルを作成します。\n\n#### フォルダ構成（データベースあり）\n```\nmy_api/\n├── config/\n├── lib/\n│   ├── my_api/\n│   │   ├── accounts/\n│   │   │   ├── user.ex      # Userモデル\n│   │   │   └── accounts.ex  # コンテキストモジュール\n│   │   └── repo.ex          # データベースリポジトリ\n│   └── my_api_web/\n│       ├── controllers/\n│       │   └── user_controller.ex # APIコントローラー\n│       └── router.ex          # ルーター\n├── priv/\n│   └── repo/\n│       └── migrations/        # マイグレーションファイル\n└── ...\n```\n\n### データベースなしのAPIモード\n\nデータベースを使用しない、純粋なAPI（例：外部APIのプロキシやインメモリデータのみを扱う場合）を作成するには、プロジェクト生成時に--no-ectoフラグを追加します。\n\n1. **プロジェクトの作成**\n   - コマンド: `mix phx.new my_api --no-html --no-webpack --no-ecto`\n   - 説明: Ecto関連の依存関係や設定ファイルを一切含みません。\n\n2. **APIエンドポイントの手動作成**\n   - `lib/my_api_web/controllers/api_controller.ex`: APIエンドポイントのロジックを記述します。\n   - `lib/my_api_web/router.ex`: そのコントローラーへのルーティングを設定します。\n\n#### フォルダ構成（データベースなし）\n```\nmy_api/\n├── config/\n├── lib/\n│   └── my_api_web/\n│       ├── controllers/\n│       │   └── api_controller.ex  # 手動で作成したコントローラー\n│       └── router.ex            # ルーター\n├── priv/\n└── ...\n```\n\n### 比較と使い分け\n\n| 特徴 | データベースありAPIモード | データベースなしAPIモード |\n|------|--------------------------|--------------------------|\n| 主な用途 | データの永続化が必要なAPI（例：ユーザー管理、ブログ投稿） | データベースを必要としないAPI（例：外部APIのプロキシ、計算サービス） |\n| プロジェクト作成 | `mix phx.new --no-html --no-webpack` | `mix phx.new --no-html --no-webpack --no-ecto` |\n| データ永続化 | ✅ Ectoによるデータベース接続 | ❌ データベース接続なし |\n| リソース作成 | ✅ phx.gen.jsonジェネレーターが利用可能 | ❌ ジェネレーターは利用不可、手動で作成 |\n| 利点 | 複雑なデータモデルを効率的に管理できる | 不要な依存関係がなく、軽量でシンプル |\n| 考慮点 | 開発環境のセットアップ（Postgresなど）が必要 | すべてのAPIエンドポイントを手動で定義する必要がある |\n\nどちらのモードを選択するかは、APIの目的によって決まります。データの読み書きが必要な場合はデータベースあり、外部サービスとの連携や単純な処理に特化する場合はデータベースなしが適しています。","src/content/docs/elixirガイド/03_中級/API利用法.mdx","f44ffd4bc6875364","elixirガイド/02_基本/02_basic_syntax",{"id":395,"data":397,"body":402,"filePath":403,"digest":404,"deferredRender":16},{"title":398,"editUrl":16,"head":399,"template":18,"sidebar":400,"pagefind":16,"draft":20},"Elixirの基本構文",[],{"hidden":20,"attrs":401},{},"# Elixirの基本構文\n\nElixirの基本的な構文を以下に示します。\n\n## データ型\n\nElixirには、以下のような基本的なデータ型があります。これらのデータ型は、プログラム内でさまざまなデータを表現するために使用されます。\n\n- **整数**: `1`, `42` - 整数は、数値を表すために使用されます。\n- **浮動小数点数**: `3.14`, `-0.5` - 浮動小数点数は、小数点を含む数値を表すために使用されます。\n- **文字列**: `\"Hello, Elixir!\"` - 文字列は、テキストデータを表すために使用されます。\n- **アトム**: `:ok`, `:error` - アトムは、名前付き定数を表すために使用されます。\n- **リスト**: `[1, 2, 3]` - リストは、順序付きのコレクションを表すために使用されます。\n- **タプル**: `{:ok, \"Success\"}` - タプルは、固定長のコレクションを表すために使用されます。\n\n### 使用例\n\n以下に、各データ型の使用例を示します。\n\n```elixir\n# 整数の使用例\nnumber = 42\nIO.puts(\"Number: #{number}\")\n\n# 文字列の使用例\nmessage = \"Hello, Elixir!\"\nIO.puts(message)\n\n# アトムの使用例\nstatus = :ok\nIO.puts(\"Status: #{status}\")\n```\n\nこれらのデータ型を使用することで、Elixirプログラム内でさまざまなデータを効果的に管理できます。\n\n## 関数\n\nElixirでは、関数はファーストクラスの市民であり、変数に代入したり、他の関数に渡したりすることができます。\n\n```elixir\ndefmodule Math do\n  def add(a, b) do\n    a + b\n  end\nend\n\nIO.puts(Math.add(1, 2))\n```\n\n## モジュール\n\nElixirでは、モジュールを使用して、関連する関数をグループ化します。\n\n```elixir\ndefmodule Greeter do\n  def hello(name) do\n    \"Hello, #{name}!\"\n  end\nend\n\nIO.puts(Greeter.hello(\"World\"))\n```\n\n## パターンマッチング\n\nElixirの強力な機能の一つにパターンマッチングがあります。これにより、データの構造を簡単に分解できます。\n\n```elixir\n{status, result} = {:ok, 42}\nIO.puts(result) # 42\n```\n\n## 高度なパターンマッチング\n\nElixirのパターンマッチングは、データの構造を簡単に分解するための強力な機能です。以下に、ガード節を使用した条件付きマッチングの例を示します。\n\n```elixir\n# ガード節を使用したパターンマッチング\ncase {1, 2, 3} do\n  {1, x, 3} when x > 0 ->\n    IO.puts(\"x is positive\")\n  _ ->\n    IO.puts(\"No match\")\nend\n```\n\n- **`when`**: ガード節を使用して、パターンマッチングに条件を追加します。\n\n### 使用例\n\nこの例では、タプルの2番目の要素が正の数である場合にのみマッチします。ガード節を使用することで、より柔軟なパターンマッチングが可能になります。\n\n## 並行処理\n\nElixirは、並行処理を簡単に行うための機能を提供しています。\n\n```elixir\nspawn(fn -> IO.puts(\"Hello from another process!\") end)\n```","src/content/docs/elixirガイド/02_基本/02_basic_syntax.mdx","488c01517d82de77","elixirガイド/02_基本/フォルダ構成",{"id":405,"data":407,"body":412,"filePath":413,"digest":414,"deferredRender":16},{"title":408,"editUrl":16,"head":409,"template":18,"sidebar":410,"pagefind":16,"draft":20},"フォルダ構成",[],{"hidden":20,"attrs":411},{},"## 📁 Elixir プロジェクトの標準的なフォルダ構成\n\nElixirでは、`mix new` コマンドを使ってプロジェクトを標準化します。これにより、開発者が共通の理解を持って作業できる、一貫したディレクトリ構造が生成されます。\n\n### 階層構造の概要と役割\n\n```\nmy-app/\n├── .formatter.exs      # コードフォーマット設定\n├── .gitignore          # Gitの除外ファイル\n├── config/             # 環境ごとの設定ファイル\n│   ├── config.exs      # 全環境共通のデフォルト設定\n│   └── prod.exs        # 本番環境固有の設定\n├── lib/                # アプリケーションのコアとなるソースコード\n│   └── my_app/\n│       ├── application.ex # アプリケーション起動とスーパーバイザーツリー\n│       ├── supervisor.ex  # プロセスを監視・再起動するSupervisor\n│       └── my_app.ex      # アプリケーションの主要モジュール\n├── priv/               # プライベートなアセット（マイグレーションなど）\n├── test/               # テストコード\n│   ├── my_app_test.exs    # アプリケーションのテスト\n│   └── test_helper.exs    # テスト環境のセットアップ\n└── mix.exs             # プロジェクトの設定ファイル（依存関係、タスクなど）\n```\n\nこの構造に慣れることで、新しいプロジェクトでもすぐに適応でき、効率的な開発が可能です。\n\n## 🌐 Plug: Phoenixのミドルウェア\n\nElixirのWebフレームワークであるPhoenixは、Plugというライブラリを使用してミドルウェアを実装します。Plugは、リクエストが最終的なコントローラーに到達する前に、共通の処理（認証、ロギングなど）を実行するための仕様です。\n\n### Plugの実装例：認証ミドルウェア 🛡️\n\nPlugモジュールは、`init/1`と`call/2`の2つの関数を実装する必要があります。\n\n```elixir\ndefmodule YourApp.AuthPlug do\n  import Plug.Conn\n\n  def init(opts), do: opts\n\n  def call(conn, _opts) do\n    # リクエストヘッダーから認証トークンを取得\n    case get_req_header(conn, \"authorization\") do\n      [token] when token == \"my_secret_token\" ->\n        # 認証成功、connにユーザー情報を追加\n        assign(conn, :current_user, %{id: 1, name: \"Alice\"})\n      _ ->\n        # 認証失敗、401レスポンスを返し、パイプラインを中断\n        conn |> send_resp(401, \"Unauthorized\") |> halt()\n    end\n  end\nend\n```\n\nルーターのパイプラインにこのミドルウェアを組み込むことで、特定のルートに共通の処理を適用できます。\n\n```elixir\ndefmodule YourApp.Router do\n  use Phoenix.Router\n\n  pipeline :api do\n    plug :accepts, [\"json\"]\n    plug YourApp.AuthPlug # 認証ミドルウェアを追加\n  end\n\n  scope \"/api\", YourApp.Web do\n    pipe_through :api\n    get \"/profile\", ProfileController, :show\n  end\nend\n```\n\n## 🧠 Elixirのコアコンセプトとデザインパターン\n\nElixirは、オブジェクト指向ではなく、Erlang VM (BEAM)の並行処理と耐障害性を最大限に活用した独自の**OTP（Open Telecom Platform）**デザインパターンを持っています。\n\n### 1. GenServer (ジェンサーバー)\n\nクライアント・サーバーモデルを実装するためのビヘイビアです。単一のプロセスで安全に状態を管理し、他のプロセスからのメッセージを処理します。キャッシュや外部リソースの接続プールなどで使用されます。\n\n**イメージ:** メッセージを待つ「受付係」。\n\n### 2. Supervisor (スーパーバイザー)\n\n「Let it crash」（クラッシュさせろ）の哲学に基づき、子プロセスを監視し、エラー発生時に自動的に再起動します。これにより、アプリケーション全体が停止することなく、高い回復能力を持つシステムを構築できます。\n\n**イメージ:** 従業員（プロセス）を監督する「上司」。\n\n### 3. Registry (レジストリ)\n\nプロセスをキーで登録し、そのプロセスIDを効率的に検索する機能です。分散環境で動的に生成されるプロセスを管理する際に便利です。\n\n**イメージ:** プロセスと名前を結びつける「電話帳」。\n\n## 🎨 BEAMとPhoenixのアーキテクチャ\n\n### BEAMのアーキテクチャとプロセス間通信\n\nElixirの強力な機能の秘密は、Erlangの仮想マシンであるBEAMにあります。BEAMは軽量なプロセスを多数作成し、これらはメモリを共有せずメッセージパッシングで通信します。これにより、1つのプロセスがクラッシュしても他のプロセスに影響を与えません。\n\n### Phoenixの全体像\n\nPhoenixは、Plugを中心としたパイプラインモデルを採用しています。リクエストは一連のミドルウェアを通過し、コントローラーに渡されます。この構造により、リクエスト処理のロジックが明確に分離され、コードの可読性が向上します。\n\n### その他の重要なコンセプト\n\n- **パターンマッチング**: 関数の引数やデータ構造が特定のパターンに一致するかどうかを評価する機能。\n\n- **パイプ演算子 (|>)**: 前の関数の結果を次の関数の最初の引数として渡すことで、関数呼び出しをチェーンでつなぎ、データフローを直感的に表現します。\n\nこれらの機能が組み合わさることで、Elixirは複雑な問題をシンプルかつ堅牢に解決できる、強力なツールとなっています。🚀","src/content/docs/elixirガイド/02_基本/フォルダ構成.mdx","563abff7ae52ef23","elixirガイド/04_上級最適化/パフォーマンスチューニング",{"id":415,"data":417,"body":421,"filePath":422,"digest":423,"deferredRender":16},{"title":328,"editUrl":16,"head":418,"template":18,"sidebar":419,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":420},{},"## Elixir パフォーマンスチューニング：主要な手法\n\nElixirは並行処理と耐障害性に優れていますが、最高のパフォーマンスを引き出すには、特定のチューニング手法を理解し、適切に適用することが重要です。\n\n### 1. キャッシュの活用：ETSとGenServer\n\nElixirでキャッシュを実装する最も一般的な方法は、ETS (Erlang Term Storage) を使うことです。ETSはBEAMに組み込まれた超高速なインメモリデータベースです。\n\n- **GenServerとの組み合わせ**: 複数のプロセスからのアクセスを安全に制御するため、ETSテーブルをGenServerでラップします。これにより、一貫性と並行性を保ちながらキャッシュを管理できます。\n\n#### ETSキャッシュをGenServerでラップする例\n\n```elixir\ndefmodule CacheServer do\n  use GenServer\n\n  # クライアントAPI\n  def start_link(_opts), do: GenServer.start_link(__MODULE__, :ok, name: :my_cache)\n  def put(key, value), do: GenServer.call(:my_cache, {:put, key, value})\n  def get(key), do: GenServer.call(:my_cache, {:get, key})\n\n  # GenServerコールバック\n  def init(:ok) do\n    :ets.new(:my_cache_table, [:set, :public, :named_table])\n    {:ok, %{}}\n  end\n\n  def handle_call({:put, key, value}, _from, state) do\n    :ets.insert(:my_cache_table, {key, value})\n    {:reply, :ok, state}\n  end\n\n  def handle_call({:get, key}, _from, state) do\n    case :ets.lookup(:my_cache_table, key) do\n      [{^key, value}] -> {:reply, value, state}\n      [] -> {:reply, nil, state}\n    end\n  end\nend\n```\n\n### 2. プロファイリングとボトルネックの特定\n\nパフォーマンスの問題を解決するには、まずボトルネックを正確に特定することが不可欠です。\n\n- **:eprof**: 関数のCPU時間を測定するプロファイラです。\n- **mix profile.fprof**: より詳細な呼び出しグラフ分析を提供します。\n- **recon**: プロセスごとのメモリ使用量やスケジューラの動作をリアルタイムで監視するツールセットです。\n\n#### プロファイリングの使用例\n\n```elixir\n# IEx (Interactive Elixir) セッションで実行\n:eprof.start_profiling()\n:eprof.profile(fn ->\n  # プロファイルしたいコード\n  YourApp.some_expensive_function()\nend)\n:eprof.analyze()\n```\n\n### 3. その他の重要なパフォーマンスチューニング手法\n\n- **I/Oの管理：非同期I/Oと接続プール**:\n  - **非同期I/O**: データベースや外部APIへのアクセスなど、I/Oバウンドな操作では、Task モジュールを使って非同期に実行することで、メインプロセスをブロックせずに済みます。\n  - **DB接続プール**: DBConnectionなどのライブラリを使い、データベース接続をプールすることで、接続の確立にかかるオーバーヘッドを削減し、スループットを向上させます。\n\n- **コード構造：Enum vs Stream**:\n  - **Enum**: コレクション全体を一度に処理します。小さなデータセットに適しています。\n  - **Stream**: 遅延評価（Lazy Evaluation）を行います。操作を必要になるまで実行しないため、大規模なデータセットを扱う際にメモリ消費を抑えられます。\n\n- **JITコンパイラとコンパイル時の最適化**:\n  - Erlang/OTP 24以降に導入されたJITコンパイラは、頻繁に実行されるコードをネイティブコードに変換し、パフォーマンスを向上させます。\n  - **dialyzer**: 静的コード分析ツール。コードの品質とパフォーマンス向上に不可欠です。\n\n- **プロセスの最適化**:\n  - 不要なプロセスの削減や、メッセージキューの監視を行うことで、ガベージコレクションのオーバーヘッドやメモリ使用量を最適化できます。\n\n- **NIF (Native Implemented Functions) の活用**:\n  - 計算集約型（CPUバウンド）の処理には、ネイティブ言語（C, Rustなど）で実装された関数を呼び出すNIFが非常に有効です。Rustlerなどのライブラリを使うと、より安全にNIFを実装できます。ただし、NIFはBEAMプロセスをブロックするため、I/Oバウンドなタスクには不向きです。\n\nこれらの手法を組み合わせることで、Elixirアプリケーションは高いスケーラビリティとパフォーマンスを実現できます。","src/content/docs/elixirガイド/04_上級・最適化/パフォーマンスチューニング.mdx","14265b3daefe3fe1","elixirガイド/02_基本/環境構築",{"id":424,"data":426,"body":431,"filePath":432,"digest":433,"deferredRender":16},{"title":427,"editUrl":16,"head":428,"template":18,"sidebar":429,"pagefind":16,"draft":20},"環境構築",[],{"hidden":20,"attrs":430},{},"Elixirの環境構築手順を以下に示します。\n\n## インストール\n\nElixirをインストールするには、以下の手順を実行します。まず、Homebrewがインストールされていることを確認してください。\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n## セットアップ\n\nHomebrewがインストールされたら、以下のコマンドを実行してElixirをインストールします。\n\n```bash\nbrew install elixir\n```","src/content/docs/elixirガイド/02_基本/環境構築.mdx","aca9fa2827708057","flutterガイド/02_基本/api_communication",{"id":434,"data":436,"body":441,"filePath":442,"digest":443,"deferredRender":16},{"title":437,"editUrl":16,"head":438,"template":18,"sidebar":439,"pagefind":16,"draft":20},"API通信",[],{"label":437,"hidden":20,"attrs":440},{},"# API通信の概要\n\nFlutterでのAPI通信は、`http`パッケージを使用して簡単に行うことができます。ここでは、GETリクエストとPOSTリクエストの基本的な使い方を紹介します。\n\n## GETリクエスト\n\nGETリクエストを使用して、サーバーからデータを取得します。\n\n```dart\nimport 'package:http/http.dart' as http;\n\nFuture\u003Cvoid> fetchData() async {\n  final response = await http.get(Uri.parse('https://api.example.com/data'));\n  if (response.statusCode == 200) {\n    print('Data fetched successfully');\n  } else {\n    print('Failed to fetch data');\n  }\n}\n```\n\n- **`get`**: サーバーからデータを取得するためのHTTPメソッドです。\n- **`Uri.parse`**: URLを解析して、`Uri`オブジェクトを生成します。\n\n## POSTリクエスト\n\nPOSTリクエストを使用して、サーバーにデータを送信します。\n\n```dart\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\n\nFuture\u003Cvoid> postData() async {\n  final response = await http.post(\n    Uri.parse('https://api.example.com/data'),\n    headers: \u003CString, String>{\n      'Content-Type': 'application/json; charset=UTF-8',\n    },\n    body: jsonEncode(\u003CString, String>{\n      'key': 'value',\n    }),\n  );\n  if (response.statusCode == 201) {\n    print('Data posted successfully');\n  } else {\n    print('Failed to post data');\n  }\n}\n```\n\n- **`post`**: サーバーにデータを送信するためのHTTPメソッドです。\n- **`jsonEncode`**: データをJSON形式にエンコードします。\n\n## その他の通信手法\n\n- **`PUTリクエスト`**: サーバー上のデータを更新します。\n- **`DELETEリクエスト`**: サーバー上のデータを削除します。\n\nこれらの方法を使って、FlutterアプリケーションからAPIと通信し、データの更新や削除を行うことができます。\n\n# 実践的なアドバイス\n\nAPI通信を行う際のベストプラクティスや、よくある問題の解決策を以下に示します。\n\n## ベストプラクティス\n\n- **エラーハンドリング**: API通信中にエラーが発生した場合、適切なエラーメッセージを表示し、ユーザーに再試行を促します。\n- **非同期処理の活用**: API通信は非同期で行い、UIスレッドをブロックしないようにします。\n- **データのキャッシュ**: ネットワーク通信を最小限に抑えるために、データをキャッシュし、オフラインでも利用可能にします。\n\n## よくある問題の解決策\n\n- **タイムアウトの設定**: APIリクエストがタイムアウトする場合、`http`パッケージの`timeout`メソッドを使用して、タイムアウト時間を設定します。\n\n```dart\nfinal response = await http.get(Uri.parse('https://api.example.com/data')).timeout(Duration(seconds: 10));\n```\n\n- **認証の実装**: APIが認証を必要とする場合、適切な認証ヘッダーをリクエストに追加します。\n\n```dart\nfinal response = await http.get(\n  Uri.parse('https://api.example.com/data'),\n  headers: \u003CString, String>{\n    'Authorization': 'Bearer YOUR_ACCESS_TOKEN',\n  },\n);\n```","src/content/docs/flutterガイド/02_基本/api_communication.mdx","44607c20ddd23c86","flutterガイド/02_基本/data_management",{"id":444,"data":446,"body":451,"filePath":452,"digest":453,"deferredRender":16},{"title":447,"editUrl":16,"head":448,"template":18,"sidebar":449,"pagefind":16,"draft":20},"データ管理",[],{"label":447,"hidden":20,"attrs":450},{},"# データ管理\n\nFlutterでのデータ管理は、アプリケーションの機能性とユーザー体験を向上させるために重要です。以下に、データ管理の方法を紹介します。\n\n## ローカルデータベース\n\nFlutterでローカルデータベースを使用する方法を紹介します。`sqflite`パッケージを使用して、データを永続化します。\n\n### sqfliteの使用例\n\n```dart\nimport 'package:sqflite/sqflite.dart';\n\nFuture\u003Cvoid> insertData(Database db) async {\n  await db.insert(\n    'table_name',\n    {'column_name': 'value'},\n  );\n}\n```\n\n- **`sqflite`**: SQLiteデータベースを操作するためのパッケージです。\n- **`insert`**: データをテーブルに挿入します。\n\n## ネットワーク通信\n\n`http`パッケージを使ってAPI通信を行う方法を紹介します。RESTful APIと通信することで、外部データを取得・送信します。\n\n### HTTPリクエストの例\n\n```dart\nimport 'package:http/http.dart' as http;\n\nFuture\u003Cvoid> fetchData() async {\n  final response = await http.get(Uri.parse('https://api.example.com/data'));\n  if (response.statusCode == 200) {\n    print('Data fetched successfully');\n  }\n}\n```\n\n- **`http`**: HTTPリクエストを行うためのパッケージです。\n- **`get`**: データを取得するためのHTTPメソッドです。\n\n## その他のデータ管理手法\n\n- **`shared_preferences`**: キーと値のペアを保存するためのパッケージです。ユーザー設定や小さなデータを保存するのに適しています。\n- **`hive`**: 軽量で高速なNoSQLデータベースです。オフラインデータの保存に適しています。\n\n# 実践的なアドバイス\n\nデータ管理を行う際のベストプラクティスや、よくある問題の解決策を以下に示します。\n\n## ベストプラクティス\n\n- **データのキャッシュ**: ネットワーク通信を最小限に抑えるために、データをキャッシュし、オフラインでも利用可能にします。\n- **非同期処理の活用**: データベース操作やネットワークリクエストは非同期で行い、UIスレッドをブロックしないようにします。\n- **データの正規化**: データベース内のデータを正規化し、冗長性を排除します。\n\n## よくある問題の解決策\n\n- **ネットワークエラーの処理**: ネットワークエラーが発生した場合、適切なエラーメッセージを表示し、ユーザーに再試行を促します。\n\n```dart\ntry {\n  final response = await http.get(Uri.parse('https://api.example.com/data'));\n  if (response.statusCode == 200) {\n    print('Data fetched successfully');\n  } else {\n    print('Failed to fetch data');\n  }\n} catch (e) {\n  print('Network error: $e');\n}\n```\n\n- **データの競合**: 複数のデータソースからデータを取得する場合、データの競合を防ぐために、データの整合性を保つロジックを実装します。\n\n```","src/content/docs/flutterガイド/02_基本/data_management.mdx","c862cf198c176b31","flutterガイド/02_基本/アーキテクチャ",{"id":454,"data":456,"body":460,"filePath":461,"digest":462,"deferredRender":16},{"title":408,"editUrl":16,"head":457,"template":18,"sidebar":458,"pagefind":16,"draft":20},[],{"label":408,"hidden":20,"attrs":459},{},"___\n# フォルダ構成\n\nFlutterプロジェクトのフォルダ構成は、アプリケーションの開発効率とメンテナンス性を向上させるために重要です。以下に、主要なフォルダの役割を紹介します。\n\n## 主要フォルダの役割\n\n### **lib フォルダ**\nメインのDartコードを書く場所です。\n\n- **`main.dart`**: アプリのエントリーポイントです。アプリケーションの起動とルーティングを管理します。\n- **`screens/`**: 各画面のUIを定義します。画面ごとにファイルを分けて管理します。\n- **`widgets/`**: 再利用可能なウィジェットを定義します。共通のUIコンポーネントをここに配置します。\n- **`models/`**: データモデルを定義します。アプリケーションで使用するデータ構造をここに配置します。\n- **`services/`**: API通信やデータベース処理を行うサービスを定義します。\n- **`utils/`**: ユーティリティ関数を定義します。共通のロジックをここに配置します。\n- **`route/`**: ルーティング関連のファイルを管理します。\n  - **`routes.dart`**: アプリケーションのルーティングを管理します。\n\n### **android フォルダ**\nAndroid固有の設定やネイティブコードを管理します。\n\n- **`app/build.gradle`**: Android依存関係とビルド設定を管理します。\n- **`app/src/main/AndroidManifest.xml`**: アプリの権限、アクティビティ設定を管理します。\n- **`app/src/main/kotlin/`**: Android用のネイティブコードを管理します（必要な場合）。\n- **`app/src/main/res/`**: アイコン、スプラッシュ画面などのリソースを管理します。\n\n### **ios フォルダ**\niOS固有の設定やネイティブコードを管理します。\n\n- **`Runner.xcodeproj`**: Xcodeプロジェクト設定を管理します。\n- **`Runner/Info.plist`**: iOS権限、設定情報を管理します。\n- **`Runner/Assets.xcassets`**: アプリアイコン、画像リソースを管理します。\n\n## その他の重要フォルダ\n\n### **assets フォルダ**\n画像、フォント、設定ファイルなどの静的リソースを管理します。\n\n### **test フォルダ**\nユニットテストとウィジェットテストを管理します。\n\n### **web フォルダ**\nWeb版アプリ用の設定を管理します。\n\n# 実践的なアドバイス\n\nフォルダ構成を設計する際のベストプラクティスや、よくある問題の解決策を以下に示します。\n\n## ベストプラクティス\n\n- **一貫した命名規則**: フォルダやファイルの命名規則を一貫させ、チーム全体で統一します。\n- **モジュール化**: 機能ごとにフォルダを分け、コードのモジュール化を図ります。これにより、コードの再利用性とメンテナンス性が向上します。\n- **ドキュメントの整備**: 各フォルダの役割や使用方法をドキュメント化し、新しいメンバーがプロジェクトに参加しやすくします。\n\n## よくある問題の解決策\n\n- **フォルダの肥大化**: フォルダが肥大化した場合、サブフォルダを作成して整理します。例えば、`screens/`フォルダ内に`home/`や`settings/`などのサブフォルダを作成します。\n\n- **依存関係の管理**: 依存関係が複雑になる場合、`pubspec.yaml`を適切に管理し、不要な依存関係を削除します。\n\n- **プラットフォーム固有のコードの管理**: プラットフォーム固有のコードは、`android/`や`ios/`フォルダに分けて管理し、共通コードと分離します。","src/content/docs/flutterガイド/02_基本/アーキテクチャ.mdx","e0a0dcfed43c9b61","flutterガイド/03_中級/api利用法",{"id":463,"data":465,"body":469,"filePath":470,"digest":471,"deferredRender":16},{"title":388,"editUrl":16,"head":466,"template":18,"sidebar":467,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":468},{},"## FlutterとRailsのAPI連携\nFlutterとRailsのAPI連携について、両方の観点から実践的に解説します。\n\n### 1. 全体像の理解 💡\nFlutterとRailsは、それぞれ独立した役割を担います。\n\n- **Rails（バックエンド）**: APIサーバーとして機能します。データベースとのやり取り、ビジネスロジックの実行、そしてJSON形式でのデータ提供を担当します。\n- **Flutter（フロントエンド）**: UI（ユーザーインターフェース）を担当します。ユーザーの操作に応じてRailsのAPIにHTTPリクエストを送信し、返ってきたJSONデータを画面に表示します。\n\nこの構成では、両者はRESTful APIを介して通信するのが一般的です。\n\n### 2. Rails側でのAPI構築 ⚙️\nまず、RailsでAPIエンドポイントを準備します。Railsは`--api`オプションを使ってAPI専用プロジェクトを簡単に作成できます。\n\n```bash\nrails new your_project_name --api\n```\n\n次に、データを扱うためのリソース（例：posts）を生成します。\n\n```bash\nrails g resource post title:string body:string\n```\n\nこれにより、`app/models/post.rb`、`app/controllers/posts_controller.rb`、ルーティング設定が自動で生成されます。\n\n`posts_controller.rb`で、`index`（一覧取得）や`show`（個別取得）などのアクションを定義します。\n\n```ruby\n# app/controllers/posts_controller.rb\nclass PostsController \u003C ApplicationController\n  def index\n    @posts = Post.all\n    render json: @posts # JSON形式でデータを返却\n  end\n\n  def show\n    @post = Post.find(params[:id])\n    render json: @post\n  end\nend\n```\n\n`rails s`コマンドでサーバーを起動すると、`http://localhost:3000/posts`にアクセスすることで、JSONデータが返されるようになります。\n\n### 3. Flutter側でのAPI疎通 📲\nFlutterアプリからRails APIにアクセスするためには、`http`パッケージを使用します。特に、非同期処理を扱う`Future`と`async/await`構文が重要です。\n\n#### GETリクエスト：データの取得\n`http.get`メソッドを使って、Railsからデータを取得します。\n\n```dart\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\n\nFuture\u003CList\u003CPost>> fetchPosts() async {\n  // 開発中のローカル環境では、PCのIPアドレスを指定\n  final response = await http.get(Uri.parse('http://10.0.2.2:3000/posts'));\n  \n  if (response.statusCode == 200) {\n    // JSON文字列をデコードし、List\u003CMap>に変換\n    final List\u003Cdynamic> jsonList = json.decode(response.body);\n    \n    // Mapをカスタムモデルのリストに変換\n    return jsonList.map((json) => Post.fromJson(json)).toList();\n  } else {\n    throw Exception('Failed to load posts');\n  }\n}\n\n// レスポンスのJSONを扱うためのモデルクラス\nclass Post {\n  final int id;\n  final String title;\n  final String body;\n\n  Post({required this.id, required this.title, required this.body});\n\n  factory Post.fromJson(Map\u003CString, dynamic> json) {\n    return Post(\n      id: json['id'],\n      title: json['title'],\n      body: json['body'],\n    );\n  }\n}\n```\n\n**ポイント:**\n- **IPアドレス**: Androidエミュレータは、localhostではなく`10.0.2.2`でホストマシンにアクセスします。iOSシミュレータの場合はlocalhostで問題ありません。\n- **モデルクラス**: JSONデータを直接扱うのではなく、モデルクラスに変換することで、コードの安全性が高まります。\n\n#### POSTリクエスト：データの送信\n`http.post`メソッドを使って、新しいデータをRailsに送信します。\n\n```dart\nFuture\u003CPost> createPost(String title, String body) async {\n  final response = await http.post(\n    Uri.parse('http://10.0.2.2:3000/posts'),\n    headers: \u003CString, String>{\n      'Content-Type': 'application/json; charset=UTF-8',\n    },\n    body: jsonEncode(\u003CString, String>{\n      'title': title,\n      'body': body,\n    }),\n  );\n\n  if (response.statusCode == 201) {\n    // 成功（201 Created）\n    return Post.fromJson(jsonDecode(response.body));\n  } else {\n    throw Exception('Failed to create post');\n  }\n}\n```\n\n**ポイント:**\n- **headers**: JSONデータを送ることをRailsに伝えるため、`Content-Type`を設定します。\n- **body**: Dartの`Map`を`jsonEncode`でJSON文字列に変換してから送信します。\n\n### 4. 実際のFlutterアプリでの表示 🖼️\n上記で作成した関数を、`FutureBuilder`ウィジェットと組み合わせて使用することで、非同期処理のローディング状態やエラーを簡単にUIに反映できます。\n\n```dart\nclass PostListPage extends StatefulWidget {\n  const PostListPage({super.key});\n\n  @override\n  State\u003CPostListPage> createState() => _PostListPageState();\n}\n\nclass _PostListPageState extends State\u003CPostListPage> {\n  late Future\u003CList\u003CPost>> futurePosts;\n\n  @override\n  void initState() {\n    super.initState();\n    futurePosts = fetchPosts();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Rails × Flutter')),\n      body: FutureBuilder\u003CList\u003CPost>>(\n        future: futurePosts,\n        builder: (context, snapshot) {\n          if (snapshot.connectionState == ConnectionState.waiting) {\n            return const Center(child: CircularProgressIndicator());\n          } else if (snapshot.hasError) {\n            return Center(child: Text('エラー: ${snapshot.error}'));\n          } else if (snapshot.hasData) {\n            return ListView.builder(\n              itemCount: snapshot.data!.length,\n              itemBuilder: (context, index) {\n                final post = snapshot.data![index];\n                return ListTile(title: Text(post.title));\n              },\n            );\n          } else {\n            return const Center(child: Text('データがありません'));\n          }\n        },\n      ),\n    );\n  }\n}\n```\n\nこの例は、FlutterがRailsのAPIから取得したデータを動的に表示する、一般的なパターンを示しています。\n\n### API疎通におけるCORSの扱い 🛡️\nCORSは、異なるオリジン（ドメイン、プロトコル、ポートの組み合わせ）間でリソースを共有するための仕組みです。ブラウザはセキュリティ上の理由から、CORSのルールに従ってリクエストをブロックします。\n\n結論から言うと、通常のFlutter開発において、CORSの設定は基本的に不要です。\n\nその理由は、CORSがWebブラウザのセキュリティ機能だからです。モバイルアプリ（iOS/Android）はブラウザのセキュリティモデルに縛られないため、異なるオリジンへのAPIリクエストを自由に送信できます。\n\nただし、以下のプラットフォームではCORS設定が必要になる場合があります。\n\n- **Web**: FlutterアプリをWebで動かす場合、Webブラウザ上で動作するため、CORSの制約を受けます。この場合、Rails側にCORS設定を追加する必要があります。\n- **macOS / Windows / Linux**: デスクトップアプリとして動作する場合、ブラウザの制約を受けないため、CORS設定は不要です。\n\n### RailsでのCORS設定方法 🛠️\nRailsでCORSを有効にするには、`rack-cors` gemを使用するのが一般的です。\n\n#### 1. Gemの追加\n`Gemfile`に以下の行を追加し、`bundle install`を実行します。\n\n```ruby\ngem 'rack-cors'\n```\n\n#### 2. CORS設定\n`config/initializers/cors.rb`ファイルで設定を行います。\n\n```ruby\nRails.application.config.middleware.insert_before 0, Rack::Cors do\n  allow do\n    # Flutter Webアプリのオリジンを指定\n    origins 'http://localhost:XXXX' # 例: localhost:5500など\n    # 複数指定する場合は 'http://localhost:3000', 'https://example.com' のようにカンマ区切りで記述\n    \n    # 許可するHTTPメソッド\n    resource '*',\n      headers: :any,\n      methods: [:get, :post, :put, :patch, :delete, :options, :head]\n  end\nend\n```\n\n**origins**には、Flutter Webアプリが動作するオリジン（ドメインとポート）を指定します。ワイルドカード`*`を使うことも可能ですが、セキュリティ上の理由から、本番環境では特定のドメインを指定することが推奨されます。\n\n### その他に付け加えるべき点 💡\n#### 1. 開発環境でのIPアドレスの注意点\n前回の回答で触れたように、Androidエミュレータは`10.0.2.2`を使用しますが、これは開発環境特有の注意点です。\n\n- **iOSシミュレータ**: `localhost`または`127.0.0.1`でホストマシンにアクセスできます。\n- **実機テスト**: PCと同じWi-Fiネットワークに接続し、PCのローカルIPアドレス（例: `192.168.1.5`）を使用する必要があります。\n\n#### 2. セキュリティ対策 🔒\n本番環境では、APIキーや認証トークンを使って通信を保護することが不可欠です。\n\n- **Rails側**: `posts_controller.rb`で、`before_action :authenticate_user!`などを設定し、認証されていないリクエストを拒否します。\n- **Flutter側**: `http`リクエストのヘッダーに認証トークンを含めて送信します。\n\n```dart\n// ヘッダーに認証トークンを追加\nfinal token = 'YOUR_AUTH_TOKEN';\nfinal response = await http.get(\n  Uri.parse('http://your-api-url.com/posts'),\n  headers: {\n    'Authorization': 'Bearer $token',\n  },\n);\n```\n\nこれらのポイントを踏まえることで、FlutterとRailsの連携をより安全かつスムーズに進めることができます。\n\n### APIクライアントの抽象化と管理 🧩\n**問題点:**\nAPIリクエストをウィジェットの内部に直接記述すると、コードが複雑になり、テストやメンテナンスが困難になります。特に、複数のAPIエンドポイントやリクエストヘッダーの共通設定がある場合、コードの重複が発生しやすくなります。\n\n**解決策:**\nAPIリクエストを専門に扱うAPIクライアントクラスを作成し、抽象化します。\n\n```dart\n// lib/services/api_service.dart\nimport 'package:http/http.dart' as http;\n\nclass ApiService {\n  final String _baseUrl = 'http://10.0.2.2:3000';\n  final Map\u003CString, String> _headers = {\n    'Content-Type': 'application/json; charset=UTF-8',\n    'Authorization': 'Bearer YOUR_AUTH_TOKEN', // 認証トークン\n  };\n\n  Future\u003Chttp.Response> getPosts() {\n    final uri = Uri.parse('$_baseUrl/posts');\n    return http.get(uri, headers: _headers);\n  }\n\n  Future\u003Chttp.Response> createPost(Map\u003CString, dynamic> data) {\n    final uri = Uri.parse('$_baseUrl/posts');\n    return http.post(uri, headers: _headers, body: jsonEncode(data));\n  }\n}\n```\n\n**実践的な使い方:**\n`ApiService`のようなクラスをシングルトンパターンや依存性注入（例: Riverpod）で管理し、アプリケーション全体で再利用します。これにより、APIのエンドポイントやヘッダーの変更が必要になった場合でも、このクラスを1箇所修正するだけで済みます。\n\n### エラーハンドリングの強化 ⚠️\n**問題点:**\n前回のコード例では、ステータスコードが200または201でない場合に一律で`Exception`を投げていました。しかし、APIから返されるエラーには、入力値の検証エラー（422 Unprocessable Entity）や認証エラー（401 Unauthorized）など、様々な種類があります。\n\n**解決策:**\nステータスコードに応じて、より具体的なエラー処理を行います。\n\n```dart\nFuture\u003CList\u003CPost>> fetchPosts() async {\n  final response = await http.get(Uri.parse('$_baseUrl/posts'));\n\n  if (response.statusCode == 200) {\n    // 成功\n    // ...\n  } else if (response.statusCode == 401) {\n    // 認証エラー\n    throw Exception('認証に失敗しました。再度ログインしてください。');\n  } else if (response.statusCode >= 400 && response.statusCode \u003C 500) {\n    // クライアントエラー\n    throw Exception('不正なリクエストです。');\n  } else {\n    // その他のエラー\n    throw Exception('サーバーエラーが発生しました。');\n  }\n}\n```\n\n**実践的な使い方:**\nAPIレスポンスのステータスコードを詳細にチェックし、ユーザーに分かりやすいエラーメッセージを表示したり、ログを記録したりします。これにより、ユーザー体験が向上し、デバッグも容易になります。\n\n### より高度なAPIクライアント: Dio パッケージ 🌐\n**問題点:**\n`http`パッケージはシンプルで使いやすいですが、インターセプター、リクエストのキャンセル、グローバルな設定など、高度な機能がありません。\n\n**解決策:**\nより高機能なHTTPクライアントライブラリである`Dio`を使用することを検討します。\n\n```dart\n// Dioのインストール\n// flutter pub add dio\n\nimport 'package:dio/dio.dart';\n\nfinal dio = Dio();\n\nFuture\u003Cvoid> fetchDataWithDio() async {\n  try {\n    // ベースURLやヘッダーをグローバルに設定\n    dio.options.baseUrl = 'http://10.0.2.2:3000';\n    dio.options.headers = {\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer YOUR_AUTH_TOKEN',\n    };\n\n    final response = await dio.get('/posts');\n\n    if (response.statusCode == 200) {\n      print('Data: ${response.data}');\n    }\n  } on DioException catch (e) {\n    // ネットワークエラーやAPIエラーを詳細にハンドリング\n    print('エラー: ${e.response?.statusCode}');\n    print('エラーメッセージ: ${e.response?.data}');\n  }\n}\n```\n\n**実践的な使い方:**\n- **インターセプター**: すべてのリクエストに認証トークンを自動で追加するなどの共通処理を実装できます。\n- **エラーハンドリング**: `DioException`クラスを使って、ネットワークエラー、タイムアウト、ステータスコードごとのエラーをより細かく捕捉できます。\n\nこれらの留意点を考慮することで、より堅牢で保守性の高いFlutterアプリケーションを開発できます。\n\n### データシリアライゼーションの自動化 📦\nAPIから受け取ったJSONデータをモデルクラスに変換する作業（シリアライゼーション）は、手動で行うと非常に手間がかかり、ミスも起こりやすいです。特に、JSONの構造が複雑だったり、APIの仕様変更があったりする場合、手動での対応は現実的ではありません。\n\n**解決策:**\n`json_serializable`と`build_runner`というパッケージを使って、シリアライゼーションのコードを自動生成します。\n\n#### 準備\n`pubspec.yaml`に以下のパッケージを追加します。\n\n```yaml\ndependencies:\n  json_annotation: ^4.8.1\n\ndev_dependencies:\n  build_runner: ^2.4.6\n  json_serializable: ^6.7.1\n```\n\n#### モデルクラスの定義\n自動生成を有効にするために、モデルクラスを`@JsonSerializable()`アノテーションで装飾し、`factory`コンストラクタと`toJson`メソッドを追加します。\n\n```dart\nimport 'package:json_annotation/json_annotation.dart';\n\npart 'post.g.dart';\n\n@JsonSerializable()\nclass Post {\n  final int id;\n  final String title;\n  final String body;\n\n  Post({required this.id, required this.title, required this.body});\n\n  factory Post.fromJson(Map\u003CString, dynamic> json) => _$PostFromJson(json);\n  Map\u003CString, dynamic> toJson() => _$PostToJson(this);\n}\n```\n\n#### コードの自動生成\nターミナルで以下のコマンドを実行します。\n\n```bash\nflutter pub run build_runner build\n```\n\nこれにより、`post.g.dart`というファイルが生成され、`_$PostFromJson`と`_$PostToJson`というシリアライゼーションのロジックが自動的に作成されます。\n\n**実践的な使い方:**\nAPIの仕様が変更された場合でも、モデルクラスを修正してコマンドを再実行するだけで、シリアライゼーションのコードが最新の状態に保たれます。これにより、開発効率が大幅に向上し、ヒューマンエラーを減らせます。\n\n### API連携と状態管理の統合 🔄\nAPIリクエストは非同期処理であり、その状態（ローディング中、成功、エラー）をUIに適切に反映する必要があります。`FutureBuilder`は単一のウィジェットで非同期処理を扱うには便利ですが、複数のウィジェットで同じAPIデータを共有したり、状態をより複雑に管理したりする場合には不十分です。\n\n**解決策:**\n`Riverpod`のような状態管理ライブラリとAPIクライアントを組み合わせることで、API連携のロジックをUIから完全に分離できます。\n\n#### APIクライアントとプロバイダの連携\n先ほど作成した`ApiService`を`Riverpod`の`Provider`で管理します。\n\n```dart\n// lib/providers/providers.dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../services/api_service.dart';\nimport '../models/post.dart';\n\n// ApiServiceのインスタンスをシングルトンとして提供\nfinal apiServiceProvider = Provider\u003CApiService>((ref) => ApiService());\n\n// APIから投稿一覧を取得するFutureProvider\nfinal postsProvider = FutureProvider\u003CList\u003CPost>>((ref) async {\n  final apiService = ref.watch(apiServiceProvider);\n  final response = await apiService.getPosts();\n  \n  if (response.statusCode == 200) {\n    final List\u003Cdynamic> jsonList = json.decode(response.body);\n    return jsonList.map((json) => Post.fromJson(json)).toList();\n  }\n  throw Exception('投稿の取得に失敗しました');\n});\n```\n\n**実践的な使い方:**\n- **UIからAPIロジックを分離**: `postsProvider`を定義することで、ウィジェットは直接APIリクエストを呼び出す必要がなくなります。\n- **状態の自動管理**: `FutureProvider`が自動的にローディング、データ、エラーの状態を管理してくれるため、`FutureBuilder`を繰り返し書く手間が省けます。\n- **UIでの利用**: UI側では`ref.watch(postsProvider)`を呼び出すだけで、APIの状態に応じてUIを切り替えられます。\n\nこれらの高度なテクニックを導入することで、大規模で複雑なアプリケーションでも、API連携を効率的かつ堅牢に実装できます。\n\n### パフォーマンス最適化とスケーラビリティ 🚀\n#### データのキャッシュ\n頻繁にアクセスするが、あまり更新されないデータ（例: アプリの起動時に取得する設定情報など）がある場合、毎回APIを叩くのは非効率です。\n\n**解決策:**\n取得したデータをローカルにキャッシュ（保存）することで、APIリクエストの回数を減らし、アプリのパフォーマンスを向上させます。\n\n- **簡易的なキャッシュ**: `shared_preferences`パッケージを使って、キーと値のペアでデータを保存できます。\n- **複雑なデータのキャッシュ**: データベースライブラリ（例: `sqflite`や`Hive`）を使って、より構造化されたデータを保存・管理できます。\n\n**Hiveを用いた例:**\nHiveは、NoSQLの軽量なデータベースで、手軽にデータを保存できます。\n\n```dart\n// Hiveの初期化\nawait Hive.initFlutter();\nawait Hive.openBox('postBox');\n\n// データの保存\nfinal box = Hive.box('postBox');\nbox.put('posts', posts.map((post) => post.toJson()).toList());\n\n// データの読み込み\nfinal cachedPosts = box.get('posts');\n```\n\n#### バックグラウンドでのデータ処理\n大量のJSONデータを解析するような重い処理は、メインスレッド（UIスレッド）で実行すると、アプリの動作が一時的に固まる（UIジャック）原因になります。\n\n**解決策:**\n`compute`関数を使って、重い処理をバックグラウンドのスレッド（アイソレート）で実行します。これにより、UIの応答性を維持できます。\n\n```dart\nimport 'dart:convert';\nimport 'package:flutter/foundation.dart';\nimport 'package:http/http.dart' as http;\n\n// バックグラウンドで実行する関数\nList\u003CPost> parsePosts(String responseBody) {\n  final parsed = jsonDecode(responseBody) as List\u003Cdynamic>;\n  return parsed.map((json) => Post.fromJson(json)).toList();\n}\n\nFuture\u003CList\u003CPost>> fetchPosts() async {\n  final response = await http.get(Uri.parse('...'));\n  \n  if (response.statusCode == 200) {\n    // compute関数でバックグラウンドに処理をオフロード\n    return compute(parsePosts, response.body);\n  } else {\n    throw Exception('Failed to load posts');\n  }\n}\n```\n\n#### APIキーの安全な管理\nAPIキーや認証情報など、機密性の高い情報はソースコードに直接書き込むべきではありません。GitHubなどの公開リポジトリにアップロードしてしまうと、情報が漏洩するリスクがあります。\n\n**解決策:**\n`flutter_dotenv`や`--dart-define`フラグなどを使って、環境変数として管理します。\n\n- **flutter_dotenv**: `.env`ファイルにAPIキーを記述し、`.gitignore`に追加することで、バージョン管理から除外できます。\n- **--dart-define**: ビルド時にコマンドラインから変数を渡す方法で、特にCI/CD環境での利用に適しています。\n\n```bash\n// ビルドコマンドの例\nflutter run --dart-define=API_KEY=your_api_key_here\n```\n\n`const apiKey = String.fromEnvironment('API_KEY');`のようにコードからアクセスできます。\n\nこれらの技術は、単にAPIを疎通させるだけでなく、より本格的なアプリケーション開発において、パフォーマンス、セキュリティ、そして保守性を向上させるために不可欠です。","src/content/docs/flutterガイド/03_中級/API利用法.mdx","c0d42771dcc8bef6","flutterガイド/05_学び記事/実践で得た教訓",{"id":472,"data":474,"body":479,"filePath":480,"digest":481,"deferredRender":16},{"title":475,"editUrl":16,"head":476,"template":18,"sidebar":477,"pagefind":16,"draft":20},"実践で得た教訓",[],{"hidden":20,"attrs":478},{},"Flutterの実践で得た教訓を以下に示します。\n\n## よくある疑問\n\n- **State管理**: Flutterでは、状態管理が重要です。適切なパターンを選択することで、アプリケーションの複雑さを軽減できます。\n- **パフォーマンスの最適化**: Widgetの再構築を最小限に抑えることで、パフォーマンスを向上させることができます。","src/content/docs/flutterガイド/05_学び記事/実践で得た教訓.mdx","6856b30f5bbbe71f","flutterガイド/03_中級/pre_release",{"id":482,"data":484,"body":489,"filePath":490,"digest":491,"deferredRender":16},{"title":485,"editUrl":16,"head":486,"template":18,"sidebar":487,"pagefind":16,"draft":20},"リリース前準備",[],{"label":485,"hidden":20,"attrs":488},{},"# App審査前のテスト方法とTestFlightガイド\n\n## 概要\niOSアプリをApp Storeに提出する前の重要なテスト段階について整理。TestFlightを活用したベータテストから審査対策まで網羅的にまとめる。\n\n## App審査前のテスト段階\n\n### 1. 内部テスト（開発段階）\n- **デバッグビルド**\n  - 開発者端末での直接テスト\n  - シミュレータでの基本動作確認\n  - 各機能の単体テスト\n  - メモリリーク、クラッシュの検出\n\n- **アドホック配布**\n  - 限定的な実機テスト\n  - UDID登録済みデバイスでのテスト\n  - 本番環境に近い状態での検証\n\n### 2. TestFlightによるベータテスト\n\n#### TestFlightとは\n- Appleが提供する公式ベータテストプラットフォーム\n- App Store Connectと連携\n- 最大10,000人の外部テスターを招待可能\n- 内部テスター（App Store Connect チーム）は25人まで\n\n#### TestFlightの設定手順\n\n1. **App Store Connectでの準備**\n   - アプリ登録とBundle IDの設定\n   - 証明書・プロビジョニングプロファイルの準備\n   - アプリ情報の基本設定（名前、説明、カテゴリ等）\n\n2. **ビルドのアップロード**\n   ```bash\n   # Xcodeでのアーカイブ\n   # Product → Archive → Distribute App → App Store Connect\n   \n   # またはコマンドラインツール使用\n   xcodebuild -workspace YourApp.xcworkspace \\\n              -scheme YourApp \\\n              -archivePath YourApp.xcarchive \\\n              archive\n   ```\n\n3. **TestFlightでのビルド管理**\n   - アップロードされたビルドの自動レビュー待ち\n   - 処理完了後、テスターへの配布可能\n   - ビルド番号は毎回増加させる必要あり\n\n#### テスターの管理\n\n**内部テスター**\n- App Store Connectのチームメンバー\n- 即座にテスト開始可能\n- 管理者、開発者、App Manager、マーケターの役割に応じて招待\n\n**外部テスター**\n- メールアドレスでの招待\n- Appleの審査が必要（初回のみ、通常24時間以内）\n- グループ機能でテスター管理\n- 公開リンクでの一般募集も可能\n\n### 3. 審査前チェックリスト\n\n#### 技術的要件\n- [ ] 全ての対象デバイスでの動作確認\n- [ ] 各iOSバージョンでの互換性テスト\n- [ ] ネットワーク接続状況の変化への対応\n- [ ] バックグラウンド・フォアグラウンド切り替え\n- [ ] メモリ不足時の適切なハンドリング\n- [ ] 権限要求の適切な実装（カメラ、位置情報等）\n\n#### App Store審査ガイドライン準拠\n- [ ] プライバシーポリシーの整備\n- [ ] 年齢制限レーティングの適切な設定\n- [ ] コンテンツの適切性確認\n- [ ] 決済機能がある場合のIn-App Purchase実装\n- [ ] 広告内容の適切性（該当する場合）\n\n#### メタデータとアセット\n- [ ] アプリアイコン（必要なすべてのサイズ）\n- [ ] スクリーンショット（各デバイスサイズ対応）\n- [ ] アプリ説明文（キーワード最適化）\n- [ ] カテゴリとキーワードの選定\n- [ ] 年齢レーティングの設定\n\n### 4. TestFlightテストのベストプラクティス\n\n#### テスト計画\n1. **段階的ロールアウト**\n   - 内部テスター → 限定外部テスター → 一般外部テスター\n   - 各段階でのフィードバック収集と改善\n\n2. **多様なテスト環境**\n   - 異なるデバイスモデル\n   - 各iOSバージョン\n   - 様々なネットワーク環境\n   - 異なる使用パターン\n\n#### フィードバック収集\n- TestFlightのクラッシュレポート分析\n- テスターからの直接フィードバック\n- アナリティクスデータの活用\n- ユーザビリティテストの実施\n\n### 5. よくある審査リジェクト理由と対策\n\n#### 技術的問題\n- **クラッシュ・フリーズ**\n  - 徹底的な品質テスト\n  - 各種例外処理の実装\n  - メモリ管理の最適化\n\n- **不完全な機能**\n  - 全機能の動作確認\n  - ダミーデータやテストモードの除去\n  - ローディング状態の適切な表示\n\n#### ガイドライン違反\n- **プライバシー関連**\n  - データ収集の透明性確保\n  - ユーザー同意の適切な取得\n  - プライバシーポリシーの整備\n\n- **コンテンツ問題**\n  - 不適切なコンテンツの除去\n  - 年齢制限の適切な設定\n  - コミュニティガイドライン遵守\n\n### 6. 効率的なテストサイクル\n\n#### 自動化の活用\n```bash\n# CI/CDでの自動テスト例\n# GitHub Actionsやfastlane等を活用\n\n# fastlane設定例\nlane :beta do\n  build_app(workspace: \"YourApp.xcworkspace\", \n            scheme: \"YourApp\")\n  upload_to_testflight\n  slack(message: \"新しいベータ版をTestFlightにアップロードしました\")\nend\n```\n\n#### テスト効率化\n- 自動テストスイートの整備\n- 継続的インテグレーション\n- 段階的デプロイメント\n- A/Bテストフレームワークの活用\n\n## 参考リンク\n- [App Store Review Guidelines](https://developer.apple.com/app-store/review/guidelines/)\n- [TestFlight Beta Testing](https://developer.apple.com/testflight/)\n- [App Store Connect Help](https://developer.apple.com/help/app-store-connect/)\n\n## Tags\n#iOS #AppStore #TestFlight #QA #審査対策 #ベータテスト","src/content/docs/flutterガイド/03_中級/pre_release.mdx","006ca0a0eaacb78a","fastapiガイド/01_はじめに/インストール",{"id":492,"data":494,"body":499,"filePath":500,"digest":501,"deferredRender":16},{"title":495,"editUrl":16,"head":496,"template":18,"sidebar":497,"pagefind":16,"draft":20},"FastAPIのインストール",[],{"hidden":20,"attrs":498},{},"## 🚀 FastAPIのインストール手順\n\nFastAPIは、PythonのモダンなWebフレームワークで、高いパフォーマンスと開発効率が魅力です。ここでは、FastAPIと、開発に不可欠なWebサーバーであるUvicornのインストール方法を解説します。\n\n### 1. FastAPIとUvicornのインストール\n\nターミナルまたはコマンドプロンプトを開き、以下のコマンドを順番に実行します。\n\n```bash\npip install fastapi\npip install \"uvicorn[standard]\"\n```\n\n- **FastAPI本体をインストールします。** これにより、フレームワークの主要な機能が利用可能になります。\n- **Uvicornをインストールします。** Uvicornは、FastAPIアプリケーションを動かすためのASGI（Asynchronous Server Gateway Interface）サーバーです。`[standard]`オプションを付けることで、`httptools`や`watchfiles`といった便利な追加ライブラリも同時にインストールされ、ホットリロード（コード変更時の自動再起動）などの機能が使えるようになります。\n\n### 2. 環境の準備と実行\n\nインストールが完了したら、簡単なPythonファイルを作成して動作を確認してみましょう。\n\n#### `main.py`\n\n```python\nfrom typing import Optional\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: Optional[str] = None):\n    return {\"item_id\": item_id, \"q\": q}\n```\n\nこのファイルを保存し、ターミナルで以下のコマンドを実行します。\n\n```bash\nuvicorn main:app --reload\n```\n\n- **`main:app`**: `main`はファイル名（`main.py`）、`app`は`FastAPI()`インスタンスのオブジェクト名を指します。\n- **`--reload`**: このオプションを付けると、コードを変更するたびにサーバーが自動的に再起動します。開発中に非常に便利な機能です。\n\nこれで、Webブラウザから`http://127.0.0.1:8000`にアクセスすると、`{\"Hello\": \"World\"}`というレスポンスが表示されます。\n\n### 3. 仮想環境の作成と利用\n\nPython開発では、プロジェクトごとに独立した環境を構築するために仮想環境を使用するのが一般的です。これにより、異なるプロジェクト間でパッケージのバージョンが衝突するのを防ぐことができます。\n\n#### 仮想環境の作成\n\nプロジェクトのルートディレクトリで、以下のコマンドを実行して仮想環境を作成します。\n\n```bash\npython -m venv venv\n```\n\nこれにより、`venv`という名前のディレクトリが作成され、その中にPythonの実行ファイルと`pip`が格納されます。\n\n#### 仮想環境の有効化\n\n次に、作成した仮想環境を有効化します。\n\n- **macOS / Linux:**\n\n  ```bash\n  source venv/bin/activate\n  ```\n\n- **Windows:**\n\n  ```bash\n  venv\\Scripts\\activate\n  ```\n\n有効化すると、ターミナルのプロンプトの先頭に`(venv)`と表示され、この環境がアクティブになっていることを示します。この状態で`pip install`コマンドを実行すると、パッケージはこの仮想環境内にのみインストールされます。\n\n#### 📌 何をしているのか？\n\npython -m venv … Python に標準搭載の venv モジュールを呼び出す\n\nvenv（最後の部分） … 作成する仮想環境のフォルダ名\n\nこれを実行すると、次のような専用フォルダ構造ができます：\n\n```vbnet\nプロジェクト/\n ├── venv/              ← 仮想環境フォルダ\n │    ├── bin/ (Scripts\\ on Windows) ← python 実行ファイルや pip\n │    ├── lib/          ← インストールしたライブラリ\n │    └── pyvenv.cfg\n └── app.py             ← 自分のコード\n```\n\n#### 📌 仮想環境が必要な理由\n\nプロジェクトごとにライブラリを分けられます。\n→ グローバルにインストールすると、他プロジェクトとバージョンが衝突する\n\n再現性のある環境を作れる\n→ requirements.txt と一緒に管理すれば、同じ環境を誰でも再構築できます。\n\nシステム Python を汚さない\n\n#### 依存関係の管理\n\nプロジェクトの依存関係を管理するために、インストールしたパッケージを`requirements.txt`ファイルに記録しておきましょう。\n\n```bash\npip freeze > requirements.txt\n```\n\n他の開発者がプロジェクトに参加する際や、本番環境にデプロイする際には、このファイルから必要なパッケージを一括でインストールできます。\n\n```bash\npip install -r requirements.txt\n```\n\nこのトピックを追加することで、初心者がより良い開発プラクティスを身につけ、プロジェクトを長期的に管理しやすくなります。","src/content/docs/fastapiガイド/01_はじめに/インストール.mdx","b51ae1d80aee1bae","fastapiガイド/01_はじめに/初心者向けガイド",{"id":502,"data":504,"body":509,"filePath":510,"digest":511,"deferredRender":16},{"title":505,"editUrl":16,"head":506,"template":18,"sidebar":507,"pagefind":16,"draft":20},"初心者向けガイド",[],{"hidden":20,"attrs":508},{},"## FastAPIの初心者向けガイド\n\n### FastAPIとは\n\nFastAPIは、モダンで高速なWeb APIを構築するためのPythonフレームワークです。\n\n### 前提知識\n\n- Pythonの基本的な知識\n- HTTPプロトコルの理解\n\n### なぜFastAPIを使用するのか？ 🚀\n\nFastAPIは、Web API開発をより効率的で、堅牢かつ高速にするための多くの魅力的な機能を持っています。以下に、FastAPIが開発者に選ばれる主な理由を解説します。\n\n#### 1. 圧倒的なパフォーマンス ⚡️\n\nFastAPIは、Starlette（ルーティングとWebソケットのフレームワーク）とPydantic（データ検証ライブラリ）という、高速なコンポーネントを基盤としています。これらの非同期処理（`async`/`await`）をネイティブにサポートしているため、Node.jsやGoといった他の言語のフレームワークに匹敵する、非常に高いパフォーマンスを発揮します。これにより、高負荷なアプリケーションでもスムーズに動作します。\n\n#### 2. Pythonの型ヒントをフル活用 💡\n\nFastAPIの最大の特長は、Pythonの**型ヒント（type hints）**を積極的に利用している点です。これにより、開発者はPythonの標準的な構文で、データの型を明確に定義できます。\n\n- **自動データ検証**: FastAPIは、受け取ったリクエストデータが定義された型に一致するかを自動的に検証します。もし型が正しくなければ、エラーを返してくれるため、手動でバリデーションコードを書く必要がありません。\n\n`model`\n```py\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    name: str\n    age: int\n```\n\n`endpoint`\n```py\n@app.post(\"/users\")\ndef create_user(user: User):\n    return user\n```\n\nこちらで型が不一致の場合は、422で返却されます。\n\n- **自動ドキュメント生成**: 型情報に基づいて、APIの入出力スキーマを自動的に生成します。これは、OpenAPI（旧Swagger）仕様に準拠しており、インタラクティブなAPIドキュメントとして提供されます。\n- **IDEのサポート**: VS Codeなどの開発ツールで、コード補完やエラーチェックが正確に行われるようになり、開発効率が大幅に向上します。\n\n#### 3. 自動生成されるインタラクティブなAPIドキュメント 📝\n\nFastAPIは、OpenAPI仕様とSwagger UIをデフォルトで組み込んでいます。これにより、コードを一切書くことなく、美しくインタラクティブなAPIドキュメントが自動で生成されます。このドキュメントでは、各エンドポイントのテストもできるため、開発者間のAPI仕様の共有やデバッグが非常にスムーズになります。\n\n#### 4. 開発時間の短縮 ⏱️\n\n「設定より規約」という思想に基づき、ボイラープレートコード（定型的なコード）を最小限に抑え、開発者が本質的なビジネスロジックに集中できるように設計されています。例えば、データのバリデーション、シリアライズ（データ変換）、認証といった多くの面倒な作業を自動化してくれるため、開発時間を大幅に短縮できます。\n\n#### 5. 強固なコミュニティと信頼性 🤝\n\nFastAPIは登場から日が浅いにもかかわらず、その革新的なアプローチにより、Pythonコミュニティで急速に人気を獲得しました。NetflixやMicrosoftなどの大手企業でも採用事例があり、その信頼性は証明されています。豊富なドキュメントと活発なコミュニティがあり、問題解決も容易です。","src/content/docs/fastapiガイド/01_はじめに/初心者向けガイド.mdx","1850a689e2bfd4d7","fastapiガイド/04_上級最適化/08_orm",{"id":512,"data":514,"body":519,"filePath":520,"digest":521,"deferredRender":16},{"title":515,"editUrl":16,"head":516,"template":18,"sidebar":517,"pagefind":16,"draft":20},"FastAPI ORM",[],{"hidden":20,"attrs":518},{},"## FastAPIにおけるORM（Object-Relational Mapping）\n\nFastAPI自体にはORM機能は含まれていませんが、Pythonで最も人気のあるORMライブラリであるSQLAlchemyと組み合わせることで、Pythonオブジェクトを介してデータベース操作を効率的に行うことができます。\n\n### SQLAlchemyモデルの定義\n\nSQLAlchemyでは、`declarative_base()`から生成されるBaseクラスを継承して、Pythonのクラスとしてデータベースのテーブルを定義します。\n\n#### 例: ユーザーと投稿のモデル定義\n\n`app/models.py`\n\n```python\nfrom sqlalchemy import Column, Integer, String, ForeignKey\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n    email = Column(String, unique=True, index=True)\n\n    posts = relationship(\"Post\", back_populates=\"owner\")\n\nclass Post(Base):\n    __tablename__ = 'posts'\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    content = Column(String)\n    owner_id = Column(Integer, ForeignKey(\"users.id\"))\n\n    owner = relationship(\"User\", back_populates=\"posts\")\n```\n- `declarative_base()`: ORMマッピングの基底クラスを作成します。\n- `Column`: テーブルのカラムを定義し、データ型や制約（`primary_key`, `index`, `unique`など）を指定します。\n- `relationship()`: 異なるテーブル間の**リレーション（関連付け）**を定義します。Userモデルの`posts`は、そのユーザーが持つ複数のPostにアクセスするためのリレーションです。\n\n### データベースセッションの管理\n\nSQLAlchemyは**セッション（Session）を通じてデータベースとやり取りします。FastAPIでは、このセッションを依存性注入（Dependency Injection）**で管理するのが一般的です。\n\n#### 例: データベース接続のセットアップ\n\n`app/database.py`\n\n```python\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```\n- `get_db`関数: `yield`を使用することで、リクエストが処理される間だけデータベースセッションを保持し、処理完了後に自動で閉じるようにします。\n\n### CRUD操作の実装\n\nORMを利用することで、SQLクエリを直接書く代わりに、Pythonのオブジェクトメソッドを使ってデータベース操作を行うことができます。\n\n#### 例: CRUD操作を抽象化する\n\n`app/crud.py`\n\n```python\nfrom sqlalchemy.orm import Session\nfrom . import models, schemas\n\ndef get_user(db: Session, user_id: int):\n    return db.query(models.User).filter(models.User.id == user_id).first()\n\ndef create_user(db: Session, user: schemas.UserCreate):\n    db_user = models.User(name=user.name, email=user.email)\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n```\n- `db.query()`: `SELECT`文を生成します。\n- `filter()`: `WHERE`句に相当する条件を指定します。\n- `db.add()`: `INSERT`文を準備します。\n- `db.commit()`: 変更をデータベースに確定（コミット）します。\n\n### エンドポイントへの統合\n\n定義したORMモデルとCRUDロジックをFastAPIのエンドポイントに統合します。\n\n#### 例: ORMを利用したエンドポイント\n\n`app/main.py`\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom . import crud, models, schemas\nfrom .database import engine, get_db\n\nmodels.Base.metadata.create_all(bind=engine) # テーブルを自動作成\n\napp = FastAPI()\n\n@app.post(\"/users/\", response_model=schemas.User)\ndef create_new_user(user: schemas.UserCreate, db: Session = Depends(get_db)):\n    db_user = crud.get_user_by_email(db, email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return crud.create_user(db=db, user=user)\n```\n- `Depends(get_db)`: 依存性注入により、各リクエストにDBセッションを供給します。\n- `response_model`: ORMモデルではなく、Pydanticモデル（`schemas.User`）を指定することで、不要なデータをクライアントに返さないようにします。","src/content/docs/fastapiガイド/04_上級・最適化/08_orm.mdx","1ca5fb0301ea4395","fastapiガイド/03_中級/api利用法",{"id":522,"data":524,"body":528,"filePath":529,"digest":530,"deferredRender":16},{"title":388,"editUrl":16,"head":525,"template":18,"sidebar":526,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":527},{},"## FastAPIのAPI利用法\n\nFastAPIは、Pythonの型ヒントを最大限に活用することで、シンプルかつ直感的にAPIエンドポイントを定義できます。これにより、開発者は煩雑な設定から解放され、ビジネスロジックに集中できます。\n\n### 1. エンドポイントの定義とルーティング\n\nAPIのエンドポイントは、Pythonの関数にデコレータを適用することで定義します。このデコレータは、HTTPメソッド（GET, POSTなど）とURLパスを指定します。\n\n#### 例：基本的なエンドポイント\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n# GETメソッドのエンドポイントを定義\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n```\nこのコードは、ルートURL（/）へのGETリクエストを処理するエンドポイントを定義しています。\n\n### 2. パラメータの利用\n\nFastAPIでは、関数の引数としてパラメータを受け取ります。これらの引数にPythonの型ヒントを付けるだけで、FastAPIが自動的にデータのバリデーションとシリアライズを行います。\n\n| パラメータの種類 | 説明 | 例 |\n| --- | --- | --- |\n| パスパラメータ | URLパスの一部として渡される値。 | `/items/{item_id}` |\n| クエリパラメータ | URLの?以降にkey=value形式で渡される値。 | `/items?q=query_string` |\n| リクエストボディ | POSTやPUTリクエストの本文としてJSON形式で渡されるデータ。 | `{ \"name\": \"item\", \"price\": 100 }` |\n\n#### 例：パスパラメータとクエリパラメータ\n\n```python\nfrom typing import Optional\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: Optional[str] = None):\n    # item_idはint型として、qはstr型として自動的に検証される\n    return {\"item_id\": item_id, \"q\": q}\n```\n- `item_id: int`: パスから取得したitem_idが整数であることを保証します。\n- `q: Optional[str] = None`: qが文字列であり、省略可能（デフォルト値None）であることを示します。\n\n### 3. リクエストボディの処理\n\nPOST、PUTなどのリクエストでJSONデータを受け取る場合、Pydanticモデルを使ってリクエストボディの構造を定義します。これにより、データの自動検証とドキュメント生成が実現します。\n\n#### 例：リクエストボディの受け取り\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# リクエストボディのデータ構造を定義\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: bool = None\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    # FastAPIが自動的にリクエストJSONをItemクラスのインスタンスに変換\n    return {\"item_name\": item.name, \"message\": \"Item created successfully\"}\n```\n`create_item`関数の引数`item: Item`は、Itemモデルに従ってJSONデータを自動的に検証します。\n\n### 4. 応答（レスポンス）\n\nFastAPIは、関数が返すPythonオブジェクト（辞書、リスト、Pydanticモデルなど）を自動的にJSON形式のレスポンスに変換します。\n\n#### 例：レスポンスのカスタマイズ\n\n```python\nfrom fastapi import FastAPI, status\n\napp = FastAPI()\n\n# ステータスコードをカスタマイズ\n@app.post(\"/items/\", status_code=status.HTTP_201_CREATED)\nasync def create_item():\n    return {\"message\": \"Item created!\"}\n```\n`status_code`引数を使用することで、HTTPステータスコードを明示的に設定できます。\n\n### 5. 自動生成されるAPIドキュメント\n\nFastAPIの大きな利点は、上記のコードだけでインタラクティブなAPIドキュメントが自動生成されることです。\n\n- `/docs`にアクセスするとSwagger UI、`/redoc`にアクセスするとReDocのドキュメントが表示されます。\n- これにより、APIの仕様確認やテストが非常に簡単になります。\n\n### 6. エラーハンドリング 🚨\n\nAPI開発において、予期せぬエラーや特定の条件でエラーを返すことは不可欠です。FastAPIは`HTTPException`を使って、HTTPステータスコードと詳細メッセージを伴うエラーレスポンスを簡単に生成できます。\n\n#### 例: ユーザーが見つからない場合のエラー\n\n```python\nfrom fastapi import FastAPI, HTTPException\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    # 仮のデータベースアクセス\n    user = {\"id\": 1, \"name\": \"Alice\"}\n    \n    if user_id != user[\"id\"]:\n        raise HTTPException(\n            status_code=404, \n            detail=\"User not found\"\n        )\n    return user\n```\n`HTTPException`: この例外を発生させると、FastAPIは自動的に適切なHTTPステータスコード（例: 404 Not Found）と、JSON形式のレスポンスボディ（`{\"detail\": \"User not found\"}`）を返します。\n\n### 7. ルーターの分割とモジュール化 🧩\n\nアプリケーションが大規模になるにつれて、すべてのエンドポイントを`main.py`に記述するのは非効率的です。FastAPIでは、`APIRouter`を使ってエンドポイントをファイルごとに分割し、モジュール化することができます。\n\n#### 例: ユーザーAPIの分割\n\n`api/v1/users.py`\n\n```python\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n@router.get(\"/users/{user_id}\")\nasync def read_user(user_id: int):\n    return {\"message\": f\"Reading user {user_id}\"}\n```\n\n`main.py`\n\n```python\nfrom fastapi import FastAPI\nfrom .api.v1 import users\n\napp = FastAPI()\n\n# ルーターをインクルード\napp.include_router(users.router, prefix=\"/api/v1\")\n```\n- `APIRouter`: エンドポイントをグループ化し、個別のファイルで管理するためのクラスです。\n- `include_router`: `main.py`で`APIRouter`のインスタンスを読み込み、URLのプレフィックス（`prefix`）を指定してアプリケーションに組み込みます。これにより、`users.py`の`@router.get(\"/users/{user_id}\")`は`/api/v1/users/{user_id}`として機能します。\n\n### 8. セキュリティと認証 🔑\n\nFastAPIは、認証と認可の機能も標準でサポートしています。OAuth 2.0やHTTP Basic Authなどのスキーマを簡単に実装できます。\n\n#### 例: OAuth2によるトークン認証\n\n```python\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@app.get(\"/profile\")\nasync def get_profile(token: str = Depends(oauth2_scheme)):\n    # tokenを使ってユーザーを認証するロジック\n    return {\"message\": \"Profile accessed\", \"token\": token}\n```\n- `Depends`: 依存性注入の仕組みを使い、リクエストヘッダーから認証トークンを自動で取得します。\n- `OAuth2PasswordBearer`: ユーザー名とパスワードを介してOAuth2トークンを取得するためのスキーマを定義します。","src/content/docs/fastapiガイド/03_中級/API利用法.mdx","be7db13e287b32cd","fastapiガイド/04_上級最適化/security",{"id":531,"data":533,"body":538,"filePath":539,"digest":540,"deferredRender":16},{"title":534,"editUrl":16,"head":535,"template":18,"sidebar":536,"pagefind":16,"draft":20},"FastAPIのセキュリティ強化",[],{"hidden":20,"attrs":537},{},"## FastAPIのセキュリティ強化\n\nFastAPIは、デフォルトで高いセキュリティを提供しますが、より堅牢なAPIを構築するためには、追加のセキュリティ対策を実装することが重要です。\n\n### 1. 認証と認可 🔑\n\nFastAPIは、OAuth2やJWT（JSON Web Tokens）などの認証スキームを`Depends`機能と組み合わせて簡単に実装できます。これにより、APIエンドポイントへのアクセスを保護できます。\n\n- **OAuth2**: トークンベースの認証プロトコルで、パスワードを直接送ることなくユーザーを認証します。FastAPIの`OAuth2PasswordBearer`クラスは、これを利用するためのものです。\n- **JWT**: サーバーがユーザーの情報を安全に符号化してトークンとして発行し、クライアントはこのトークンを使って認証されたリクエストを送ります。\n\n### 2. CORS（オリジン間リソース共有） 🌐\n\nCORSは、異なるドメインからAPIへのアクセスを制御する仕組みです。これにより、悪意のあるWebサイトがあなたのAPIを悪用するのを防ぎます。FastAPIの**CORSMiddleware**を使って、許可するオリジン、メソッド、ヘッダーを柔軟に設定できます。\n\n```python\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://your-frontend.com\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n```\n\n### 3. セキュリティヘッダーの適用 🛡️\n\nWebブラウザにセキュリティを強化するよう指示するHTTPヘッダーを追加することで、XSSやクリックジャッキングといった一般的なWeb攻撃を防げます。\n\n- **X-Content-Type-Options**: ブラウザがMIMEタイプを推測するのを防ぎます。\n- **X-Frame-Options**: サイトが`\u003Ciframe>`に埋め込まれるのを制御し、クリックジャッキング攻撃を阻止します。\n- **Content-Security-Policy (CSP)**: どのドメインからリソースをロードできるかを指定し、XSS攻撃を軽減します。\n\nこれらはFastAPIのミドルウェアとして追加できます。\n\n### 4. 入力データの検証とサニタイズ 🧹\n\n悪意のある入力を防ぐため、ユーザーから受け取るデータは常に検証する必要があります。FastAPIのPydanticモデルは、型ヒントに基づいてデータの形式や構造を自動的に検証するため、このプロセスを大幅に簡素化します。\n\n- **Pydantic**: 必須フィールドやデータ型が正しいかを確認します。\n- **ORM**: SQLインジェクションを防ぐため、SQLAlchemyなどのORMを使用し、プリペアドステートメントやパラメーター化されたクエリを利用します。\n\n### 5. レートリミット ⏱️\n\nレートリミットは、一定期間内のリクエスト数を制限することで、ブルートフォース攻撃やDoS（サービス拒否）攻撃からAPIを保護します。FastAPI自体にはこの機能は含まれていませんが、**fastapi-limiter**のようなサードパーティライブラリや、Redisなどのキャッシュシステムと組み合わせることで簡単に実装できます。","src/content/docs/fastapiガイド/04_上級・最適化/security.mdx","748b8209f160d0a7","fastapiガイド/04_上級最適化/パフォーマンスチューニング",{"id":541,"data":543,"body":547,"filePath":548,"digest":549,"deferredRender":16},{"title":328,"editUrl":16,"head":544,"template":18,"sidebar":545,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":546},{},"## FastAPIのパフォーマンスチューニング\n\nFastAPIはデフォルトで高いパフォーマンスを提供しますが、大規模なアプリケーションではさらなる最適化が不可欠です。ここでは、FastAPIのパフォーマンスを最大限に引き出すための主要なテクニックを解説します。\n\n### 1. 非同期処理の活用 ⚡\n\nFastAPIはPythonの**asyncio**ライブラリに基づいています。これにより、I/O処理（例: データベースアクセス、外部API呼び出し、ファイル操作）中にサーバーがブロックされることなく、複数のリクエストを同時に処理できます。この特性を活かすことが、パフォーマンスチューニングの鍵となります。\n\n- **async def と await の使い分け**:\n  - `async def`: データベースクエリやAPIリクエストなど、I/Oバウンドな処理を含む関数に適用します。\n  - `await`: `async def`関数内で、I/O処理の完了を待つ際に使用します。\n\n- **同期関数と非同期関数の混在**:\n  FastAPIは、同期関数（`def`）を自動的に別のスレッドプールで実行します。これにより、同期的な処理が他のリクエストをブロックするのを防ぎます。しかし、パフォーマンスを最大化するためには、可能な限り非同期処理に書き換えることが推奨されます。\n\n### 2. 依存性注入の活用 💉\n\nFastAPIの**依存性注入（DI）**システムは、データベース接続の管理や認証トークンの取得といった共通のタスクを効率化します。\n\n- **データベースセッションの管理**: リクエストごとに新しいデータベースセッションを開き、処理完了後に自動的に閉じるように依存性注入を設定することで、リソースリークを防ぎ、接続プールを効率的に利用できます。\n\n#### 例: データベースセッションの管理\n\n```python\n# db/database.py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./sql_app.db\"\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```\nこの`get_db`関数を`Depends`としてエンドポイントに注入することで、データベース管理のロジックを分離できます。\n\n### 3. キャッシュ戦略の導入 💾\n\n頻繁にアクセスされるが更新頻度の低いデータは、キャッシュを利用することでデータベースへのアクセスを減らし、応答時間を大幅に短縮できます。\n\n- **インメモリキャッシュ**: `lru_cache`デコレータなどを使用して、関数呼び出しの結果をキャッシュします。\n- **Redisなどの外部キャッシュ**: 大規模な分散システムでは、Redisなどのキーバリューストアをキャッシュとして利用します。`FastAPI-Cache`などのライブラリが便利です。\n\n### 4. 適切なWebサーバーの選択 🖥️\n\nFastAPIは**ASGI（Asynchronous Server Gateway Interface）**サーバー上で動作します。開発にはUvicornがよく使われますが、本番環境ではより堅牢なサーバーと組み合わせて利用することが推奨されます。\n\n- **Gunicorn + Uvicorn**: Gunicornはプロセス管理を、Uvicornは非同期ワーカーを担う構成です。これにより、複数のUvicornワーカープロセスを起動し、CPUコアを最大限に活用できます。\n\n### 5. データ検証の最適化 📊\n\nFastAPIはPydanticを使ってデータの自動検証を行いますが、大きなデータセットを扱う場合はこの検証プロセスがボトルネックになることがあります。\n\n- **スキーマの簡素化**: 不要なフィールドは定義しないようにします。\n- **response_modelの最適化**: 応答モデルには、クライアントに返す必要のある最小限のデータのみを含めるようにします。これにより、不必要なデータのシリアライズ処理を削減できます。","src/content/docs/fastapiガイド/04_上級・最適化/パフォーマンスチューニング.mdx","f62528a9b2be8059","fastapiガイド/02_基本/フォルダ構成",{"id":550,"data":552,"body":556,"filePath":557,"digest":558,"deferredRender":16},{"title":408,"editUrl":16,"head":553,"template":18,"sidebar":554,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":555},{},"## FastAPIの推奨フォルダ構成\n\nFastAPIには、Railsのような厳格なフォルダ構成の規約はありませんが、大規模なアプリケーションを開発する際には、役割ごとにファイルを分けることが推奨されています。これにより、コードの可読性、保守性、そして再利用性が向上します。\n\n### 一般的なフォルダ構成(APIモードの場合)\n\n```\n.\n├── app/\n│   ├── __init__.py           # Pythonパッケージとして認識させるための空ファイル\n│   ├── main.py               # アプリケーションのエントリーポイント\n│   ├── api/                  # APIエンドポイントを管理するディレクトリ\n│   │   ├── __init__.py\n│   │   ├── v1/               # APIのバージョン管理\n│   │   │   ├── __init__.py\n│   │   │   └── endpoints/    # 各エンドポイントの機能\n│   │   │       ├── users.py\n│   │   │       ├── items.py\n│   │   │       └── ...\n│   ├── core/                 # アプリケーションのコア設定\n│   │   ├── __init__.py\n│   │   ├── config.py         # 環境変数や設定ファイル\n│   │   └── security.py       # 認証・認可関連のロジック\n│   ├── db/                   # データベース関連のファイル\n│   │   ├── __init__.py\n│   │   ├── database.py       # データベース接続情報\n│   │   └── models.py         # SQLAlchemyなどのORMモデル\n│   ├── schemas/              # Pydanticモデル\n│   │   ├── __init__.py\n│   │   ├── user_schema.py\n│   │   └── item_schema.py\n│   └── crud/                 # CRUD (作成, 読み取り, 更新, 削除) ロジック\n│       ├── __init__.py\n│       ├── user_crud.py\n│       └── item_crud.py\n├── tests/                    # テストコード\n├── .env                      # 環境変数\n├── .gitignore\n├── Dockerfile                # Dockerコンテナの設定ファイル\n└── requirements.txt          # 依存関係\n```\n\n### 主要なフォルダの役割\n\n- **app/**: アプリケーションのメインコードが格納されるルートディレクトリです。\n- **app/main.py**: アプリケーションのエントリーポイントです。ここでFastAPI()インスタンスを初期化し、ルーターをインクルードします。\n- **app/api/**: APIエンドポイントを定義する場所です。\n- **app/api/v1/**: APIのバージョンを管理するためのディレクトリです。これにより、将来のバージョンアップにも対応しやすくなります。\n- **app/api/v1/endpoints/**: 各エンドポイント（例：users.py、items.py）をファイルごとに分割することで、コードの整理と管理がしやすくなります。\n- **app/core/**: アプリケーション全体で共有される設定やユーティリティを格納します。\n- **app/db/**: データベース接続やORMモデルなど、データベース関連のロジックを管理します。\n- **app/schemas/**: Pydanticモデルを定義する場所です。これにより、リクエストやレスポンスのデータのバリデーションとシリアライズが明確になります。\n- **app/crud/**: データベースに対するCRUD操作（作成、読み取り、更新、削除）のロジックを分離します。これにより、ビジネスロジック（エンドポイント）からデータベース操作を切り離し、再利用性を高めます。\n\nこれらのフォルダ構成はあくまで推奨例であり、プロジェクトの規模や要件に応じて柔軟に調整することが重要です。この構造を採用することで、小規模なプロジェクトから大規模なサービスまで、一貫性のある開発が可能になります。\n\n## 高度な開発テクニック\n\nFastAPIの強力な機能を活用することで、より効率的で高品質なアプリケーションを構築できます。\n\n### 1. ミドルウェア (Middleware) 🛡️\n\nミドルウェアは、すべてのリクエストやレスポンスに共通の処理を適用するためのレイヤーです。これにより、各エンドポイントに同じコードを繰り返し書く必要がなくなります。\n\n```py\n\u003C!-- app/core/middleware.py -->\nfrom fastapi.middleware.cors import CORSMiddleware\n\ndef add_cors_middleware(app):\n    \"\"\"\n    CORSミドルウェアをアプリケーションに追加\n    \"\"\"\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],            # 許可するオリジン (例: [\"http://localhost:3000\"])\n        allow_credentials=True,         # クッキーや認証情報を許可するか\n        allow_methods=[\"*\"],            # 許可するHTTPメソッド (例: [\"GET\", \"POST\"])\n        allow_headers=[\"*\"],            # 許可するHTTPヘッダー\n    )\n```\n\n```py\n\u003C!-- app/main.py -->\nfrom fastapi import FastAPI\nfrom app.core.middleware import add_cors_middleware\n\napp = FastAPI()\n\n# CORS ミドルウェアを追加\nadd_cors_middleware(app)\n```\n\n- **利用例**: アプリケーション全体の認証・認可、リクエスト/レスポンスのロギング、異なるオリジンからの通信を許可するCORS設定など。\n\n### 2. 依存性注入 (Dependency Injection) 💉\n\nFastAPIのDIシステムは、エンドポイント関数が必要とするオブジェクトやサービス（依存関係）を自動的に提供する仕組みです。\n\n- **利用例**: リクエストごとに自動で開閉されるデータベースセッションの取得や、認証済みユーザー情報の取得など、共通のサービスをシンプルに利用できます。これにより、コードの再利用性が高まり、テストも容易になります。\n\n```py\n\u003C!-- app/db/database.py -->\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\n\nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# データベースセッションを取得する関数\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```\n\n```py\n\u003C!-- app/api/v1/endpoints/users.py -->\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom app.db.database import get_db\nfrom app.schemas.user_schema import UserCreate, UserResponse\nfrom app.crud.user_crud import create_user_crud\n\nrouter = APIRouter()\n\n@router.post(\"/users/\", response_model=UserResponse)\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    db_user = create_user_crud(db, user)\n    if not db_user:\n        raise HTTPException(status_code=400, detail=\"User already exists\")\n    return db_user\n\n```\n***ポイント:***\n\nDepends(get_db) で自動的に DB セッションがビューに渡される\n\nモック化してテストする際も簡単に差し替え可能\n\n### 3. 非同期処理 (Async/Await) ⚡️\n\nFastAPIは、Pythonの**async/await構文**をネイティブにサポートしており、非同期処理を効率的に行えます。\n\n- **メリット**: 外部API呼び出しやDBアクセスといったI/O待ちが発生する処理を効率的に管理できます。これにより、サーバーが複数のリクエストを同時に処理できるようになり、パフォーマンスが大幅に向上します。\n\n#### 例: 外部APIを非同期で呼び出す\n```py\n\u003C!-- app/services/external_api.py -->\nimport httpx\n\nasync def fetch_data(url: str):\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        return response.json()\n```\n\n```py\n\u003C!-- app/api/v1/endpoints/items.py -->\nfrom fastapi import APIRouter\nfrom app.services.external_api import fetch_data\n\nrouter = APIRouter()\n\n@router.get(\"/items/\")\nasync def get_items():\n    data = await fetch_data(\"https://api.example.com/items\")\n    return {\"items\": data}\n```\n\n***ポイント:***\n\nasync def と await を使うことで、他のリクエストをブロックせずに処理可能\n\nDBアクセスや外部API呼び出しの多いサービスで特に有効","src/content/docs/fastapiガイド/02_基本/フォルダ構成.mdx","317d518085e0fe9a","fastapiガイド/05_学び記事/documentation",{"id":559,"data":561,"body":566,"filePath":567,"digest":568,"deferredRender":16},{"title":562,"editUrl":16,"head":563,"template":18,"sidebar":564,"pagefind":16,"draft":20},"FastAPIのドキュメントのカスタマイズ",[],{"hidden":20,"attrs":565},{},"FastAPIでのドキュメントのカスタマイズ方法を以下に示します。\n\n## OpenAPIのカスタマイズ\n\nFastAPIは、OpenAPIのカスタマイズをサポートしています。これにより、APIの仕様を詳細に定義し、ドキュメントを自動生成することができます。以下に、カスタムOpenAPIスキーマを定義する方法を示します。\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.openapi.utils import get_openapi\n\napp = FastAPI()\n\ndef custom_openapi():\n    if app.openapi_schema:\n        return app.openapi_schema\n    openapi_schema = get_openapi(\n        title=\"Custom title\",\n        version=\"2.5.0\",\n        description=\"This is a very custom OpenAPI schema\",\n        routes=app.routes,\n    )\n    app.openapi_schema = openapi_schema\n    return app.openapi_schema\n\napp.openapi = custom_openapi\n```\n\n- **`get_openapi`**: OpenAPIスキーマをカスタマイズします。これにより、APIのタイトル、バージョン、説明を自由に設定できます。\n\n### 使用例\n\nこのカスタマイズにより、APIドキュメントに独自のブランドや詳細な説明を追加することができます。例えば、APIのバージョンを明示することで、開発者が異なるバージョンのAPIを簡単に識別できるようになります。\n\n```","src/content/docs/fastapiガイド/05_学び記事/documentation.mdx","86bc0cbea467c4a2","fastapiガイド/05_学び記事/setup",{"id":569,"data":571,"body":576,"filePath":577,"digest":578,"deferredRender":16},{"title":572,"editUrl":16,"head":573,"template":18,"sidebar":574,"pagefind":16,"draft":20},"FastAPIの環境構築",[],{"label":427,"hidden":20,"attrs":575},{},"# FastAPIの環境構築\n\nFastAPIをインストールするには、以下の手順を実行します。まず、Pythonがインストールされていることを確認してください。Pythonがインストールされていない場合は、公式サイトからインストールしてください。\n\n## インストール\n\nFastAPIをインストールするには、以下の手順を実行します。まず、Pythonがインストールされていることを確認してください。Pythonがインストールされていない場合は、公式サイトからインストールしてください。\n\n### 仮想環境の作成\n\nプロジェクトごとに仮想環境を作成することをお勧めします。以下のコマンドで仮想環境を作成します。\n\n```bash\npython3 -m venv myenv\nsource myenv/bin/activate\n```\n\n仮想環境を使用することで、プロジェクトごとに依存関係を管理しやすくなります。\n\n### FastAPIとUvicornのインストール\n\n仮想環境がアクティブになった状態で、以下のコマンドを実行してFastAPIとUvicornをインストールします。\n\n```bash\npip install fastapi uvicorn\n```\n\nこのコマンドを実行することで、FastAPIとUvicornがインストールされます。インストールが完了したら、以下のコマンドでFastAPIのバージョンを確認できます。\n\n```bash\npip show fastapi\n```\n\n### 依存関係の管理\n\nプロジェクトの依存関係を管理するために、`requirements.txt`ファイルを作成し、以下のように記述します。\n\n```\nfastapi\nuvicorn\n```\n\nこのファイルを使用して、他の開発者が同じ環境を再現できるようにします。\n\n```bash\npip install -r requirements.txt\n```\n\nこれにより、プロジェクトのセットアップが簡単になります。\n\n# 基本構文\n\nFastAPIの基本的な構文を紹介します。\n\n## エンドポイントの定義\n\nFastAPIでは、エンドポイントを簡単に定義できます。以下に例を示します。\n\n```python\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"Hello\": \"World\"}\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: str = None):\n    if item_id == 0:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return {\"item_id\": item_id, \"q\": q}\n```\n\n## リクエストとレスポンス\n\nFastAPIは、リクエストとレスポンスの処理を簡単に行えます。以下に例を示します。\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    description: str = None\n    price: float\n    tax: float = None\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return item\n```\n\n## エラーハンドリング\n\nFastAPIでは、エラーハンドリングも簡単に行えます。以下に例を示します。\n\n```python\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id == 0:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return {\"item_id\": item_id}\n```\n\n# APIモード専用\n\nFastAPIを使用してAPIを開発する際の基本的な手順を紹介します。\n\n## APIの基本設定\n\nFastAPIを使用する際には、以下のように基本的な設定を行います。\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n```\n\n## サーバーの起動\n\nUvicornを使用してサーバーを起動します。以下のコマンドを実行します。\n\n```bash\nuvicorn main:app --reload\n```\n\n`--reload`オプションを指定することで、コードの変更を自動的に検知してサーバーを再起動します。\n\n## APIドキュメントの確認\n\nFastAPIは自動的にAPIドキュメントを生成します。サーバーが起動したら、`http://localhost:8000/docs`でSwagger UIを使用してAPIドキュメントを確認できます。\n\n# API開発のベストプラクティス\n\nFastAPIを使用してAPIを開発する際のベストプラクティスを以下に示します。\n\n## ドキュメントの自動生成\n\nFastAPIは、APIドキュメントを自動的に生成します。開発中に`http://localhost:8000/docs`でSwagger UIを使用してAPIドキュメントを確認し、エンドポイントの仕様を常に最新に保ちます。\n\n## バリデーションの活用\n\n`pydantic`を使用して、リクエストデータのバリデーションを行います。これにより、データの整合性を保ち、エラーを未然に防ぐことができます。\n\n```python\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str = None\n    price: float\n    tax: float = None\n```\n\n## 非同期処理の活用\n\nFastAPIは非同期処理をサポートしています。`async`/`await`を使用して、非同期に処理を行い、パフォーマンスを向上させます。\n\n```python\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n```\n\n## テストの自動化\n\nFastAPIアプリケーションのテスト自動化方法を以下に示します。\n\n## pytestを使用したテスト\n\n`pytest`を使用して、FastAPIアプリケーションのテストを自動化します。\n\n### インストール\n\nまず、`pytest`をインストールします。\n\n```bash\npip install pytest\n```\n\n### テストの実装\n\n以下に、FastAPIアプリケーションのテストの例を示します。\n\n```python\nfrom fastapi.testclient import TestClient\nfrom .main import app\n\nclient = TestClient(app)\n\ndef test_read_main():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello World\"}\n```\n\n- **`TestClient`**: FastAPIアプリケーションをテストするためのクライアントです。\n- **`assert`**: テストの期待値を確認します。\n\n### テストの実行\n\n以下のコマンドを実行して、テストを実行します。\n\n```bash\npytest\n```\n\n# 認証と認可の詳細\n\nFastAPIでの認証と認可の詳細な実装方法を以下に示します。\n\n## OAuth2による認証\n\nOAuth2を使用して、トークンベースの認証を実装します。\n\n```python\nfrom fastapi import FastAPI, Depends\nfrom fastapi.security import OAuth2PasswordBearer\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@app.get(\"/users/me\")\nasync def read_users_me(token: str = Depends(oauth2_scheme)):\n    return {\"token\": token}\n```\n\n## JWTによる認証\n\nJWT（JSON Web Token）を使用して、トークンベースの認証を実装します。\n\n```python\nfrom jose import JWTError, jwt\n\nSECRET_KEY = \"your_secret_key\"\nALGORITHM = \"HS256\"\n\n@app.post(\"/token\")\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    # ユーザー認証ロジック\n    access_token = jwt.encode({\"sub\": form_data.username}, SECRET_KEY, algorithm=ALGORITHM)\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n```\n\n## ユーザーロールと権限管理\n\nユーザーロールや権限を管理して、アクセス制御を行います。\n\n```python\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    # トークンのデコードとユーザーの取得\n    return user\n\n@app.get(\"/admin\")\nasync def read_admin_data(current_user: User = Depends(get_current_user)):\n    if current_user.role != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Not enough permissions\")\n    return {\"admin_data\": \"...\"}\n```\n\n# セキュリティと認証\n\nFastAPIでのセキュリティ対策や認証の実装方法を以下に示します。\n\n## OAuth2による認証\n\nFastAPIは、OAuth2を使用した認証をサポートしています。以下に、OAuth2を使用した認証の例を示します。\n\n```python\nfrom fastapi import FastAPI, Depends\nfrom fastapi.security import OAuth2PasswordBearer\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@app.get(\"/users/me\")\nasync def read_users_me(token: str = Depends(oauth2_scheme)):\n    return {\"token\": token}\n```\n\n## JWTによる認証\n\nJWT（JSON Web Token）を使用して、トークンベースの認証を実装します。以下に、JWTを使用した認証の例を示します。\n\n```python\nfrom jose import JWTError, jwt\n\nSECRET_KEY = \"your_secret_key\"\nALGORITHM = \"HS256\"\n\n@app.post(\"/token\")\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    # ユーザー認証ロジック\n    access_token = jwt.encode({\"sub\": form_data.username}, SECRET_KEY, algorithm=ALGORITHM)\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n```\n\n## セキュリティヘッダーの設定\n\nCORS（Cross-Origin Resource Sharing）を設定して、セキュリティを強化します。\n\n```python\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://example.com\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n```\n\n- **`allow_origins`**: 許可するオリジンを指定します。\n\n## CSRF対策\n\nCSRF（Cross-Site Request Forgery）対策を実装します。\n\n```python\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.middleware(\"http\")\nasync def csrf_protect(request: Request, call_next):\n    if request.method == \"POST\":\n        token = request.headers.get(\"X-CSRF-Token\")\n        if not token or token != \"expected_token\":\n            return JSONResponse(status_code=403, content={\"detail\": \"CSRF token missing or incorrect\"})\n    response = await call_next(request)\n    return response\n```\n\n## セキュリティヘッダーの設定\n\nセキュリティヘッダーを設定して、セキュリティを強化します。\n\n```python\n@app.middleware(\"http\")\nasync def add_security_headers(request: Request, call_next):\n    response = await call_next(request)\n    response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response.headers[\"X-Frame-Options\"] = \"DENY\"\n    return response\n```\n\n# デプロイメント\n\nFastAPIアプリケーションのデプロイメント方法を以下に示します。\n\n## Dockerを使用したデプロイメント\n\nDockerを使用して、FastAPIアプリケーションをコンテナ化し、デプロイします。\n\n### Dockerfileの作成\n\n以下の内容で`Dockerfile`を作成します。\n\n```dockerfile\nFROM python:3.9\n\nWORKDIR /app\n\nCOPY . /app\n\nRUN pip install --no-cache-dir -r requirements.txt\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"]\n```\n\n### Dockerイメージのビルド\n\n以下のコマンドを実行して、Dockerイメージをビルドします。\n\n```bash\ndocker build -t myfastapiapp .\n```\n\n### Dockerコンテナの起動\n\n以下のコマンドを実行して、Dockerコンテナを起動します。\n\n```bash\ndocker run -d --name myfastapiapp -p 80:80 myfastapiapp\n```\n\n## クラウドサービスへのデプロイ\n\nFastAPIアプリケーションをAWS、GCP、Azureなどのクラウドサービスにデプロイすることも可能です。各クラウドサービスのドキュメントを参照して、適切な手順でデプロイを行います。\n\n# 高度なルーティング\n\nFastAPIでの高度なルーティングの設定方法を以下に示します。\n\n## パスパラメータ\n\nパスパラメータを使用して、動的なルートを定義します。\n\n```python\n@app.get(\"/users/{user_id}\")\nasync def read_user(user_id: int):\n    return {\"user_id\": user_id}\n```\n\n- **`{user_id}`**: パスパラメータとして定義され、エンドポイントに渡されます。\n\n## クエリパラメータ\n\nクエリパラメータを使用して、リクエストに追加の情報を渡します。\n\n```python\n@app.get(\"/items/\")\nasync def read_items(q: str = None):\n    return {\"q\": q}\n```\n\n- **`q: str = None`**: クエリパラメータとして定義され、オプションでリクエストに含めることができます。\n\n## パスオペレーションの設定\n\nパスオペレーションに追加の設定を行い、詳細なルーティングを実現します。\n\n```python\n@app.get(\"/items/{item_id}\", response_model=Item)\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n```\n\n- **`response_model=Item`**: レスポンスモデルを指定し、返されるデータの型を定義します。\n\n# ミドルウェアの活用\n\nFastAPIでのミドルウェアの設定方法を以下に示します。\n\n## ミドルウェアの追加\n\nミドルウェアを使用して、リクエストの前処理や後処理を行います。\n\n```python\nfrom fastapi import FastAPI\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\napp = FastAPI()\n\nclass SimpleMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request, call_next):\n        # リクエストの前処理\n        response = await call_next(request)\n        # レスポンスの後処理\n        return response\n\napp.add_middleware(SimpleMiddleware)\n```\n\n- **`BaseHTTPMiddleware`**: ミドルウェアを作成するための基底クラスです。\n- **`dispatch`**: リクエストとレスポンスの処理を行うメソッドです。\n\n## ログ記録の実装\n\nリクエストとレスポンスのログを記録するミドルウェアを実装します。\n\n```python\nimport logging\n\nlogger = logging.getLogger(\"uvicorn\")\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request, call_next):\n        logger.info(f\"Request: {request.method} {request.url}\")\n        response = await call_next(request)\n        logger.info(f\"Response: {response.status_code}\")\n        return response\n\napp.add_middleware(LoggingMiddleware)\n```\n\n# バックグラウンドタスク\n\nFastAPIでのバックグラウンドタスクの実装方法を以下に示します。\n\n## バックグラウンドタスクの追加\n\nバックグラウンドタスクを使用して、リクエストの処理後に非同期でタスクを実行します。\n\n```python\nfrom fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\ndef write_log(message: str):\n    with open(\"log.txt\", mode=\"a\") as log:\n        log.write(message + \"\\n\")\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_log, f\"Notification sent to {email}\")\n    return {\"message\": \"Notification sent\"}\n```\n\n- **`BackgroundTasks`**: バックグラウンドタスクを管理するためのクラスです。\n- **`add_task`**: バックグラウンドで実行するタスクを追加します。\n\n## 非同期タスクの管理\n\nバックグラウンドタスクを使用して、非同期にタスクを管理します。これにより、リクエストの応答を待たずにタスクを実行できます。\n\n# WebSocketの使用\n\nFastAPIでのWebSocketの使用方法を以下に示します。\n\n## WebSocketの基本設定\n\nWebSocketを使用して、リアルタイム通信を実現します。\n\n```python\nfrom fastapi import FastAPI, WebSocket\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Message text was: {data}\")\n```\n\n- **`WebSocket`**: WebSocket接続を管理するためのクラスです。\n- **`accept`**: クライアントからの接続を受け入れます。\n- **`receive_text`**: クライアントからのメッセージを受信します。\n- **`send_text`**: クライアントにメッセージを送信します。\n\n## リアルタイム通信の実装\n\nWebSocketを使用して、リアルタイムでデータを送受信します。これにより、チャットアプリケーションや通知システムなどを実現できます。\n\n# リアルタイムデータ処理\n\nFastAPIでのリアルタイムデータ処理の実装方法を以下に示します。\n\n## WebSocketを使用したリアルタイムデータのストリーミング\n\nWebSocketを使用して、リアルタイムでデータをストリーミングします。\n\n```python\nfrom fastapi import FastAPI, WebSocket\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Message text was: {data}\")\n```\n\n- **`WebSocket`**: WebSocket接続を管理するためのクラスです。\n- **`accept`**: クライアントからの接続を受け入れます。\n- **`receive_text`**: クライアントからのメッセージを受信します。\n- **`send_text`**: クライアントにメッセージを送信します。\n\n## リアルタイムデータ処理の実装\n\nWebSocketを使用して、リアルタイムでデータを送受信します。これにより、チャットアプリケーションや通知システムなどを実現できます。\n\n# データベースとの連携\n\nFastAPIでのデータベースとの連携方法を以下に示します。\n\n## SQLAlchemyを使用したデータベース操作\n\nSQLAlchemyを使用して、データベースと連携します。\n\n### インストール\n\nまず、SQLAlchemyをインストールします。\n\n```bash\npip install sqlalchemy\n```\n\n### データベースモデルの定義\n\n```python\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"sqlite:///./test.db\"\n\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, index=True)\n    email = Column(String, unique=True, index=True)\n```\n\n### データベース操作\n\n```python\nfrom sqlalchemy.orm import Session\n\n# ユーザーの作成\nasync def create_user(db: Session, user: User):\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    return user\n```\n\n## Tortoise ORMを使用したデータベース操作\n\nTortoise ORMを使用して、非同期でデータベースと連携します。\n\n### インストール\n\n```bash\npip install tortoise-orm\n```\n\n### データベースモデルの定義\n\n```python\nfrom tortoise import fields, Tortoise, run_async\nfrom tortoise.models import Model\n\nclass User(Model):\n    id = fields.IntField(pk=True)\n    name = fields.CharField(max_length=50)\n    email = fields.CharField(max_length=50, unique=True)\n\nasync def init():\n    await Tortoise.init(\n        db_url='sqlite://db.sqlite3',\n        modules={'models': ['__main__']}\n    )\n    await Tortoise.generate_schemas()\n\nrun_async(init())\n```\n\n# パフォーマンスの最適化\n\nFastAPIアプリケーションのパフォーマンス最適化方法を以下に示します。\n\n## キャッシュの活用\n\nキャッシュを使用して、データの取得を高速化します。`fastapi-cache`を使用して、キャッシュを実装します。\n\n### インストール\n\n```bash\npip install fastapi-cache\n```\n\n### キャッシュの設定\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi_cache import FastAPICache\nfrom fastapi_cache.backends.inmemory import InMemoryBackend\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    FastAPICache.init(InMemoryBackend())\n\n@app.get(\"/items/{item_id}\")\n@FastAPICache(expire=60)\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n```\n\n- **`FastAPICache`**: キャッシュを管理するためのクラスです。\n- **`InMemoryBackend`**: メモリ内キャッシュを使用します。\n\n## 非同期処理の最適化\n\n非同期処理を最適化して、パフォーマンスを向上させます。`async`/`await`を使用して、非同期に処理を行います。\n\n```python\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n```\n\n# 非同期タスクのスケジューリング\n\nFastAPIでの非同期タスクのスケジューリング方法を以下に示します。\n\n## APSchedulerを使用したタスクスケジューリング\n\n`APScheduler`を使用して、定期的に非同期タスクを実行します。\n\n### インストール\n\n```bash\npip install apscheduler\n```\n\n### タスクの定義とスケジューリング\n\n```python\nfrom fastapi import FastAPI\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.triggers.interval import IntervalTrigger\n\napp = FastAPI()\nscheduler = AsyncIOScheduler()\n\nasync def scheduled_task():\n    print(\"Task executed\")\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    scheduler.add_job(scheduled_task, IntervalTrigger(seconds=10))\n    scheduler.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    scheduler.shutdown()\n```\n\n- **`AsyncIOScheduler`**: 非同期タスクをスケジュールするためのスケジューラです。\n- **`IntervalTrigger`**: タスクを定期的に実行するためのトリガーです。\n\n# 国際化とローカライゼーション\n\nFastAPIでの国際化とローカライゼーションの実装方法を以下に示します。\n\n## 多言語対応の設定\n\n`fastapi-i18n`を使用して、多言語対応を実現します。\n\n### インストール\n\n```bash\npip install fastapi-i18n\n```\n\n### 設定ファイルの作成\n\n`locales`ディレクトリに、各言語の翻訳ファイルを作成します。\n\n```\nlocales/\n  en.json\n  ja.json\n```\n\n### 翻訳ファイルの例\n\n`en.json`:\n\n```json\n{\n  \"greeting\": \"Hello\"\n}\n```\n\n`ja.json`:\n\n```json\n{\n  \"greeting\": \"こんにちは\"\n}\n```\n\n### 国際化の設定\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi_i18n import I18nMiddleware\n\napp = FastAPI()\n\napp.add_middleware(I18nMiddleware, default_locale=\"en\", locales_dir=\"locales\")\n\n@app.get(\"/greet\")\nasync def greet():\n    return {\"message\": app.i18n.t(\"greeting\")}\n```\n\n- **`I18nMiddleware`**: 国際化を管理するためのミドルウェアです。\n- **`t`**: 翻訳キーを使用して、翻訳されたメッセージを取得します。\n\n# APIバージョニング\n\nFastAPIでのAPIバージョニングの実装方法を以下に示します。\n\n## バージョン管理のベストプラクティス\n\nAPIのバージョン管理を行うことで、後方互換性を保ちながら新機能を追加できます。\n\n### パスベースのバージョニング\n\nURLパスにバージョン番号を含める方法です。\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/v1/items/{item_id}\")\nasync def read_item_v1(item_id: int):\n    return {\"item_id\": item_id, \"version\": \"v1\"}\n\n@app.get(\"/v2/items/{item_id}\")\nasync def read_item_v2(item_id: int):\n    return {\"item_id\": item_id, \"version\": \"v2\"}\n```\n\n### ヘッダーベースのバージョニング\n\nHTTPヘッダーにバージョン情報を含める方法です。\n\n```python\nfrom fastapi import FastAPI, Header, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, accept_version: str = Header(None)):\n    if accept_version == \"v1\":\n        return {\"item_id\": item_id, \"version\": \"v1\"}\n    elif accept_version == \"v2\":\n        return {\"item_id\": item_id, \"version\": \"v2\"}\n    else:\n        raise HTTPException(status_code=400, detail=\"Invalid API version\")\n```\n\n# エラーハンドリングの拡張\n\nFastAPIでのエラーハンドリングの拡張方法を以下に示します。\n\n## カスタムエラーハンドラー\n\nカスタムエラーハンドラーを実装して、特定のエラーに対するカスタムレスポンスを返します。\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.exception_handler(HTTPException)\nasync def custom_http_exception_handler(request, exc):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": f\"Oops! {exc.detail}\"},\n    )\n```\n\n## ログの記録\n\nエラー発生時にログを記録して、デバッグを容易にします。\n\n```python\nimport logging\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n@app.exception_handler(Exception)\nasync def generic_exception_handler(request, exc):\n    logger.error(f\"Unexpected error: {exc}\")\n    return JSONResponse(\n        status_code=500,\n        content={\"message\": \"Internal Server Error\"},\n    )\n```\n\n# ドキュメントのカスタマイズ\n\nFastAPIの自動生成ドキュメントのカスタマイズ方法を以下に示します。\n\n## OpenAPI仕様の拡張\n\nOpenAPI仕様を拡張して、APIドキュメントをカスタマイズします。\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.openapi.utils import get_openapi\n\napp = FastAPI()\n\ndef custom_openapi():\n    if app.openapi_schema:\n        return app.openapi_schema\n    openapi_schema = get_openapi(\n        title=\"Custom title\",\n        version=\"2.5.0\",\n        description=\"This is a very custom OpenAPI schema\",\n        routes=app.routes,\n    )\n    app.openapi_schema = openapi_schema\n    return app.openapi_schema\n\napp.openapi = custom_openapi\n```\n\n## Swagger UIのカスタマイズ\n\nSwagger UIをカスタマイズして、APIドキュメントの外観を変更します。\n\n```python\nfrom fastapi.openapi.docs import get_swagger_ui_html\n\n@app.get(\"/docs\", include_in_schema=False)\nasync def custom_swagger_ui_html():\n    return get_swagger_ui_html(\n        openapi_url=app.openapi_url,\n        title=app.title + \" - Custom Docs\",\n        swagger_favicon_url=\"https://example.com/favicon.ico\"\n    )\n```\n\n- **`get_swagger_ui_html`**: Swagger UIのHTMLを生成するための関数です。\n\n# ファイルアップロードとダウンロード\n\nFastAPIでのファイルアップロードとダウンロードの実装方法を以下に示します。\n\n## ファイルアップロード\n\nファイルをアップロードするためのエンドポイントを定義します。\n\n```python\nfrom fastapi import FastAPI, File, UploadFile\n\napp = FastAPI()\n\n@app.post(\"/uploadfile/\")\nasync def create_upload_file(file: UploadFile = File(...)):\n    return {\"filename\": file.filename}\n```\n\n- **`UploadFile`**: アップロードされたファイルを表すクラスです。\n- **`File`**: ファイルをアップロードするための依存関係を定義します。\n\n## ファイルダウンロード\n\nファイルをダウンロードするためのエンドポイントを定義します。\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.responses import FileResponse\n\napp = FastAPI()\n\n@app.get(\"/downloadfile/{file_path}\")\nasync def download_file(file_path: str):\n    return FileResponse(path=file_path, filename=\"downloaded_file.txt\")\n```\n\n- **`FileResponse`**: ファイルをレスポンスとして返すためのクラスです。\n\n# APIゲートウェイの設定\n\nFastAPIをAPIゲートウェイとして使用する方法を以下に示します。\n\n## 複数のマイクロサービスを統合\n\nFastAPIを使用して、複数のマイクロサービスを統合し、APIゲートウェイとして機能させます。\n\n### ルーティングの設定\n\n各マイクロサービスへのルーティングを設定します。\n\n```python\nfrom fastapi import FastAPI, Request\nimport httpx\n\napp = FastAPI()\n\n@app.api_route(\"/service1/{path:path}\", methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"])\nasync def proxy_service1(request: Request, path: str):\n    url = f\"http://service1/{path}\"\n    async with httpx.AsyncClient() as client:\n        response = await client.request(\n            method=request.method,\n            url=url,\n            headers=request.headers,\n            content=await request.body()\n        )\n    return response\n```\n\n- **`httpx.AsyncClient`**: 非同期HTTPクライアントを使用して、他のサービスにリクエストを転送します。\n\n## APIゲートウェイの利点\n\n- **セキュリティの強化**: APIゲートウェイを通じて、セキュリティポリシーを一元管理します。\n- **負荷分散**: リクエストを複数のサービスに分散させ、負荷を軽減します。\n- **監視とロギング**: APIゲートウェイを通じて、リクエストの監視とロギングを行います。\n\n# デプロイメントのベストプラクティス\n\nFastAPIアプリケーションのデプロイメントにおけるベストプラクティスを以下に示します。\n\n## コンテナ化\n\nDockerを使用して、FastAPIアプリケーションをコンテナ化し、移植性を向上させます。\n\n### Dockerfileの作成\n\n以下の内容で`Dockerfile`を作成します。\n\n```dockerfile\nFROM python:3.9\n\nWORKDIR /app\n\nCOPY . /app\n\nRUN pip install --no-cache-dir -r requirements.txt\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"]\n```\n\n## CI/CDパイプラインの構築\n\nGitHub Actionsを使用して、CI/CDパイプラインを構築し、自動デプロイを実現します。\n\n### GitHub Actionsの設定\n\n以下の内容で`.github/workflows/deploy.yml`を作成します。\n\n```yaml\nname: Deploy\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.9'\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n    - name: Build and push Docker image\n      run: |\n        docker build -t myfastapiapp .\n        docker push myfastapiapp\n```\n\n- **`Docker`**: アプリケーションをコンテナ化して、どこでも動作するようにします。\n- **`GitHub Actions`**: CI/CDパイプラインを構築して、自動デプロイを実現します。\n\n# モニタリングとロギング\n\nFastAPIアプリケーションのモニタリングとロギングの設定方法を以下に示します。\n\n## PrometheusとGrafanaを使用したモニタリング\n\nPrometheusとGrafanaを使用して、アプリケーションのパフォーマンスをモニタリングします。\n\n### Prometheusの設定\n\nPrometheusを使用して、メトリクスを収集します。\n\n```yaml\n# prometheus.yml\nscrape_configs:\n  - job_name: 'fastapi'\n    static_configs:\n      - targets: ['localhost:8000']\n```\n\n### Grafanaの設定\n\nGrafanaを使用して、メトリクスを可視化します。Prometheusをデータソースとして追加し、ダッシュボードを作成します。\n\n## ロギングの設定\n\nPythonの`logging`モジュールを使用して、アプリケーションのログを記録します。\n\n```python\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"uvicorn\")\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    logger.info(f\"Fetching item with id: {item_id}\")\n    return {\"item_id\": item_id}\n```\n\n- **`logging`**: アプリケーションの動作を記録し、デバッグや監視に役立てます。\n\n# スケーラビリティの向上\n\nFastAPIアプリケーションのスケーラビリティを向上させるための方法を以下に示します。\n\n## クラウドサービスを利用したスケーリング\n\nAWS、GCP、Azureなどのクラウドサービスを利用して、アプリケーションをスケーリングします。\n\n### AWS Elastic Beanstalk\n\nAWS Elastic Beanstalkを使用して、アプリケーションを自動スケーリングします。\n\n```bash\n# Elastic Beanstalk CLIを使用してデプロイ\neb init -p python-3.9 my-fastapi-app\neb create my-fastapi-env\n```\n\n### GCP App Engine\n\nGCP App Engineを使用して、アプリケーションをスケーリングします。\n\n```bash\n# app.yamlを作成してデプロイ\nruntime: python39\n\n# デプロイ\ngcloud app deploy\n```\n\n## コンテナオーケストレーション\n\nKubernetesを使用して、コンテナ化されたアプリケーションをオーケストレーションします。\n\n### Kubernetesの設定\n\nKubernetesを使用して、アプリケーションをスケーリングします。\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: fastapi-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: fastapi\n  template:\n    metadata:\n      labels:\n        app: fastapi\n    spec:\n      containers:\n      - name: fastapi\n        image: myfastapiapp\n        ports:\n        - containerPort: 80\n```\n\n- **`replicas`**: アプリケーションのインスタンス数を指定して、スケーリングを行います。\n\n# カスタムミドルウェアの作成\n\nFastAPIでのカスタムミドルウェアの作成方法を以下に示します。\n\n## カスタムミドルウェアの実装\n\nリクエストの前処理や後処理を行うカスタムミドルウェアを作成します。\n\n```python\nfrom fastapi import FastAPI, Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\napp = FastAPI()\n\nclass CustomMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        # リクエストの前処理\n        response = await call_next(request)\n        # レスポンスの後処理\n        return response\n\napp.add_middleware(CustomMiddleware)\n```\n\n- **`BaseHTTPMiddleware`**: ミドルウェアを作成するための基底クラスです。\n- **`dispatch`**: リクエストとレスポンスの処理を行うメソッドです。\n\n## ミドルウェアの活用例\n\n- **ログ記録**: リクエストとレスポンスのログを記録します。\n- **認証**: リクエストの認証を行います。\n- **キャッシュ**: レスポンスをキャッシュして、パフォーマンスを向上させます。\n\n# セキュリティ強化の詳細\n\nFastAPIでのセキュリティ強化方法をさらに詳しく解説します。\n\n## JWTによる認証\n\nFastAPIは、JWT（JSON Web Token）を使用した認証をサポートしています。\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\n\napp = FastAPI()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nSECRET_KEY = \"your_secret_key\"\nALGORITHM = \"HS256\"\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n        return username\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n```\n\n# APIバージョニングの詳細\n\nFastAPIでのAPIバージョニング方法をさらに詳しく解説します。\n\n## バージョン付きエンドポイント\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/api/v1/items/\")\nasync def read_items_v1():\n    return {\"version\": \"v1\"}\n\n@app.get(\"/api/v2/items/\")\nasync def read_items_v2():\n    return {\"version\": \"v2\"}\n```\n\n# エラーハンドリングの拡張の詳細\n\nFastAPIでのエラーハンドリングの拡張方法をさらに詳しく解説します。\n\n## カスタムエラーハンドラーの詳細\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.exception_handler(HTTPException)\nasync def custom_http_exception_handler(request, exc):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": f\"Oops! {exc.detail}\"},\n    )\n```\n\n# ドキュメントのカスタマイズの詳細\n\nFastAPIでのドキュメントのカスタマイズ方法をさらに詳しく解説します。\n\n## OpenAPIのカスタマイズの詳細\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.openapi.utils import get_openapi\n\napp = FastAPI()\n\ndef custom_openapi():\n    if app.openapi_schema:\n        return app.openapi_schema\n    openapi_schema = get_openapi(\n        title=\"Custom title\",\n        version=\"2.5.0\",\n        description=\"This is a very custom OpenAPI schema\",\n        routes=app.routes,\n    )\n    app.openapi_schema = openapi_schema\n    return app.openapi_schema\n\napp.openapi = custom_openapi\n```","src/content/docs/fastapiガイド/05_学び記事/setup.mdx","0d5d37278d49fc00","jestガイド/01_はじめに/01_install",{"id":579,"data":581,"body":586,"filePath":587,"digest":588,"deferredRender":16},{"title":582,"editUrl":16,"head":583,"template":18,"sidebar":584,"pagefind":16,"draft":20},"Jestのインストール",[],{"hidden":20,"attrs":585},{},"## Jestのインストールとセットアップ\nJestは、特にReact環境で広く使われるJavaScriptのテストフレームワークです。ViteやNext.jsなどの環境では、トランスパイル設定が異なるため、それぞれの環境に合わせた追加設定が必要です。\n\n### 1. Jestのコアライブラリをインストールする 📦\nまず、jestと、テスト中にDOMをシミュレートするためのjsdomを開発用依存関係としてインストールします。\n\n```bash\nnpm install --save-dev jest jest-environment-jsdom\n```\n\n### 2. package.jsonにテストスクリプトを追加する ⚙️\nテストを簡単に実行できるように、package.jsonファイルに\"test\"スクリプトを追加します。\n\n```json\n\"scripts\": {\n  \"test\": \"jest\"\n}\n```\n\nこれで、ターミナルで`npm test`と入力するだけでJestを実行できます。\n\n## ViteでのJestセットアップ\nViteはESモジュール（ESM）をネイティブにサポートしていますが、Jestは通常CommonJS環境で動作します。そのため、JestにESMを扱えるように設定する必要があります。\n\n### 1. 依存ライブラリのインストール 🧩\nESMとJSX（React）をサポートするために、以下のライブラリをインストールします。\n\n```bash\nnpm install --save-dev @babel/core @babel/preset-env @babel/preset-react\n```\n\n- **@babel/core**: JavaScriptのトランスパイルに必要です。\n- **@babel/preset-env**: 最新のJavaScript構文をJestが理解できる古い構文に変換します。\n- **@babel/preset-react**: JSXをJavaScriptに変換します。\n\n### 2. Babelの設定ファイルを作成する 📝\nプロジェクトのルートに`.babelrc`ファイルを作成し、先ほどインストールしたプリセットを設定します。これにより、JestはReactコンポーネントを正しく処理できるようになります。\n\n```json\n// .babelrc\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n```\n\n### 3. Jestの設定ファイルを更新する 🛠️\n`jest.config.js`ファイルを作成し、テストファイルがどこにあるか、どのような環境で実行するかなどを設定します。Vite環境では、特にESMをトランスパイルする設定が重要です。\n\n```javascript\n// jest.config.js\nmodule.exports = {\n  // テスト環境をjsdomに設定\n  testEnvironment: 'jest-environment-jsdom',\n  // テストファイルの検索パターン\n  testMatch: [\"**/__tests__/**/*.js?(x)\", \"**/?(*.)+(spec|test).js?(x)\"],\n  // ESモジュールをCommonJSに変換\n  transform: {\n    \"^.+\\\\.(js|jsx)$\": \"babel-jest\",\n  },\n  // テスト対象外のディレクトリ\n  transformIgnorePatterns: [\n    \"/node_modules/\",\n  ],\n  // モジュール解決エイリアスの設定（Viteの設定と一致させる）\n  moduleNameMapper: {\n    '^@/(.*)$': '\u003CrootDir>/src/$1',\n  },\n};\n```\n\nこれで、ViteプロジェクトでJestが動作するようになります。\n\n## Next.jsでのJestセットアップ\nNext.jsには、組み込みのBabel設定があるため、Jestの設定が比較的シンプルです。`next/jest`パッケージがJestとNext.jsの連携を自動的に処理してくれます。\n\n### 1. 依存ライブラリのインストール 🧩\nNext.js環境でJestを動かすために、以下のライブラリをインストールします。\n\n```bash\nnpm install --save-dev jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom\n```\n\n- **@testing-library/react**: コンポーネントのテストをより簡単にします。\n- **@testing-library/jest-dom**: Jestに便利なDOMマッチャーを追加します。\n\n### 2. Jest設定ファイルを生成する 📝\nNext.jsプロジェクトのルートで以下のコマンドを実行します。これにより、Jestの設定ファイルが自動的に生成されます。\n\n```bash\nnpx jest --init\n```\n\n### 3. 設定ファイルを調整する 🛠️\n生成された`jest.config.js`を編集し、`next/jest`パッケージを使ってNext.jsの機能をJestで有効にします。\n\n```javascript\n// jest.config.js\nconst nextJest = require('next/jest');\n\n// next.config.jsから設定を読み込む\nconst createJestConfig = nextJest({\n  dir: './',\n});\n\n// Jestの設定を追加\nconst customJestConfig = {\n  setupFilesAfterEnv: ['\u003CrootDir>/jest.setup.js'],\n  moduleDirectories: ['node_modules', '\u003CrootDir>/'],\n  testEnvironment: 'jest-environment-jsdom',\n};\n\nmodule.exports = createJestConfig(customJestConfig);\n```\n\n### 4. jest.setup.jsファイルを作成する 📄\n`@testing-library/jest-dom`の機能を有効にするために、ルートに`jest.setup.js`ファイルを作成します。\n\n```javascript\n// jest.setup.js\nimport '@testing-library/jest-dom/extend-expect';\n```\n\nこれにより、JestはNext.jsの環境でシームレスに動作し、Reactコンポーネントを簡単にテストできるようになります。","src/content/docs/jestガイド/01_はじめに/01_install.mdx","bd58f266beb96912","flutterガイド/04_上級最適化/パフォーマンスチューニング",{"id":589,"data":591,"body":595,"filePath":596,"digest":597,"deferredRender":16},{"title":58,"editUrl":16,"head":592,"template":18,"sidebar":593,"pagefind":16,"draft":20},[],{"label":58,"hidden":20,"attrs":594},{},"# アニメーションの詳細\n\nFlutterでのアニメーションの実装方法を以下に示します。\n\n## AnimationControllerを使用したアニメーション\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyAnimatedWidget extends StatefulWidget {\n  @override\n  _MyAnimatedWidgetState createState() => _MyAnimatedWidgetState();\n}\n\nclass _MyAnimatedWidgetState extends State\u003CMyAnimatedWidget> with SingleTickerProviderStateMixin {\n  AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 2),\n      vsync: this,\n    )..repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: _controller,\n      child: const Text('Hello Flutter'),\n    );\n  }\n}\n```\n\n# パフォーマンス最適化\n\nFlutterアプリケーションのパフォーマンス最適化方法を以下に示します。\n\n## Widgetの再構築を最小限に抑える\n\n`const`コンストラクタを使用して、Widgetの再構築を最小限に抑えます。\n\n```dart\nconst Text('Hello Flutter');\n```\n\n## リストのパフォーマンス最適化\n\n`ListView.builder`を使用して、大量のデータを効率的に表示します。\n\n```dart\nListView.builder(\n  itemCount: 1000,\n  itemBuilder: (context, index) {\n    return ListTile(\n      title: Text('Item $index'),\n    );\n  },\n);\n```\n\n## 画像の最適化\n\n`CachedNetworkImage`を使用して、画像のキャッシュを行い、ネットワーク負荷を軽減します。\n\n```dart\nCachedNetworkImage(\n  imageUrl: 'https://example.com/image.jpg',\n  placeholder: (context, url) => CircularProgressIndicator(),\n  errorWidget: (context, url, error) => Icon(Icons.error),\n);\n```\n\n## アニメーションの最適化\n\n`AnimatedBuilder`を使用して、アニメーションのパフォーマンスを向上させます。\n\n```dart\nAnimatedBuilder(\n  animation: _controller,\n  builder: (context, child) {\n    return Transform.rotate(\n      angle: _controller.value * 2.0 * pi,\n      child: child,\n    );\n  },\n  child: const Icon(Icons.star),\n);\n```\n\n## プロファイリング\n\nFlutter DevToolsを使用して、アプリケーションのパフォーマンスをプロファイリングします。\n\n```bash\nflutter pub global activate devtools\nflutter pub global run devtools\n```\n\n# データ管理\n\nFlutterでのデータ管理方法を以下に示します。\n\n## sqfliteを使用したローカルデータベース\n\n```dart\nimport 'package:sqflite/sqflite.dart';\n\nFuture\u003Cvoid> insertData(Database db) async {\n  await db.insert(\n    'my_table',\n    {'column1': 'value1', 'column2': 'value2'},\n    conflictAlgorithm: ConflictAlgorithm.replace,\n  );\n}\n```\n\n# テストの詳細\n\nFlutterアプリケーションのテスト方法を以下に示します。\n\n## Widgetテスト\n\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/main.dart';\n\nvoid main() {\n  testWidgets('MyWidget has a title and message', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    final titleFinder = find.text('T');\n    final messageFinder = find.text('M');\n\n    expect(titleFinder, findsOneWidget);\n    expect(messageFinder, findsOneWidget);\n  });\n}\n```","src/content/docs/flutterガイド/04_上級・最適化/パフォーマンスチューニング.mdx","3dfa425ab1367d35","jestガイド/02_基本/環境構築",{"id":598,"data":600,"body":605,"filePath":606,"digest":607,"deferredRender":16},{"title":601,"editUrl":16,"head":602,"template":18,"sidebar":603,"pagefind":16,"draft":20},"Jestの基本",[],{"hidden":20,"attrs":604},{},"このセクションでは、Jestを使用した基本的なテストの書き方と環境構築について説明します。\n\n## 環境構築\n\nJestを使用するための環境を構築します。以下の手順に従ってください。\n\n1. **プロジェクトの初期化**\n   - 新しいプロジェクトを作成し、`npm init`を実行して`package.json`を生成します。\n\n2. **Jestのインストール**\n   - すでにインストール済みの場合はスキップしてください。\n   - ```bash\n     npm install --save-dev jest\n     ```\n\n3. **テストディレクトリの作成**\n   - `tests`ディレクトリを作成し、テストファイルを配置します。\n\n## 基本的なテストの書き方\n\nJestを使用して基本的なテストを作成します。以下は簡単な例です。\n\n```javascript\n// sum.js\nfunction sum(a, b) {\n  return a + b;\n}\nmodule.exports = sum;\n\n// sum.test.js\nconst sum = require('./sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n```\n\nこの例では、`sum`関数が正しく動作することを確認するテストを作成しています。","src/content/docs/jestガイド/02_基本/環境構築.mdx","c126af09f197308b","jestガイド/03_中級/api利用法",{"id":608,"data":610,"body":615,"filePath":616,"digest":617,"deferredRender":16},{"title":611,"editUrl":16,"head":612,"template":18,"sidebar":613,"pagefind":16,"draft":20},"Jestの中級",[],{"hidden":20,"attrs":614},{},"このセクションでは、Jestを使用した中級レベルのテスト手法について説明します。\n\n## モックとスパイ\n\nJestを使用して関数のモックやスパイを行う方法を紹介します。これにより、テスト中に関数の呼び出しを監視したり、モックしたりすることが可能です。\n\n### モックの使用\n\nJestの`jest.mock`を使用して、モジュールをモックすることができます。\n\n```javascript\n// user.js\nfunction getUser() {\n  return { name: 'Alice' };\n}\nmodule.exports = getUser;\n\n// user.test.js\njest.mock('./user');\nconst getUser = require('./user');\n\ntest('should mock getUser function', () => {\n  getUser.mockReturnValue({ name: 'Bob' });\n  expect(getUser()).toEqual({ name: 'Bob' });\n});\n```\n\n### スパイの使用\n\nJestの`jest.spyOn`を使用して、関数の呼び出しをスパイすることができます。\n\n```javascript\n// math.js\nconst math = {\n  add: (a, b) => a + b,\n};\nmodule.exports = math;\n\n// math.test.js\nconst math = require('./math');\n\ntest('spies on add method', () => {\n  const spy = jest.spyOn(math, 'add');\n  math.add(1, 2);\n  expect(spy).toHaveBeenCalledWith(1, 2);\n});\n```","src/content/docs/jestガイド/03_中級/API利用法.mdx","03cddfaec129d531","jestガイド/05_学び記事/実践で得た教訓",{"id":618,"data":620,"body":625,"filePath":626,"digest":627,"deferredRender":16},{"title":621,"editUrl":16,"head":622,"template":18,"sidebar":623,"pagefind":16,"draft":20},"Jestの学び記事",[],{"hidden":20,"attrs":624},{},"このセクションでは、Jestを使用した実践で得た教訓や洞察を共有します。\n\n## 実践で得た教訓\n\nJestを使用する際に役立つ実践的なアドバイスを紹介します。\n\n### テストの設計\n\n- テストは小さく、独立しているべきです。これにより、特定の機能が正しく動作することを確認しやすくなります。\n\n### デバッグのヒント\n\n- Jestの`--watch`モードを使用して、テストを自動的に再実行し、開発効率を向上させます。\n\n```bash\njest --watch\n```\n\n### コードカバレッジ\n\n- Jestの`--coverage`オプションを使用して、コードカバレッジを確認し、テストの網羅性を評価します。\n\n```bash\njest --coverage\n```","src/content/docs/jestガイド/05_学び記事/実践で得た教訓.mdx","155d401d8b8aed59","nextjsガイド/02_中級/02_routing",{"id":628,"data":630,"body":635,"filePath":636,"digest":637,"deferredRender":16},{"title":631,"editUrl":16,"head":632,"template":18,"sidebar":633,"pagefind":16,"draft":20},"Next.jsのルーティング",[],{"hidden":20,"attrs":634},{},"## 🛤️ Next.jsのルーティング（App RouterとPages Router）\n\nNext.jsは、ファイルシステムに基づいたルーティングを採用しています。これにより、プロジェクト内のディレクトリやファイルがそのままURLパスになります。Next.js 13以降、新しいApp Routerが導入され、既存のPages Routerと異なるアプローチでルーティングを管理します。\n\n### 1. App Routerによるルーティング\n\nApp Routerは、`app/`ディレクトリを使用してルーティングを管理します。このアプローチでは、レイアウトの共有、ストリーミング、サーバーコンポーネントの利用が容易になります。\n\n#### ファイルベースのルーティング (`app/`)\n\n`app/`ディレクトリ内のサブディレクトリがURLパスに対応します。各セグメントの`page.tsx`ファイルが、そのパスのUIを定義します。\n\n```\n/app\n├── layout.tsx         // 共有レイアウト（例: ナビゲーションバー）\n├── page.tsx           // ルートページ (/)\n├── about/\n│   └── page.tsx       // /aboutページ\n└── blog/\n    └── [slug]/\n        └── page.tsx   // /blog/[slug]ページ\n```\n\n#### 動的ルーティング (TypeScript)\n\n動的なパスセグメントは、角括弧`[]`で囲んで指定します。例えば、`[slug]`というディレクトリは、`/blog/first-post`や`/blog/second-post`のようなURLに対応します。\n\n##### 例: `app/blog/[slug]/page.tsx`\n\n```typescript\n// app/blog/[slug]/page.tsx\ntype BlogPostPageProps = {\n  params: {\n    slug: string;\n  };\n};\n\nconst BlogPostPage = ({ params }: BlogPostPageProps) => {\n  return \u003Ch1>ブログ投稿: {params.slug}\u003C/h1>;\n};\n\nexport default BlogPostPage;\n```\n\n- `params`: App Routerでは、動的なセグメントの値が`params`プロパティとしてコンポーネントに渡されます。これにより、`useRouter`フックを使用する必要がなくなります。\n\n### 2. Pages Routerによるルーティング\n\nPages Routerは、`pages/`ディレクトリを使用してルーティングを管理する従来のアプローチです。\n\n#### ファイルベースのルーティング (`pages/`)\n\n`pages/`ディレクトリ内のファイル名がURLパスになります。\n\n```\n/pages\n├── index.tsx          // ルートページ (/)\n├── about.tsx          // /aboutページ\n└── blog/\n    └── [id].tsx       // /blog/[id]ページ\n```\n\n#### 動的ルーティング (TypeScript)\n\nPages Routerでは、`useRouter`フックを使って動的なセグメントの値を取得します。\n\n##### 例: `pages/blog/[id].tsx`\n\n```typescript\n// pages/blog/[id].tsx\nimport { useRouter } from 'next/router';\n\nconst BlogPostPage = () => {\n  const router = useRouter();\n  const { id } = router.query;\n\n  return \u003Ch1>ブログ投稿: {id}\u003C/h1>;\n};\n\nexport default BlogPostPage;\n```\n\n- `useRouter`: クライアントサイドでのルーティング情報（URL、クエリパラメータなど）にアクセスするためのフックです。\n\n### まとめ\n\n| 特徴             | Pages Router | App Router |\n|------------------|--------------|------------|\n| ディレクトリ     | `pages/`     | `app/`     |\n| 動的セグメント   | `[name].tsx` | `[name]/page.tsx` |\n| パス取得         | `useRouter().query` | `params`プロパティ |\n| 利点             | シンプルで理解しやすい | レイアウト共有、サーバーコンポーネント、高度な機能 |\n\n新しいプロジェクトを始める場合は、**App Router**の利用が強く推奨されます。App Routerは、将来的なNext.jsの進化の方向性であり、サーバーコンポーネントやデータフェッチの新しい方法など、多くのパフォーマンス改善を提供します。","src/content/docs/nextjsガイド/02_中級/02_routing.mdx","7c5ec1a0cdb68735","nextjsガイド/02_中級/04_deployment",{"id":638,"data":640,"body":645,"filePath":646,"digest":647,"deferredRender":16},{"title":641,"editUrl":16,"head":642,"template":18,"sidebar":643,"pagefind":16,"draft":20},"Next.jsのデプロイメント",[],{"hidden":20,"attrs":644},{},"## 🚀 Next.jsのデプロイメント\n\nNext.jsアプリケーションのデプロイは、開発元であるVercelを利用するのが最も一般的で推奨される方法です。VercelはNext.jsに最適化されており、ビルド、デプロイ、ホスティングのプロセスを自動化します。\n\n### 1. Vercelへのデプロイ準備 📦\n\nNext.jsのデプロイメントには、Vercel CLIを使う方法と、Gitとの連携を使う方法の2つがあります。\n\n#### Vercel CLIのインストールとデプロイ\n\n```bash\nnpm install -g vercel\nvercel\n```\n\nこのコマンドを実行すると、Vercelアカウントへのログインが促され、その後、現在のプロジェクトをVercelにデプロイするプロセスが始まります。\n\n#### Gitとの連携\n\nGitHub、GitLab、またはBitbucketのリポジトリとVercelを連携させるのが最も一般的な方法です。リポジトリをVercelにインポートすると、以降の`git push`が自動的にデプロイメントをトリガーします。\n\n### 2. Vercelでのデプロイメントの仕組み ⚙️\n\nVercelは、Next.jsの機能を最大限に活用したホスティング環境を提供します。\n\n- **ビルド（Build）**: Vercelは、`next build`コマンドを実行し、アプリケーションを本番用に最適化します。静的ページ（SSG）やサーバーサイドでレンダリングされるページ（SSR）が生成されます。\n\n- **サーバーレス機能**: APIルートやSSR機能は、自動的にAWS Lambdaなどのサーバーレス関数としてデプロイされます。これにより、必要なときにだけ計算リソースが使用され、コスト効率とスケーラビリティが向上します。\n\n- **CDN（コンテンツ配信ネットワーク）**: 静的アセット（画像、CSS、SSGで生成されたHTMLなど）は、世界中のCDNに自動的にキャッシュされ、ユーザーに高速で配信されます。\n\n### 3. Vercelダッシュボードの見方と活用法 📊\n\nデプロイ後、Vercelのダッシュボードでアプリケーションの状態を詳細に確認できます。\n\n- **Deployments（デプロイメント）**:\n  - このセクションでは、過去のすべてのデプロイメント履歴を確認できます。それぞれのデプロイメントには、ステータス、デプロイ日時、およびプレビューURLが表示されます。これにより、新しい変更を本番環境に反映する前に、テストすることができます。\n\n- **Analytics（アナリティクス）**:\n  - アプリケーションのパフォーマンスに関する詳細なデータを提供します。Web Vitals（LCP, FID, CLSなど）のスコアを追跡し、ページの読み込み速度やユーザー体験を分析できます。また、どのページが最も訪問されているか、どの地域からのアクセスが多いかといった情報も確認できます。\n\n- **Logs（ログ）**:\n  - APIルートやサーバーレス関数からのログをリアルタイムで確認できます。エラーやデバッグ情報を追跡するのに非常に便利です。\n\n- **Settings（設定）**:\n  - ドメインのカスタム設定、環境変数、チームメンバーの管理など、プロジェクトに関する詳細な設定を行えます。特に、APIキーなどの機密情報を環境変数として安全に管理できる点が重要です。\n\n### 4. Vercelダッシュボードのより詳しい見方と活用法 🔍\n\nVercelダッシュボードには、上記以外にも、プロジェクトの運用を最適化するための強力な機能が備わっています。\n\n- **Domains（ドメイン）**:\n  - プロジェクトにカスタムドメイン（例:your-site.com）を簡単に紐づけることができます。VercelがDNSレコードを自動で設定してくれるため、手動で複雑な設定をする必要がありません。\n\n- **Git Integration（Git連携）**:\n  - Vercelは、Gitブランチとデプロイメントを自動的に紐づけます。特定のブランチ（例:main）へのプッシュを本番環境への自動デプロイメントに設定したり、プルリクエストごとにプレビューURLを自動生成したりできます。これにより、チーム開発におけるレビュープロセスが非常にスムーズになります。\n\n- **Environment Variables（環境変数）**:\n  - 本番環境、プレビュー環境、開発環境ごとに異なる環境変数を設定できます。APIキーやデータベース接続文字列などの機密情報を安全に管理するのに不可欠です。デプロイ設定をGitHubに公開することなく、安全に管理できるのが大きな利点です。\n\n- **Integrations（統合）**:\n  - Vercelは、Slack、GitHub、Sentryなどの様々なサービスと統合できます。たとえば、デプロイが完了したときにSlackに通知を送ったり、エラー監視ツールと連携して問題を迅速に特定したりできます。\n\n- **Functions（関数）**:\n  - APIルートやSSRページがサーバーレス関数としてどのようにデプロイされているかを確認できます。各関数の実行時間、メモリ使用量、コールドスタート時間などの詳細なメトリクスを監視できるため、パフォーマンスのボトルネックを特定するのに役立ちます。\n\nこれらの機能は、Next.jsのデプロイメントを自動化するだけでなく、アプリケーションのパフォーマンス監視、セキュリティ、チーム開発の効率を大幅に向上させます。","src/content/docs/nextjsガイド/02_中級/04_deployment.mdx","03965041a6a020ff","nextjsガイド/02_中級/03_api_routes",{"id":648,"data":650,"body":655,"filePath":656,"digest":657,"deferredRender":16},{"title":651,"editUrl":16,"head":652,"template":18,"sidebar":653,"pagefind":16,"draft":20},"Next.jsのAPIルート",[],{"hidden":20,"attrs":654},{},"## 🤝 Next.jsのAPIルート\n\nNext.jsのAPIルートは、フロントエンドとバックエンドの機能を一つのプロジェクト内で統合できる強力な機能です。これにより、Express.jsやFastAPIのような別のサーバーを構築することなく、サーバーサイドのロジックを簡単に実装できます。これは、Next.jsが単なるフロントエンドフレームワークではなく、フルスタックフレームワークとして機能する大きな理由の一つです。\n\n### 1. APIルートの作成\n\nAPIルートは、`pages/api`（Pages Router）または`app/api`（App Router）ディレクトリ内にファイルを作成することで定義されます。これらのディレクトリ内のファイルは、対応するパスへのAPIエンドポイントになります。\n\n#### Pages Router (`pages/api`)\n\n`pages/api`ディレクトリ内の各ファイルがAPIエンドポイントになります。\n\n##### 例: `/pages/api/hello.ts`\n\n```typescript\n// pages/api/hello.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method === 'GET') {\n    res.status(200).json({ message: 'Hello from API!' });\n  } else {\n    res.status(405).json({ message: 'Method Not Allowed' });\n  }\n}\n```\n\n- `req`: incoming request object\n- `res`: server response object\n\nこのコードは、GETリクエストを受け付け、Method Not Allowedエラーを返すシンプルなAPIです。\n\n#### App Router (`app/api`)\n\nApp Routerでは、`app/api`ディレクトリ内の各ルートセグメントに`route.ts`ファイルを作成します。これにより、HTTPメソッド（GET, POST, PUTなど）ごとに専用の関数を定義できます。\n\n##### 例: `/app/api/hello/route.ts`\n\n```typescript\n// app/api/hello/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n  return NextResponse.json({ message: 'Hello from App Router!' });\n}\n\nexport async function POST() {\n  return NextResponse.json({ message: 'POST request received.' });\n}\n```\n\n- `NextResponse`: 新しいApp Routerで推奨されるレスポンスオブジェクトで、より柔軟なレスポンス制御が可能です。\n- `HTTPメソッド関数`: 各HTTPメソッドに対応する関数をエクスポートすることで、ルーティングが自動的に処理されます。\n\n### 2. APIルートの活用：フルスタック開発の実現\n\nAPIルートの真価は、フロントエンドとバックエンドのシームレスな統合にあります。\n\n- **データベースとの連携**: APIルート内でデータベースに接続し、データの取得、更新、削除を行うことができます。これにより、クライアントは直接データベースにアクセスすることなく、安全にデータをやり取りできます。\n\n- **外部APIとの通信**: 外部のAPIを呼び出してデータを取得し、加工してからフロントエンドに渡すことができます。これにより、機密情報（APIキーなど）をクライアント側に公開することなく処理できます。\n\n- **認証ロジックの実装**: ユーザー認証やセッション管理などのサーバーサイドロジックをAPIルート内に実装できます。\n\nこのように、Next.jsはAPIルートを提供することで、単一のリポジトリ内でフロントエンドとバックエンドの両方を効率的に管理できるフルスタック開発の環境を構築します。これにより、プロジェクトの複雑さを軽減し、開発スピードを向上させることができます。","src/content/docs/nextjsガイド/02_中級/03_api_routes.mdx","0dfe4ad1ddef93aa","nextjsガイド/01_はじめに/00_なぜnextなのか",{"id":658,"data":660,"body":665,"filePath":666,"digest":667,"deferredRender":16},{"title":661,"editUrl":16,"head":662,"template":18,"sidebar":663,"pagefind":16,"draft":20},"Next.jsとは",[],{"hidden":20,"attrs":664},{},"## ⚛️ Next.jsとは\n\nNext.jsは、Reactをベースにしたオープンソースのフレームワークです。Webアプリケーションをより効率的かつ高性能に開発するために設計されています。Next.jsは、React単体では提供されないルーティング、サーバーサイドレンダリング（SSR）、**静的サイト生成（SSG）**などの機能を標準で備えています。\n\n### なぜNext.jsを選ぶのか？（Reactとの比較）\n\nNext.jsが選ばれる理由は、React単体で開発する際のいくつかの課題を解決しているからです。\n\n#### 1. パフォーマンスの課題 ⚡️\n\n- **Reactの課題**:\n  - Reactはデフォルトで**クライアントサイドレンダリング（CSR）**を採用しています。これは、ブラウザがJavaScriptをダウンロード、実行してからコンテンツが表示されるため、初期ロードに時間がかかり、ユーザー体験（UX）が悪化する可能性があります。特に、モバイル環境やネットワーク環境の悪い場所では顕著です。\n\n- **Next.jsによる解決**:\n  - Next.jsは、以下のレンダリング方式をサポートし、パフォーマンスを最適化します。\n    - **サーバーサイドレンダリング（SSR）**: サーバーでHTMLを生成し、クライアントに送信します。これにより、ユーザーはすぐにコンテンツを見ることができ、高速な表示が実現します。\n    - **静的サイト生成（SSG）**: ビルド時にHTMLファイルを生成します。コンテンツが動的に変化しない場合に非常に効果的で、CDN（コンテンツ配信ネットワーク）から高速に配信できます。\n    - **ハイブリッドレンダリング**: ページごとに最適なレンダリング方式を選択できます。\n\n#### 2. SEO（検索エンジン最適化）の課題 🔍\n\n- **Reactの課題**:\n  - ReactのCSRは、JavaScriptが実行されないとページ内容が空の状態になるため、検索エンジンのクローラーがコンテンツを正しく認識できない可能性があります。これにより、SEOスコアが低下することがあります。\n\n- **Next.jsによる解決**:\n  - SSRやSSGを使用することで、HTMLがサーバーで事前に生成されます。この生成済みのHTMLにはコンテンツが完全に含まれているため、検索エンジンのクローラーが簡単に内容を読み取ることができ、SEOに非常に有利です。\n\n#### 3. 開発体験の課題 🧑‍💻\n\n- **Reactの課題**:\n  - React単体では、ルーティングやAPIルートの作成など、アプリケーションの基盤となる部分を開発者が自分で構築しなければなりません。これにより、開発の初期段階で多くの時間と労力がかかります。\n\n- **Next.jsによる解決**:\n  - Next.jsは、これらの共通の課題に対する**規約（コンベンション）**を提供します。\n    - **ファイルシステムベースのルーティング**: `pages/`または`app/`ディレクトリにファイルを作成するだけで、自動的にルーティングが設定されます。\n    - **APIルート**: `pages/api`ディレクトリにファイルを作成することで、簡単にAPIエンドポイントを構築できます。これは、フロントエンドとバックエンドを一つのプロジェクトで管理できることを意味します。\n    - **画像最適化**: `next/image`コンポーネントを使用すると、画像の遅延読み込みや最適化を自動で行い、パフォーマンスを向上させます。\n\nこれらの機能により、開発者はアプリケーションのコア機能に集中でき、開発効率が大幅に向上します。\n\n#### 4. ゼロコンフィグと拡張性 ⚙️\n\n- **Reactの課題**:\n  - Reactでゼロからプロジェクトを始めるには、WebpackやBabelといった複雑なビルドツールを設定する必要があります。これは、特に初心者にとって学習コストが高く、時間もかかります。\n\n- **Next.jsによる解決**:\n  - Next.jsは、これらのビルド設定の多くを内部で自動的に処理します。開発者は設定ファイルに悩むことなく、すぐにコードを書き始めることができます。\n    - **ゼロコンフィグ**: Next.jsはデフォルトで多くの設定を最適化しており、開発者はすぐに始められます。\n    - **高い拡張性**: 必要に応じて、`next.config.js`ファイルを通じて、WebpackやBabelの設定をカスタマイズすることも可能です。これにより、独自の要件を持つ複雑なプロジェクトにも柔軟に対応できます。\n\n#### 5. フルスタック開発のサポート 🤝\n\n- **Reactの課題**:\n  - Reactは主にUIを構築するためのライブラリであり、バックエンド機能（データベース接続、認証など）は別途、Node.js、Express、FastAPIなどのフレームワークを使って構築する必要があります。これにより、フロントエンドとバックエンドで異なる開発環境とデプロイプロセスを管理する必要が生じます。\n\n- **Next.jsによる解決**:\n  - Next.jsは、API RoutesとMiddlewareの機能を提供することで、フロントエンドとバックエンドを一つのプロジェクト内で統合的に開発するフルスタックフレームワークとしての側面を持ちます。\n    - **API Routes**: `pages/api`または`app/api`ディレクトリにファイルを作成することで、サーバーサイドのロジックを簡単に実装できます。これにより、フロントエンドとバックエンドの連携がシームレスになります。\n    - **Middleware**: リクエストがエンドポイントに到達する前に、認証チェックやリダイレクトなどのロジックを実行できます。\n\nこれらの機能により、開発者は1つのコードベースでフロントエンドとバックエンドの両方を管理でき、開発とデプロイの複雑さを大幅に軽減できます。\n\n### まとめ\n\nNext.jsは、React単体では解決が困難だったパフォーマンス、SEO、開発効率といった課題を、フレームワークとしての規約と豊富な機能で克服しています。さらに、ビルド設定の自動化やフルスタック開発のサポートにより、小規模なプロジェクトから大規模なエンタープライズアプリケーションまで、あらゆる規模のWeb開発において強力なツールとなっています。","src/content/docs/nextjsガイド/01_はじめに/00_なぜNextなのか.mdx","a9fb2e4de452f679","nextjsガイド/01_はじめに/css",{"id":668,"data":670,"body":675,"filePath":676,"digest":677,"deferredRender":16},{"title":671,"editUrl":16,"head":672,"template":18,"sidebar":673,"pagefind":16,"draft":20},"cookie戦略",[],{"hidden":20,"attrs":674},{},"## 🎨 スタイリング戦略\n\nNext.jsは、アプリケーションのスタイリングに複数の方法を提供します。プロジェクトの規模やチームの好みに応じて最適な方法を選択できます。\n\n### 1. CSS Modules\n\nCSS Modulesは、コンポーネントごとに独立したスタイルを適用するための推奨される方法です。各CSSファイルは自動的に一意のクラス名を生成するため、クラス名の衝突を防ぐことができます。\n\n- **利点**: グローバルな名前空間の汚染を防ぎ、コンポーネントの再利用性を高めます。\n- **使用法**: ファイル名を`.module.css`で終わらせます。\n\n```css\n/* styles/Button.module.css */\n.button {\n  background-color: blue;\n  color: white;\n}\n```\n\n```typescript\nimport styles from '../styles/Button.module.css';\n\nfunction Button() {\n  return \u003Cbutton className={styles.button}>Click me\u003C/button>;\n}\n```\n\n### 2. Styled-Components / Emotion\n\nStyled-ComponentsやEmotionといったCSS-in-JSライブラリを使用すると、スタイルをJavaScriptコード内に直接記述できます。これにより、コンポーネントとスタイルを1つのファイルにまとめることができます。\n\n- **利点**: コンポーネントのプロパティに基づいて動的なスタイルを適用するのが簡単です。JavaScriptの機能（変数、関数など）をスタイルに利用できます。\n- **使用法**: ライブラリをインストールし、コンポーネントを作成します。\n\n```typescript\nimport styled from 'styled-components';\n\nconst StyledButton = styled.button`\n  background-color: ${props => props.primary ? 'blue' : 'gray'};\n  color: white;\n  border: none;\n`;\n\nfunction Button({ primary }) {\n  return \u003CStyledButton primary={primary}>Styled Button\u003C/StyledButton>;\n}\n```\n\n### 3. Tailwind CSS\n\nTailwind CSSは、ユーティリティファーストのCSSフレームワークです。事前に定義されたクラス（例：`flex`, `text-center`, `p-4`）をHTMLに直接適用することで、素早くデザインを構築できます。\n\n- **利点**: カスタムCSSを書く必要がほとんどなく、開発スピードが大幅に向上します。ビルド時に不要なCSSが削除されるため、最終的なファイルサイズが非常に小さくなります。\n- **使用法**: クラス名を直接HTMLに追加します。\n\n```typescript\n\u003Cbutton className=\"bg-blue-500 text-white font-bold py-2 px-4 rounded\">\n  Tailwind Button\n\u003C/button>\n```\n\n## 🌐 国際化（i18n）\n\nNext.jsは、アプリケーションを多言語対応にするための国際化機能をサポートしています。これにより、ユーザーの言語設定に応じてコンテンツを切り替えることができます。\n\n### 1. Next.jsのi18n機能\n\nNext.jsの組み込みi18n機能は、ルーティングを介して言語を処理します。`next.config.js`でサポートするロケール（言語）とデフォルトのロケールを設定するだけで簡単に始められます。\n\n#### 設定例:\n\n```javascript\n// next.config.js\nmodule.exports = {\n  i18n: {\n    locales: ['en', 'ja'], // サポートする言語\n    defaultLocale: 'en',  // デフォルトの言語\n  },\n};\n```\n\nこの設定により、URLが自動的に`/ja/about`や`/en/about`のように言語ごとにルーティングされます。\n\n### 2. 外部ライブラリとの連携\n\nより高度な機能（動的な翻訳、複数形など）が必要な場合は、`react-i18next`や`next-intl`のようなライブラリを組み合わせるのが一般的です。これらのライブラリは、翻訳ファイルの管理やコンポーネント内での翻訳文字列の利用を容易にします。\n\nこれらのトピック以外にも、認証、テスト、パフォーマンス最適化など、Next.jsには掘り下げるべき分野がまだたくさんあります。","src/content/docs/nextjsガイド/01_はじめに/CSS.mdx","74d0fcb58b277f93","nextjsガイド/02_基本/01_setup",{"id":678,"data":680,"body":685,"filePath":686,"digest":687,"deferredRender":16},{"title":681,"editUrl":16,"head":682,"template":18,"sidebar":683,"pagefind":16,"draft":20},"Next.jsのセットアップ",[],{"hidden":20,"attrs":684},{},"## 🚀Next.jsのセットアップ\n\nNext.jsプロジェクトを始めるには、Node.jsがPCにインストールされている必要があります。以下のコマンドを使用して、対話形式で新しいNext.jsアプリケーションを簡単に作成できます。\n\n### 1. プロジェクトの作成\n\nプロジェクトを作成したいディレクトリで、以下のコマンドを実行します。\n\n```bash\nnpx create-next-app@latest\n```\n\nこのコマンドを実行すると、以下のような設定に関する質問が順に表示されます。\n\n- **プロジェクト名**: `my-next-app` など、プロジェクトの名前を入力します。\n- **TypeScriptの利用**: `Yes` または `No` を選択します。TypeScriptを使用すると、大規模なアプリケーションでコードの信頼性を高めることができます。\n- **ESLintの利用**: `Yes` または `No` を選択します。コードの品質を維持するのに役立ちます。\n- **Tailwind CSSの利用**: `Yes` または `No` を選択します。迅速なUI開発に便利なユーティリティファーストのCSSフレームワークです。\n- **src/ディレクトリの利用**: `Yes` または `No` を選択します。すべてのアプリケーションコードを`src/`ディレクトリにまとめることで、プロジェクトを整理しやすくなります。\n- **App Routerの利用**: `Yes` または `No` を選択します。Next.js 13以降で導入された、コンポーネントベースのルーティングシステムです。新しいプロジェクトではこれを利用することが推奨されます。\n- **インポートエイリアスの設定**: `Yes` または `No` を選択します。`@/components` のように、相対パスではなく絶対パスでモジュールをインポートできるようになります。\n\n### 2. 開発サーバーの起動\n\nプロジェクトの作成が完了したら、新しく生成されたディレクトリに移動し、開発サーバーを起動します。\n\n```bash\ncd my-next-app\nnpm run dev\n```\n\nこれにより、開発サーバーが起動し、`http://localhost:3000`で作成したアプリケーションをリアルタイムで確認できます。コードを変更するたびにブラウザが自動的にリロードされるため、開発がスムーズに進みます。","src/content/docs/nextjsガイド/02_基本/01_setup.mdx","dfd459fa5146a71b","nextjsガイド/02_基本/02_routing",{"id":688,"data":690,"body":635,"filePath":694,"digest":637,"deferredRender":16},{"title":631,"editUrl":16,"head":691,"template":18,"sidebar":692,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":693},{},"src/content/docs/nextjsガイド/02_基本/02_routing.mdx","nextjsガイド/02_基本/03_api_routes",{"id":695,"data":697,"body":655,"filePath":701,"digest":657,"deferredRender":16},{"title":651,"editUrl":16,"head":698,"template":18,"sidebar":699,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":700},{},"src/content/docs/nextjsガイド/02_基本/03_api_routes.mdx","nextjsガイド/02_基本/04_deployment",{"id":702,"data":704,"body":645,"filePath":708,"digest":647,"deferredRender":16},{"title":641,"editUrl":16,"head":705,"template":18,"sidebar":706,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":707},{},"src/content/docs/nextjsガイド/02_基本/04_deployment.mdx","jestガイド/04_上級最適化/パフォーマンスチューニング",{"id":709,"data":711,"body":716,"filePath":717,"digest":718,"deferredRender":16},{"title":712,"editUrl":16,"head":713,"template":18,"sidebar":714,"pagefind":16,"draft":20},"Jestの上級",[],{"hidden":20,"attrs":715},{},"このセクションでは、Jestを使用した上級レベルのテスト手法とパフォーマンスチューニングについて説明します。\n\n## パフォーマンスチューニング\n\nJestのテスト実行速度を最適化するための方法を紹介します。\n\n### 並行テストの活用\n\nJestはデフォルトで並行テストをサポートしています。`--maxWorkers`オプションを使用して、同時に実行するテストの数を制御できます。\n\n```bash\njest --maxWorkers=4\n```\n\n### キャッシュの利用\n\nJestはテスト結果をキャッシュして、再実行時の速度を向上させます。キャッシュを有効にするには、`--cache`オプションを使用します。\n\n```bash\njest --cache\n```\n\n## ベストプラクティス\n\n- テストは独立して実行できるように設計します。\n- テストデータはモックまたはスタブを使用して管理します。\n- エラーハンドリングを適切に行い、詳細なエラーメッセージを提供します。","src/content/docs/jestガイド/04_上級・最適化/パフォーマンスチューニング.mdx","4ec5f28a8f5262de","nextjsガイド/03_上級/05_advanced_features",{"id":719,"data":721,"body":726,"filePath":727,"digest":728,"deferredRender":16},{"title":722,"editUrl":16,"head":723,"template":18,"sidebar":724,"pagefind":16,"draft":20},"Next.jsの高度な機能",[],{"hidden":20,"attrs":725},{},"Next.jsは、さまざまな高度な機能を提供しています。以下に、いくつかの例を示します。\n\n## 静的サイト生成 (SSG)\n\nNext.jsは、ビルド時に静的ページを生成することができます。\n\n```javascript\n// /pages/posts/[id].js\nexport async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { id: '1' } },\n      { params: { id: '2' } },\n    ],\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  return {\n    props: { postId: params.id },\n  };\n}\n\nconst Post = ({ postId }) => {\n  return \u003Cp>Post ID: {postId}\u003C/p>;\n};\n\nexport default Post;\n```\n\n## サーバーサイドレンダリング (SSR)\n\nサーバーサイドでページをレンダリングすることも可能です。\n\n```javascript\n// /pages/index.js\nexport async function getServerSideProps() {\n  return {\n    props: { message: 'Hello from SSR' },\n  };\n}\n\nconst Home = ({ message }) => {\n  return \u003Cp>{message}\u003C/p>;\n};\n\nexport default Home;\n```\n\n## Incremental Static Regeneration (ISR)\n\nISRを使用すると、静的ページをビルド後に再生成できます。これにより、最新のデータを反映しつつ、静的サイトのパフォーマンスを維持できます。\n\n```javascript\n// /pages/posts/[id].js\nexport async function getStaticProps({ params }) {\n  const post = await fetchPost(params.id);\n  return {\n    props: { post },\n    revalidate: 10, // 10秒ごとに再生成\n  };\n}\n```\n\n## Image Optimization\n\n`next/image`コンポーネントを使用すると、画像の自動最適化が可能です。これにより、ページの読み込み速度が向上します。\n\n```javascript\nimport Image from 'next/image';\n\nconst MyImage = () => (\n  \u003CImage\n    src=\"/me.png\"\n    alt=\"Picture of the author\"\n    width={500}\n    height={500}\n  />\n);\n```\n\n## Internationalization (i18n)\n\nNext.jsのi18n機能を使用して、多言語対応のアプリケーションを構築できます。\n\n```javascript\n// next.config.js\nmodule.exports = {\n  i18n: {\n    locales: ['en', 'fr', 'ja'],\n    defaultLocale: 'en',\n  },\n};\n```\n\n## Custom Server\n\nカスタムサーバーを設定することで、Next.jsアプリケーションのリクエスト処理をカスタマイズできます。\n\n```javascript\nconst express = require('express');\nconst next = require('next');\n\nconst app = next({ dev: process.env.NODE_ENV !== 'production' });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  server.get('/custom', (req, res) => {\n    return app.render(req, res, '/custom', req.query);\n  });\n\n  server.all('*', (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(3000, (err) => {\n    if (err) throw err;\n    console.log('> Ready on http://localhost:3000');\n  });\n});\n```\n\n## Middleware\n\nミドルウェアを使用して、リクエストの前処理や後処理を行うことができます。\n\n```javascript\n// middleware.js\nexport function middleware(req, ev) {\n  // リクエストの前処理\n}\n```","src/content/docs/nextjsガイド/03_上級/05_advanced_features.mdx","9fd7cbf70b4d7cef","nextjsガイド/03_上級/06_orm",{"id":729,"data":731,"body":736,"filePath":737,"digest":738,"deferredRender":16},{"title":732,"editUrl":16,"head":733,"template":18,"sidebar":734,"pagefind":16,"draft":20},"Next.jsのORM",[],{"hidden":20,"attrs":735},{},"## 🗄️ Next.jsのORM\n\nNext.jsでのデータベース操作には、ORM（Object-Relational Mapping）を使用することが一般的です。ORMを使用することで、データベースとのやり取りをオブジェクト指向の方法で行うことができ、コードの可読性と保守性が向上します。\n\n### 1. Prismaの導入\n\nPrismaは、Next.jsプロジェクトでよく使用されるORMの一つです。Prismaを使用することで、データベーススキーマの定義、マイグレーションの管理、データの取得や更新を簡単に行うことができます。\n\n#### Prismaのインストール\n\n```bash\nnpm install @prisma/client\nnpm install prisma --save-dev\n```\n\n#### Prismaの初期化\n\n```bash\nnpx prisma init\n```\n\nこのコマンドを実行すると、Prismaの設定ファイルが生成されます。\n\n### 2. データベーススキーマの定義\n\nPrismaでは、`schema.prisma`ファイルを使用してデータベーススキーマを定義します。\n\n```prisma\n// schema.prisma\nmodel User {\n  id    Int     @id @default(autoincrement())\n  name  String\n  email String  @unique\n}\n```\n\n### 3. マイグレーションの実行\n\nデータベーススキーマを変更した後、マイグレーションを実行してデータベースを更新します。\n\n```bash\nnpx prisma migrate dev --name init\n```\n\n### 4. データの取得と操作\n\nPrismaクライアントを使用して、データベースからデータを取得したり、更新したりすることができます。\n\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  const allUsers = await prisma.user.findMany();\n  console.log(allUsers);\n}\n\nmain()\n  .catch(e => {\n    throw e;\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n```\n\nPrismaを使用することで、Next.jsアプリケーションでのデータベース操作が効率的かつ安全に行えるようになります。","src/content/docs/nextjsガイド/03_上級/06_orm.mdx","850bcb6af15fb137","nextjsガイド/03_上級/07_testing",{"id":739,"data":741,"body":746,"filePath":747,"digest":748,"deferredRender":16},{"title":742,"editUrl":16,"head":743,"template":18,"sidebar":744,"pagefind":16,"draft":20},"Next.jsのテスト",[],{"hidden":20,"attrs":745},{},"## 🧪 Next.jsのテスト\n\nNext.jsアプリケーションのテストは、アプリケーションの品質を保証するために重要です。JestやReact Testing Libraryを使用して、コンポーネントやページのテストを行うことが一般的です。\n\n### 1. Jestのセットアップ\n\nJestは、JavaScriptのテストフレームワークで、Next.jsプロジェクトで広く使用されています。\n\n#### Jestのインストール\n\n```bash\nnpm install --save-dev jest\nnpm install --save-dev @testing-library/react\nnpm install --save-dev @testing-library/jest-dom\n```\n\n#### Jestの設定\n\n`jest.config.js`ファイルを作成し、以下のように設定します。\n\n```javascript\n// jest.config.js\nmodule.exports = {\n  testEnvironment: 'jsdom',\n  setupFilesAfterEnv: ['\u003CrootDir>/jest.setup.js'],\n  moduleNameMapper: {\n    '^@/(.*)$': '\u003CrootDir>/$1',\n  },\n};\n```\n\n### 2. React Testing Libraryの使用\n\nReact Testing Libraryは、Reactコンポーネントのテストを行うためのライブラリです。\n\n#### 基本的なテストの例\n\n```javascript\nimport { render, screen } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport Home from '@/pages/index';\n\ntest('renders a heading', () => {\n  render(\u003CHome />);\n  const heading = screen.getByRole('heading', {\n    name: /welcome to next.js!/i,\n  });\n  expect(heading).toBeInTheDocument();\n});\n```\n\n### 3. テストの実行\n\nテストを実行するには、以下のコマンドを使用します。\n\n```bash\nnpm test\n```\n\nJestとReact Testing Libraryを使用することで、Next.jsアプリケーションのコンポーネントやページの動作を確実にテストし、品質を保証することができます。","src/content/docs/nextjsガイド/03_上級/07_testing.mdx","40f3899c8e4fca47","nextjsガイド/03_上級/08_caching_strategies",{"id":749,"data":751,"body":756,"filePath":757,"digest":758,"deferredRender":16},{"title":752,"editUrl":16,"head":753,"template":18,"sidebar":754,"pagefind":16,"draft":20},"Next.jsのキャッシング戦略",[],{"hidden":20,"attrs":755},{},"## 🗄️ Next.jsのキャッシング戦略\n\nNext.jsでは、パフォーマンスを向上させるためにさまざまなキャッシング戦略を採用できます。これにより、ユーザーエクスペリエンスを向上させ、サーバーの負荷を軽減することができます。\n\n### 1. 静的サイト生成 (SSG) のキャッシュ\n\n静的サイト生成を使用することで、ビルド時に生成されたHTMLファイルをCDNにキャッシュし、ユーザーに高速で配信できます。\n\n```javascript\n// /pages/posts/[id].js\nexport async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { id: '1' } },\n      { params: { id: '2' } },\n    ],\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  return {\n    props: { postId: params.id },\n  };\n}\n\nconst Post = ({ postId }) => {\n  return \u003Cp>Post ID: {postId}\u003C/p>;\n};\n\nexport default Post;\n```\n\n### 2. サーバーサイドレンダリング (SSR) のキャッシュ\n\nサーバーサイドレンダリングを使用する場合、キャッシュを適切に設定することで、サーバーの負荷を軽減し、レスポンス時間を短縮できます。\n\n```javascript\n// /pages/index.js\nexport async function getServerSideProps() {\n  return {\n    props: { message: 'Hello from SSR' },\n  };\n}\n\nconst Home = ({ message }) => {\n  return \u003Cp>{message}\u003C/p>;\n};\n\nexport default Home;\n```\n\n### 3. Incremental Static Regeneration (ISR)\n\nISRを使用することで、静的ページをビルド後に再生成し、最新のデータを反映しつつ、静的サイトのパフォーマンスを維持できます。\n\n```javascript\n// /pages/posts/[id].js\nexport async function getStaticProps({ params }) {\n  const post = await fetchPost(params.id);\n  return {\n    props: { post },\n    revalidate: 10, // 10秒ごとに再生成\n  };\n}\n```\n\n### 4. CDNの活用\n\nNext.jsは、Vercelを使用することで、静的アセット（画像、CSS、SSGで生成されたHTMLなど）を世界中のCDNに自動的にキャッシュし、ユーザーに高速で配信します。\n\n### 5. キャッシュ制御ヘッダー\n\nキャッシュ制御ヘッダーを使用して、ブラウザやCDNのキャッシュを細かく制御できます。\n\n```javascript\n// /pages/api/hello.js\nexport default function handler(req, res) {\n  res.setHeader('Cache-Control', 's-maxage=10, stale-while-revalidate');\n  res.status(200).json({ message: 'Hello from API!' });\n}\n```\n\nこれらのキャッシング戦略を適用することで、Next.jsアプリケーションのパフォーマンスを大幅に向上させることができます。","src/content/docs/nextjsガイド/03_上級/08_caching_strategies.mdx","d073368b24928ae2","nextjsガイド/03_上級/09_directory_structure",{"id":759,"data":761,"body":766,"filePath":767,"digest":768,"deferredRender":16},{"title":762,"editUrl":16,"head":763,"template":18,"sidebar":764,"pagefind":16,"draft":20},"Next.jsのディレクトリ構造",[],{"hidden":20,"attrs":765},{},"## 🗂️ Next.jsのディレクトリ構造\n\nNext.jsプロジェクトのディレクトリ構造は、プロジェクトの規模や目的に応じて柔軟に設計できます。以下に、一般的なディレクトリ構造の例を示します。\n\n### 1. 小規模プロジェクト\n\n小規模なプロジェクトでは、シンプルなディレクトリ構造が適しています。\n\n```\n/\n├── pages/\n│   ├── index.js\n│   ├── about.js\n│   └── contact.js\n├── public/\n│   └── images/\n├── styles/\n│   └── globals.css\n└── package.json\n```\n\n### 2. 大規模プロジェクト\n\n大規模なプロジェクトでは、機能ごとにディレクトリを分けることで、コードの可読性と保守性を向上させることができます。\n\n```\n/\n├── components/\n│   ├── Header.js\n│   ├── Footer.js\n│   └── Sidebar.js\n├── pages/\n│   ├── index.js\n│   ├── about.js\n│   └── contact.js\n├── public/\n│   └── images/\n├── styles/\n│   ├── globals.css\n│   └── Header.module.css\n└── package.json\n```\n\n### 3. 機能ベースのディレクトリ構造\n\n機能ベースのディレクトリ構造は、特定の機能に関連するすべてのファイルを一つのディレクトリにまとめる方法です。\n\n```\n/\n├── features/\n│   ├── auth/\n│   │   ├── Login.js\n│   │   ├── Register.js\n│   │   └── auth.module.css\n│   ├── dashboard/\n│   │   ├── Dashboard.js\n│   │   └── dashboard.module.css\n│   └── profile/\n│       ├── Profile.js\n│       └── profile.module.css\n├── pages/\n│   ├── index.js\n│   ├── about.js\n│   └── contact.js\n├── public/\n│   └── images/\n├── styles/\n│   └── globals.css\n└── package.json\n```\n\n### 4. Next.js 13以降のディレクトリ構造\n\nNext.js 13以降では、`app/`ディレクトリを使用した新しいディレクトリ構造が導入されました。\n\n```\n/app\n├── layout.tsx\n├── page.tsx\n├── about/\n│   └── page.tsx\n└── blog/\n    └── [slug]/\n        └── page.tsx\n```\n\nこの構造では、`app/`ディレクトリ内のサブディレクトリがURLパスに対応し、各セグメントの`page.tsx`ファイルがそのパスのUIを定義します。\n\nNext.jsのディレクトリ構造は、プロジェクトのニーズに応じて柔軟に設計できるため、開発者は最適な構造を選択することが重要です。","src/content/docs/nextjsガイド/03_上級/09_directory_structure.mdx","a6446f4b9c796e37","nextjsガイド/03_上級/10_why_nextjs",{"id":769,"data":771,"body":776,"filePath":777,"digest":778,"deferredRender":16},{"title":772,"editUrl":16,"head":773,"template":18,"sidebar":774,"pagefind":16,"draft":20},"なぜNext.jsを選ぶのか",[],{"hidden":20,"attrs":775},{},"## 🤔 なぜNext.jsを選ぶのか（Reactとの比較）\n\nNext.jsが選ばれる理由は、React単体で開発する際のいくつかの課題を解決しているからです。\n\n### 1. パフォーマンスの課題 ⚡️\n\n- **Reactの課題**:\n  - Reactはデフォルトで**クライアントサイドレンダリング（CSR）**を採用しています。これは、ブラウザがJavaScriptをダウンロード、実行してからコンテンツが表示されるため、初期ロードに時間がかかり、ユーザー体験（UX）が悪化する可能性があります。特に、モバイル環境やネットワーク環境の悪い場所では顕著です。\n\n- **Next.jsによる解決**:\n  - Next.jsは、以下のレンダリング方式をサポートし、パフォーマンスを最適化します。\n    - **サーバーサイドレンダリング（SSR）**: サーバーでHTMLを生成し、クライアントに送信します。これにより、ユーザーはすぐにコンテンツをみることができ、高速な表示が実現します。\n    - **静的サイト生成（SSG）**: ビルド時にHTMLファイルを生成します。コンテンツが動的に変化しない場合に非常に効果的で、CDN（コンテンツ配信ネットワーク）から高速に配信できます。\n    - **ハイブリッドレンダリング**: ページごとに最適なレンダリング方式を選択できます。\n\n### 2. SEO（検索エンジン最適化）の課題 🔍\n\n- **Reactの課題**:\n  - ReactのCSRは、JavaScriptが実行されないとページ内容が空の状態になるため、検索エンジンのクローラーがコンテンツを正しく認識できない可能性があります。これにより、SEOスコアが低下することがあります。\n\n- **Next.jsによる解決**:\n  - SSRやSSGを使用することで、HTMLがサーバーで事前に生成されます。この生成済みのHTMLにはコンテンツが完全に含まれているため、検索エンジンのクローラーが簡単に内容を読み取ることができ、SEOに非常に有利です。\n\n### 3. 開発体験の課題 👨‍💻\n\n- **Reactの課題**:\n  - React単体では、ルーティングやAPIルートの作成など、アプリケーションの基盤となる部分を開発者が自分で構築しなければなりません。これにより、開発の初期段階で多くの時間と労力がかかります。\n\n- **Next.jsによる解決**:\n  - Next.jsは、これらの共通の課題に対する**規約（コンベンション）**を提供します。\n    - **ファイルシステムベースのルーティング**: `pages/`または`app/`ディレクトリにファイルを作成するだけで、自動的にルーティングが設定されます。\n    - **APIルート**: `pages/api`ディレクトリにファイルを作成することで、簡単にAPIエンドポイントを構築できます。これは、フロントエンドとバックエンドを一つのプロジェクトで管理できることを意味します。\n    - **画像最適化**: `next/image`コンポーネントを使用すると、画像の遅延読み込みや最適化を自動で行い、パフォーマンスを向上させます。\n\nこれらの機能により、開発者はアプリケーションのコア機能に集中でき、開発効率が大幅に向上します。\n\n### 4. ゼロコンフィグと拡張性 ⚙️\n\n- **Reactの課題**:\n  - Reactでゼロからプロジェクトを始めるには、WebpackやBabelといった複雑なビルドツールを設定する必要があります。これは、特に初心者にとって学習コストが高く、時間もかかります。\n\n- **Next.jsによる解決**:\n  - Next.jsは、これらのビルド設定の多くを内部で自動的に処理します。開発者は設定ファイルに悩むことなく、すぐにコードを書き始めることができます。\n    - **ゼロコンフィグ**: Next.jsはデフォルトで多くの設定を最適化しており、開発者はすぐに始められます。\n    - **高い拡張性**: 必要に応じて、`next.config.js`ファイルを通じて、WebpackやBabelの設定をカスタマイズすることも可能です。これにより、独自の要件を持つ複雑なプロジェクトにも柔軟に対応できます。\n\n### 5. フルスタック開発のサポート 🤝\n\n- **Reactの課題**:\n  - Reactは主にUIを構築するためのライブラリであり、バックエンド機能（データベース接続、認証など）は別途、Node.js、Express、FastAPIなどのフレームワークを使って構築する必要があります。これにより、フロントエンドとバックエンドで異なる開発環境とデプロイプロセスを管理する必要が生じます。\n\n- **Next.jsによる解決**:\n  - Next.jsは、API RoutesとMiddlewareの機能を提供することで、フロントエンドとバックエンドを一つのプロジェクト内で統合的に開発するフルスタックフレームワークとしての側面を持ちます。\n    - **API Routes**: `pages/api`または`app/api`ディレクトリにファイルを作成することで、サーバーサイドのロジックを簡単に実装できます。これにより、フロントエンドとバックエンドの連携がシームレスになります。\n    - **Middleware**: リクエストがエンドポイントに到達する前に、認証チェックやリダイレクトなどのロジックを実行できます。\n\nこれらの機能により、開発者は1つのコードベースでフロントエンドとバックエンドの両方を管理でき、開発とデプロイの複雑さを大幅に軽減できます。\n\n### まとめ\n\nNext.jsは、React単体では解決が困難だったパフォーマンス、SEO、開発効率といった課題を、フレームワークとしての規約と豊富な機能で克服しています。さらに、ビルド設定の自動化やフルスタック開発のサポートにより、小規模なプロジェクトから大規模なエンタープライズアプリケーションまで、あらゆる規模のWeb開発において強力なツールとなっています。","src/content/docs/nextjsガイド/03_上級/10_why_nextjs.mdx","c0653af6326ec35e","nextjsガイド/03_中級/01_advanced_features",{"id":779,"data":781,"body":785,"filePath":786,"digest":787,"deferredRender":16},{"title":722,"editUrl":16,"head":782,"template":18,"sidebar":783,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":784},{},"## 🛠️ Next.jsの高度な機能\n\nNext.jsは、基本的な機能に加えて、開発者がより高度なアプリケーションを構築するための多くの機能を提供しています。これらの機能を活用することで、アプリケーションのパフォーマンスやユーザー体験を向上させることができます。\n\n### 1. サーバーサイドレンダリング（SSR）\n\nNext.jsは、サーバーサイドレンダリングをサポートしており、ページの初回ロードを高速化し、SEOを向上させることができます。SSRを利用することで、サーバーでHTMLを生成し、クライアントに送信することができます。\n\n#### 実装例\n\n```typescript\n// pages/index.tsx\nimport { GetServerSideProps } from 'next';\n\nexport const getServerSideProps: GetServerSideProps = async (context) => {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n  };\n};\n\nconst HomePage = ({ data }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch1>サーバーサイドレンダリング\u003C/h1>\n      \u003Cpre>{JSON.stringify(data, null, 2)}\u003C/pre>\n    \u003C/div>\n  );\n};\n\nexport default HomePage;\n```\n\n### 2. 静的サイト生成（SSG）\n\n静的サイト生成を使用すると、ビルド時にページを事前にレンダリングし、CDNにデプロイすることで、ユーザーからのリクエストに対して静的なHTMLファイルを直接提供できます。\n\n#### 実装例\n\n```typescript\n// pages/blog/[id].tsx\nimport { GetStaticPaths, GetStaticProps } from 'next';\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const res = await fetch('https://api.example.com/posts');\n  const posts = await res.json();\n\n  const paths = posts.map((post) => ({\n    params: { id: post.id.toString() },\n  }));\n\n  return { paths, fallback: false };\n};\n\nexport const getStaticProps: GetStaticProps = async (context) => {\n  const res = await fetch(`https://api.example.com/posts/${context.params.id}`);\n  const post = await res.json();\n\n  return {\n    props: {\n      post,\n    },\n  };\n};\n\nconst BlogPost = ({ post }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch1>{post.title}\u003C/h1>\n      \u003Cp>{post.content}\u003C/p>\n    \u003C/div>\n  );\n};\n\nexport default BlogPost;\n```\n\n### 3. API Routes\n\nNext.jsのAPI Routesを使用すると、サーバーサイドのロジックを簡単に実装できます。これにより、フロントエンドとバックエンドの機能を一つのプロジェクト内で統合できます。\n\n#### 実装例\n\n```typescript\n// pages/api/hello.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  res.status(200).json({ message: 'Hello from API!' });\n}\n```\n\n### 4. 画像の最適化\n\nNext.jsの`next/image`コンポーネントを使用すると、画像の最適化を自動で行い、パフォーマンスを向上させることができます。\n\n#### 実装例\n\n```typescript\nimport Image from 'next/image';\n\nconst MyImage = () => {\n  return (\n    \u003CImage\n      src=\"/path/to/image.jpg\"\n      alt=\"My Image\"\n      width={500}\n      height={300}\n    />\n  );\n};\n\nexport default MyImage;\n```\n\nこれらの高度な機能を活用することで、Next.jsアプリケーションのパフォーマンスとユーザー体験を大幅に向上させることができます。","src/content/docs/nextjsガイド/03_中級/01_advanced_features.mdx","d3448ee54a3137b2","nextjsガイド/03_中級/02_orm",{"id":788,"data":790,"body":794,"filePath":795,"digest":796,"deferredRender":16},{"title":732,"editUrl":16,"head":791,"template":18,"sidebar":792,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":793},{},"## 🗄️ Next.jsのORM\n\nNext.jsでのデータベース操作には、ORM（Object-Relational Mapping）を使用することで、データベースとのやり取りを簡素化し、コードの可読性と保守性を向上させることができます。ここでは、Prismaを例にとって、Next.jsでのORMの使用方法を紹介します。\n\n### 1. Prismaのセットアップ\n\nPrismaは、Next.jsと組み合わせて使用することができる強力なORMです。以下の手順でPrismaをセットアップします。\n\n#### インストール\n\n```bash\nnpm install @prisma/client\nnpm install prisma --save-dev\n```\n\n#### Prismaの初期化\n\n```bash\nnpx prisma init\n```\n\nこのコマンドを実行すると、Prismaの設定ファイル`prisma/schema.prisma`が生成されます。\n\n### 2. データベーススキーマの定義\n\n`prisma/schema.prisma`ファイルでデータベーススキーマを定義します。\n\n```prisma\n// prisma/schema.prisma\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id    Int    @id @default(autoincrement())\n  name  String\n  email String @unique\n}\n```\n\n### 3. Prisma Clientの生成\n\nスキーマを定義したら、Prisma Clientを生成します。\n\n```bash\nnpx prisma generate\n```\n\n### 4. データベース操作\n\nPrisma Clientを使用して、データベース操作を行います。\n\n#### ユーザーの作成\n\n```typescript\n// pages/api/users.ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport default async function handler(req, res) {\n  if (req.method === 'POST') {\n    const { name, email } = req.body;\n    const user = await prisma.user.create({\n      data: {\n        name,\n        email,\n      },\n    });\n    res.status(201).json(user);\n  } else {\n    res.status(405).json({ message: 'Method Not Allowed' });\n  }\n}\n```\n\n#### ユーザーの取得\n\n```typescript\n// pages/api/users/[id].ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport default async function handler(req, res) {\n  const { id } = req.query;\n  const user = await prisma.user.findUnique({\n    where: { id: Number(id) },\n  });\n  res.status(200).json(user);\n}\n```\n\nPrismaを使用することで、Next.jsアプリケーション内でのデータベース操作が簡単になり、コードの可読性と保守性が向上します。","src/content/docs/nextjsガイド/03_中級/02_orm.mdx","94b0f8bbefe51abc","nextjsガイド/03_中級/03_testing",{"id":797,"data":799,"body":803,"filePath":804,"digest":805,"deferredRender":16},{"title":742,"editUrl":16,"head":800,"template":18,"sidebar":801,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":802},{},"## 🧪 Next.jsのテスト\n\nNext.jsプロジェクトの品質と信頼性を確保するために、ユニットテストは不可欠です。Next.jsの公式ドキュメントでは、テストフレームワークとしてJestとReact Testing Libraryの組み合わせが推奨されています。\n\n### 1. 必要なパッケージをインストール\n\n`create-next-app`でテスト環境をセットアップしていない場合、以下をインストールします。\n\n```bash\nnpm install -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom\n```\n\n### 2. Jestの設定\n\n`jest.config.ts`ファイルを作成し、`jest-environment-jsdom`と`@testing-library/jest-dom`を使用するように設定します。\n\n### 3. コンポーネントのテスト例\n\n例えば、シンプルな「こんにちは」を表示するコンポーネントをテストします。\n\n```typescript\n// components/Greeting.tsx\nexport default function Greeting({ name }: { name: string }) {\n  return \u003Ch1>こんにちは、{name}！\u003C/h1>;\n}\n```\n\n#### テストコード\n\n```typescript\n// __tests__/Greeting.test.tsx\nimport '@testing-library/jest-dom';\nimport { render, screen } from '@testing-library/react';\nimport Greeting from '@/components/Greeting';\n\ndescribe('Greeting', () => {\n  it('should render a greeting with the provided name', () => {\n    render(\u003CGreeting name=\"太郎\" />);\n\n    // 「こんにちは、太郎！」というテキストがドキュメントに存在するか確認\n    expect(screen.getByText('こんにちは、太郎！')).toBeInTheDocument();\n  });\n});\n```\n\nこのテストは、コンポーネントが正しくテキストをレンダリングしているかを確認します。RTLは、UIが正しくユーザーに表示されているかをテストする上で非常に強力です。\n\nこれらの機能は、Next.jsが提供するエコシステムの一部であり、開発者がモダンで高品質なウェブアプリケーションを効率的に構築するための基盤となります。","src/content/docs/nextjsガイド/03_中級/03_testing.mdx","f3154cf55c6fcdb1","nextjsガイド/03_中級/04_caching_strategies",{"id":806,"data":808,"body":812,"filePath":813,"digest":814,"deferredRender":16},{"title":752,"editUrl":16,"head":809,"template":18,"sidebar":810,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":811},{},"## 🗄️ Next.jsのキャッシング戦略\n\nNext.jsは、アプリケーションのパフォーマンスを向上させるために、さまざまなキャッシング戦略を提供しています。これらの戦略を適切に活用することで、ユーザー体験を大幅に向上させることができます。\n\n### 1. 静的サイト生成（SSG）\n\n静的サイト生成を使用すると、ビルド時にページを事前にレンダリングし、CDNにデプロイすることで、ユーザーからのリクエストに対して静的なHTMLファイルを直接提供できます。\n\n#### 実装例\n\n```typescript\n// pages/blog/[id].tsx\nimport { GetStaticPaths, GetStaticProps } from 'next';\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const res = await fetch('https://api.example.com/posts');\n  const posts = await res.json();\n\n  const paths = posts.map((post) => ({\n    params: { id: post.id.toString() },\n  }));\n\n  return { paths, fallback: false };\n};\n\nexport const getStaticProps: GetStaticProps = async (context) => {\n  const res = await fetch(`https://api.example.com/posts/${context.params.id}`);\n  const post = await res.json();\n\n  return {\n    props: {\n      post,\n    },\n  };\n};\n\nconst BlogPost = ({ post }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch1>{post.title}\u003C/h1>\n      \u003Cp>{post.content}\u003C/p>\n    \u003C/div>\n  );\n};\n\nexport default BlogPost;\n```\n\n### 2. サーバーサイドレンダリング（SSR）\n\nNext.jsは、サーバーサイドレンダリングをサポートしており、ページの初回ロードを高速化し、SEOを向上させることができます。SSRを利用することで、サーバーでHTMLを生成し、クライアントに送信することができます。\n\n#### 実装例\n\n```typescript\n// pages/index.tsx\nimport { GetServerSideProps } from 'next';\n\nexport const getServerSideProps: GetServerSideProps = async (context) => {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n  };\n};\n\nconst HomePage = ({ data }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch1>サーバーサイドレンダリング\u003C/h1>\n      \u003Cpre>{JSON.stringify(data, null, 2)}\u003C/pre>\n    \u003C/div>\n  );\n};\n\nexport default HomePage;\n```\n\n### 3. ISR（Incremental Static Regeneration）\n\nISRを使用すると、静的に生成されたページをバックグラウンドで再生成し、最新のデータを提供することができます。これにより、静的サイトのパフォーマンスを維持しつつ、動的なデータを提供できます。\n\n#### 実装例\n\n```typescript\n// pages/blog/[id].tsx\nimport { GetStaticPaths, GetStaticProps } from 'next';\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const res = await fetch('https://api.example.com/posts');\n  const posts = await res.json();\n\n  const paths = posts.map((post) => ({\n    params: { id: post.id.toString() },\n  }));\n\n  return { paths, fallback: 'blocking' };\n};\n\nexport const getStaticProps: GetStaticProps = async (context) => {\n  const res = await fetch(`https://api.example.com/posts/${context.params.id}`);\n  const post = await res.json();\n\n  return {\n    props: {\n      post,\n    },\n    revalidate: 60, // 60秒ごとに再生成\n  };\n};\n\nconst BlogPost = ({ post }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch1>{post.title}\u003C/h1>\n      \u003Cp>{post.content}\u003C/p>\n    \u003C/div>\n  );\n};\n\nexport default BlogPost;\n```\n\nこれらのキャッシング戦略を適切に活用することで、Next.jsアプリケーションのパフォーマンスとユーザー体験を大幅に向上させることができます。","src/content/docs/nextjsガイド/03_中級/04_caching_strategies.mdx","2ba770824898b874","nextjsガイド/03_中級/api利用法",{"id":815,"data":817,"body":821,"filePath":822,"digest":823,"deferredRender":16},{"title":388,"editUrl":16,"head":818,"template":18,"sidebar":819,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":820},{},"## 🤝 外部APIの利用とAPIルートの役割\n\nNext.jsでは、外部のAPIを利用する場合と、プロジェクト内に独自のAPIエンドポイントを作成する場合の2つが考えられます。外部APIを直接クライアントサイドから呼び出すことも可能ですが、セキュリティやパフォーマンスの観点から、**APIルート（Route Handler）**を介して呼び出すのが推奨されます。\n\n### 1. 外部APIをAPIルートから呼び出す 📞\n\n外部APIキーなどの機密情報をフロントエンドに公開することなく、安全にデータを取得するのがこの方法です。Next.jsのAPIルートがサーバーサイドで外部APIを呼び出し、その結果をフロントエンドに返します。\n\n#### APIルートの作成 (`app/api/data/route.ts`)\n\nApp Routerでは、`app/api`ディレクトリにAPIエンドポイントを作成します。\n\n```typescript\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n  try {\n    // 外部APIキーは環境変数から安全に取得\n    const apiKey = process.env.EXTERNAL_API_KEY;\n    const res = await fetch(`https://api.example.com/data?key=${apiKey}`);\n    \n    if (!res.ok) {\n      throw new Error('Failed to fetch data from external API');\n    }\n    \n    const data = await res.json();\n    \n    // 取得したデータをフロントエンドに返す\n    return NextResponse.json({ data });\n  } catch (error) {\n    console.error('API call failed:', error);\n    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });\n  }\n}\n```\n\n#### コンポーネントからの呼び出し\n\n作成したAPIルートは、通常のAPIエンドポイントとしてフロントエンドから呼び出せます。\n\n```typescript\n// components/DataDisplay.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\n\nexport default function DataDisplay() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    async function fetchData() {\n      const res = await fetch('/api/data');\n      const result = await res.json();\n      setData(result.data);\n      setLoading(false);\n    }\n    fetchData();\n  }, []);\n\n  if (loading) return \u003Cdiv>Loading...\u003C/div>;\n  if (!data) return \u003Cdiv>No data found.\u003C/div>;\n\n  return (\n    \u003Cdiv>\n      \u003Ch1>Data from API:\u003C/h1>\n      \u003Cpre>{JSON.stringify(data, null, 2)}\u003C/pre>\n    \u003C/div>\n  );\n}\n```\n\n### 2. サーバーコンポーネントからの直接呼び出し ⚡️\n\nNext.jsのサーバーコンポーネントでは、外部APIを直接呼び出すことができ、APIルートを介す必要はありません。これにより、データ取得ロジックがコンポーネントの近くに配置され、シンプルになります。\n\n#### サーバーコンポーネントでのデータ取得 (`app/page.tsx`)\n\n```typescript\n// app/page.tsx\nexport default async function Page() {\n  // 外部APIキーは環境変数から安全に取得\n  const apiKey = process.env.EXTERNAL_API_KEY;\n  const res = await fetch(`https://api.example.com/data?key=${apiKey}`);\n  const data = await res.json();\n\n  return (\n    \u003Cdiv>\n      \u003Ch1>Data fetched on the server:\u003C/h1>\n      \u003Cpre>{JSON.stringify(data, null, 2)}\u003C/pre>\n    \u003C/div>\n  );\n}\n```\n\nこのアプローチは、APIキーを安全に保ちつつ、クライアントサイドでのデータ取得や状態管理の複雑さを避けることができます。この処理はサーバー上で行われるため、クライアントに機密情報が公開されることはありません。\n\n### どちらを選ぶべきか？\n\n- **APIルートを介す場合**:\n  - **認証**: 外部APIを呼び出す前に、カスタムの認証やバリデーションロジックを実行する必要がある場合。\n  - **データ加工**: 外部APIから取得したデータを複数のコンポーネントで利用するために、複雑な加工や変換が必要な場合。\n  - **クライアントでの利用**: データの取得をクライアントサイドの状態管理ライブラリ（Zustand, Reduxなど）と連携させたい場合。\n\n- **サーバーコンポーネントから直接呼び出す場合**:\n  - **シンプルさ**: コンポーネントのレンダリングに必要なデータを直接取得するだけで良い場合。\n  - **パフォーマンス**: サーバーコンポーネントのキャッシュ機能を利用して、パフォーマンスを最適化したい場合。\n\nまとめると、Next.jsは外部APIを利用するための柔軟な選択肢を提供します。プロジェクトの要件に応じて、APIルートを介して中間層を設けるか、サーバーコンポーネントから直接呼び出すかを決定します。","src/content/docs/nextjsガイド/03_中級/API利用法.mdx","a064909f7ef0cefc","nextjsガイド/03_中級/05_csrssr",{"id":824,"data":826,"body":831,"filePath":832,"digest":833,"deferredRender":16},{"title":827,"editUrl":16,"head":828,"template":18,"sidebar":829,"pagefind":16,"draft":20},"CSR・SSR",[],{"hidden":20,"attrs":830},{},"## 🔄 レンダリングの比較: CSR vs. SSR\n\nWebページのレンダリング方法には主に2つのアプローチがあります。Next.jsは、これら両方の利点を組み合わせることで、高速なパフォーマンスと優れた開発体験を提供します。\n\n### 1. クライアントサイドレンダリング (CSR) 🖥️\n\nCSRは、レンダリングをブラウザに任せる方式です。サーバーは最低限のHTMLとJavaScriptを送信し、データ取得やDOM構築はすべてクライアント（ブラウザ）で行われます。\n\n- **仕組み**: 最初に空のHTMLとJavaScriptの「シェル」が送られます。ブラウザはJavaScriptを実行し、APIからデータをフェッチして動的にコンテンツを生成します。\n\n- **利点**:\n  - 高速なページ遷移: 初回ロード後は、必要なデータだけをAPIで取得し、DOMを部分的に更新するため、ページ間の移動が非常に滑らかです。\n  - インタラクティブ: ユーザーの操作に応じて動的に変化するUI（例：フォーム入力、グラフ）の実装に適しています。\n\n- **欠点**:\n  - 初回表示までの遅延: JavaScriptとデータがすべてロードされるまで、ユーザーは何も表示されない「白い画面」を見ることになります。\n  - SEOへの影響: 検索エンジンのクローラーが初期に完全なコンテンツを取得できないため、SEOのパフォーマンスに影響する可能性があります。\n\n### 2. サーバーサイドレンダリング (SSR) 💻\n\nSSRは、レンダリングをサーバーで行う方式です。\n\n- **仕組み**: ユーザーからのリクエストに対して、サーバーがデータを取得し、完成したHTMLを生成してブラウザに送信します。ブラウザは受け取ったHTMLをすぐに表示し、その後、JavaScriptがロードされてインタラクティブな機能が追加されます（これをハイドレーションと呼びます）。\n\n- **利点**:\n  - 高速な初回表示: ユーザーはすぐにコンテンツを見ることができ、ユーザー体験が向上します。\n  - 優れたSEO: 検索エンジンのクローラーは完成したHTMLを受け取るため、コンテンツを正確にインデックスできます。\n\n- **欠点**:\n  - サーバー負荷: リクエストごとにサーバーがHTMLを生成するため、アクセス数が増えるとサーバーの負荷が高まります。\n  - ページ遷移: ページを移動するたびにサーバーが新しいHTMLを生成するため、CSRに比べると遷移が遅く感じることがあります。\n\n### 3. Next.jsにおけるハイブリッドレンダリング 🧩\n\nNext.jsの最新のApp Routerは、これらのレンダリング方法を組み合わせて利用するハイブリッドレンダリングを標準としています。\n\n- **サーバーコンポーネント (SSR)**: デフォルトでは、すべてのコンポーネントがサーバーでレンダリングされます。これにより、ページの大部分は高速に表示され、SEOに有利な状態が保たれます。\n\n- **クライアントコンポーネント (CSR)**: ユーザーインタラクションが必要なコンポーネントのみを'use client'ディレクティブでクライアントコンポーネントとしてマークします。これにより、フォーム、アニメーション、状態管理が必要な部分だけがCSRとして動作し、パフォーマンスとユーザー体験を両立させます。\n\nこのハイブリッドアプローチにより、開発者はページ全体をCSRにするかSSRにするかという二者択一から解放され、より効率的でパフォーマンスに優れたアプリケーションを構築できます。\n\n## 🔄 CSRとSSRのレンダリングフローを比較する図解\n\nクライアントサイドレンダリング（CSR）とサーバーサイドレンダリング（SSR）の主な違いは、誰がいつ、ページのコンテンツを生成するかです。この違いは、ページの表示速度、SEO、そしてサーバー負荷に影響します。Next.jsは、この両方のメリットを活かすハイブリッドレンダリングで、これらの問題を解決します。\n\n### 1. クライアントサイドレンダリング (CSR) 🖥️\n\nCSRでは、レンダリングの大部分をブラウザが担当します。サーバーは最小限のHTMLとJavaScriptの**「骨組み」**だけを送り、ブラウザがAPIからデータを取得してページを構築します。\n\n- **レンダリングフロー**:\n  1. ユーザーがリクエストを送る。\n  2. サーバーは空のHTMLとJavaScriptを送り返す。\n  3. ブラウザはHTMLを表示する。この時点ではまだコンテンツは表示されない。\n  4. ブラウザがJavaScriptをダウンロードし、実行を開始。\n  5. ブラウザはAPIからデータを取得する。\n  6. ブラウザが取得したデータを使ってDOMを構築し、ページにコンテンツが表示される。\n\n### 2. サーバーサイドレンダリング (SSR) 💻\n\nSSRでは、レンダリングをサーバーが担当します。サーバーがデータを取得し、完全にレンダリングされたHTMLをブラウザに送り返します。\n\n- **レンダリングフロー**:\n  1. ユーザーがリクエストを送る。\n  2. サーバーはページに必要なデータを取得し、完全にレンダリングされたHTMLを生成する。\n  3. サーバーはそのHTMLをブラウザに送り返す。\n  4. ブラウザはHTMLをすぐに表示する。この時点でコンテンツは見える状態になっている。\n  5. ブラウザがJavaScriptをダウンロードし、実行を開始（ハイドレーション）。これにより、ボタンのクリックなど、インタラクティブな機能が有効になる。\n\n### 3. Next.jsのハイブリッドレンダリング 🧩\n\nNext.jsは、CSRとSSRの長所を組み合わせることで、ハイブリッドレンダリングという最適なアプローチを提供します。\n\n- **サーバーコンポーネント (SSR)**: デフォルトでサーバーサイドレンダリングが行われます。これにより、初回ロードが速くなり、SEOに強くなります。\n\n- **クライアントコンポーネント (CSR)**: `use client`ディレクティブを使うことで、一部のコンポーネントだけをCSRとしてレンダリングできます。これにより、フォームやアニメーションなど、インタラクティブな要素を持つ部分だけをクライアントで動かし、不必要なサーバー負荷を軽減します。\n\nこのハイブリッドなアプローチによって、Next.jsはパフォーマンスとユーザー体験を高いレベルで両立させています。\n\n## 🔄 CSRとSSRの使い分け：具体的なシナリオ\n\nNext.jsのハイブリッドレンダリングは強力ですが、ページのどの部分をCSRにするか、SSRにするかを見極めることが重要です。一般的なアプリケーションの機能ごとに、最適なレンダリング方法を以下に示します。\n\n### 1. サーバーサイドレンダリング（SSR）が最適なシーン 💻\n\nSSRは、コンテンツが静的または頻繁に更新されるが、リアルタイム性は不要なページに最適です。\n\n- **ブログ記事やニュースサイト**:\n  - **理由**: 記事の内容は頻繁に変わりますが、すべてのユーザーに対して同じコンテンツを表示するため、リクエストごとにサーバーでレンダリングすることでSEOに強くなります。\n  - **実装**: `app/blog/[slug]/page.tsx` のようなサーバーコンポーネントで記事データをフェッチし、HTMLを生成します。\n\n- **ECサイトの商品詳細ページ**:\n  - **理由**: 商品情報（価格、在庫、説明）は常に最新である必要がありますが、SEOも重要です。クローラーが商品ページを正しくインデックスできるように、サーバーでレンダリングします。\n  - **実装**: `app/products/[id]/page.tsx`で商品IDを基にデータを取得し、ページをレンダリングします。\n\n- **プロフィールページやダッシュボードの初期表示**:\n  - **理由**: ユーザーがログインした後に最初に表示されるページは、認証情報に基づいてデータをサーバーで取得し、高速に表示させるのが良いでしょう。\n  - **実装**: ユーザーのトークンをCookieから読み取り、`app/dashboard/page.tsx`のようなサーバーコンポーネントでユーザー情報をフェッチします。\n\n### 2. クライアントサイドレンダリング（CSR）が最適なシーン 🖥️\n\nCSRは、ユーザーの操作に強く依存するインタラクティブなUIや、リアルタイム性が求められるコンポーネントに最適です。\n\n- **フォーム、モーダル、アニメーション**:\n  - **理由**: これらのUI要素は、ユーザーの入力やクリックに応じて動的に変化するため、JavaScriptによるクライアントサイドでの制御が必要です。\n  - **実装**: `app/form.tsx`のようなファイルで、'use client'ディレクティブを宣言し、`useState`や`useEffect`などのクライアントサイドのフックを使用します。\n\n- **検索フィルター、ソート機能**:\n  - **理由**: ユーザーが検索ボックスに文字を入力するたびに、サーバーにリクエストを送るのは非効率です。クライアントサイドで状態を管理し、APIリクエストを最適化する方が良いです。\n  - **実装**: `app/search.tsx`のようなクライアントコンポーネントで、検索クエリの状態を管理し、ユーザーの入力に応じてリアルタイムで結果を表示します。\n\n- **リアルタイムなデータ表示**:\n  - **理由**: 株価チャートやライブチャットなど、継続的にサーバーと通信してデータを更新する必要がある場合は、WebSocket通信やポーリングをクライアントコンポーネントで実装します。\n  - **実装**: 状態管理ライブラリ（Zustandなど）と組み合わせて、`use client`で宣言したコンポーネントでリアルタイムデータを扱います。\n\n### 3. ハイブリッドレンダリングの実践 🧩\n\nNext.jsでは、CSRとSSRを同じページで組み合わせることができます。\n\n- **ECサイトの商品詳細ページ**:\n  - **全体**: 商品情報（名前、価格、説明）は**サーバーコンポーネント（SSR）**でレンダリングし、高速な初回表示とSEOを確保します。\n  - **インタラクティブな部分**: 「カートに追加」ボタンや、ユーザーレビューの星評価コンポーネントは、'use client'を宣言した**クライアントコンポーネント（CSR）**として実装します。これにより、JavaScriptがロードされた後、これらの要素がインタラクティブになります。\n\nこのように、Next.jsは「初期表示とSEO」にはSSR、「ユーザーインタラクション」にはCSRを使い分けることで、最高のパフォーマンスと開発体験を実現します。\n\n## 🔄 CSRとSSRの使い分け：具体的な実装例\n\nNext.jsにおけるハイブリッドレンダリングの真価は、1つのページ内でサーバーコンポーネント（SSR）とクライアントコンポーネント（CSR）を組み合わせて使う点にあります。ここでは、その具体的なコード例として、ECサイトの商品詳細ページを題材に解説します。\n\n### 1. サーバーコンポーネント（SSR）: 商品情報の表示 💻\n\nこのコンポーネントはサーバーでレンダリングされ、SEOに有利な状態でユーザーに届きます。ここでは、データをフェッチし、静的なUIを生成する役割を担います。\n\n- **役割**: ユーザーリクエスト時に、URLのidから商品データを取得し、HTMLを生成する。\n- **使用例**: 商品名、価格、説明、画像など。\n\n```typescript\n// app/products/[id]/page.tsx\n// このファイルはデフォルトでサーバーコンポーネントです\n\nimport AddToCartButton from '@/components/AddToCartButton';\n\n// サーバーコンポーネント内で直接データを取得\nasync function getProduct(id: string) {\n  const res = await fetch(`https://api.example.com/products/${id}`);\n  return res.json();\n}\n\nexport default async function ProductPage({ params }: { params: { id: string } }) {\n  const product = await getProduct(params.id);\n\n  return (\n    \u003Cdiv className=\"container\">\n      {/* SEOに重要な部分をSSRでレンダリング */}\n      \u003Ch1 className=\"text-3xl font-bold\">{product.name}\u003C/h1>\n      \u003Cp className=\"text-2xl\">${product.price}\u003C/p>\n      \u003Cimg src={product.image_url} alt={product.name} />\n      \u003Cp>{product.description}\u003C/p>\n\n      {/* インタラクティブな部分はクライアントコンポーネントに任せる */}\n      \u003CAddToCartButton productId={product.id} />\n    \u003C/div>\n  );\n}\n```\n\nこのProductPageは、サーバーでレンダリングされるため、初回のロードが非常に速く、検索エンジンがコンテンツを正確に読み取ることができます。\n\n### 2. クライアントコンポーネント（CSR）: 「カートに追加」ボタン 🛒\n\nこのコンポーネントは'use client'ディレクティブを持つため、ブラウザでレンダリングされます。ユーザーの操作に応じた状態変更やAPI呼び出しを扱います。\n\n- **役割**: ユーザーのクリックイベントを処理し、カートの状態を更新する。\n- **使用例**: カウントアップ、カートへの商品追加、モーダル表示など。\n\n```typescript\n// components/AddToCartButton.tsx\n'use client';\n\nimport { useState } from 'react';\n\nexport default function AddToCartButton({ productId }: { productId: string }) {\n  const [isAdding, setIsAdding] = useState(false);\n\n  const handleAddToCart = async () => {\n    setIsAdding(true);\n    // APIルートを呼び出し、カートに商品を追加\n    await fetch('/api/cart', {\n      method: 'POST',\n      body: JSON.stringify({ productId }),\n    });\n    setIsAdding(false);\n  };\n\n  return (\n    \u003Cbutton\n      onClick={handleAddToCart}\n      disabled={isAdding}\n      className=\"bg-green-500 text-white p-2 rounded\"\n    >\n      {isAdding ? '追加中...' : 'カートに追加'}\n    \u003C/button>\n  );\n}\n```\n\nこのAddToCartButtonは、useStateフックを使用しているため、必ずクライアントで実行される必要があります。親のサーバーコンポーネントからpropsとしてproductIdを受け取り、その情報を使ってAPIを呼び出します。\n\n## まとめ：ハイブリッドレンダリングの利点\n\nこの実装例では、**ページのコアコンテンツ（SSR）とインタラクティブな機能（CSR）**が明確に分離されています。これにより、以下のメリットが生まれます。\n\n- **パフォーマンス**: 初期ロードが速くなり、ユーザーはすぐに商品情報を見ることができます。\n- **開発体験**: サーバーとクライアントのロジックが分離されるため、コードの見通しが良くなります。\n- **SEO**: サーバーで生成されたHTMLにより、検索エンジンがページを正しくインデックスできます。\n\nNext.jsは、このハイブリッドなアプローチによって、ウェブ開発のベストプラクティスを簡単に適用できるようにしています。\n\nNext.jsにおけるハイブリッドレンダリングは、**サーバーサイドレンダリング（SSR）とクライアントサイドレンダリング（CSR）**の長所を組み合わせることで、ウェブページのパフォーマンスとユーザー体験を最適化する強力なアプローチです。この戦略では、SEOに重要な静的コンテンツを高速に表示し、ユーザーインタラクションが必要な部分だけを動的にロードします。\n\n### 1. サーバーコンポーネント (SSR) の役割\n\nサーバーコンポーネントは、レンダリングをサーバー上で行うため、データの取得からHTMLの生成までを単一のリクエスト内で完結させます。これにより、ブラウザに渡されるのは完全にレンダリングされたHTMLとなり、ユーザーはすぐにコンテンツを見ることができます。これは、ブログ記事やECサイトの商品詳細ページのように、SEOが重要で、かつ初回表示が速いことが求められるページに最適です。\n\n- **提供されたコード例**では、`app/products/[id]/page.tsx`がサーバーコンポーネントとして機能しています。\n- `getProduct(id)`関数は、サーバーサイドで直接外部APIを呼び出し、商品データを取得します。\n- このデータは、`\u003Ch1>`や`\u003Cimg>`タグなどのHTML要素に直接埋め込まれてレンダリングされます。\n- このプロセスはクライアントサイドのJavaScriptに依存しないため、初回表示が非常に高速になり、検索エンジンのクローラーもコンテンツを正確に読み取ることができます。\n\n### 2. クライアントコンポーネント (CSR) の役割\n\nクライアントコンポーネントは、ブラウザでレンダリングされ、ユーザーの操作に応じて動的に動作する部分を担います。'use client'ディレクティブで明示的に宣言し、`useState`や`useEffect`といったReactのフックを利用できます。これにより、フォームの入力、ボタンのクリック、リアルタイムなデータの更新など、インタラクティブな機能を実現します。\n\n- **提供されたコード例**では、`components/AddToCartButton.tsx`がクライアントコンポーネントです。\n- `'use client'`ディレクティブが宣言されているため、このコンポーネントとその子孫コンポーネントはクライアントでレンダリングされます。\n- `useState`フックを使ってボタンの状態（例：isAdding）を管理し、ユーザーのクリックイベントに応じてUIを更新します。\n- `fetch` APIを使い、非同期でサーバーのAPIルート（`/api/cart`）を呼び出してカートに商品を追加するロジックが含まれています。\n\n### 3. ハイブリッドレンダリングの実践例 🧩\n\nECサイトの商品詳細ページは、ハイブリッドレンダリングの理想的な例です。\n\n- **SSR部分**: 商品名、価格、説明、画像といった静的かつSEOに重要な情報は、サーバーコンポーネントでレンダリングされます。\n- **CSR部分**: 「カートに追加」ボタンのように、ユーザーの操作に応じて状態が変化する部分は、クライアントコンポーネントとして分離されます。\n\nこの分離により、Next.jsはページの「表示」と「インタラクション」を明確に分け、それぞれの最適な環境で実行します。ユーザーはすぐにコンテンツを見ることができ、その後にJavaScriptがロードされてインタラクティブな機能が有効になるため、パフォーマンスとユーザビリティの両方が向上します。\n\nこのアプローチは、Next.jsが現代のウェブ開発における多くの課題（SEO、初回ロード速度、ユーザー体験）を解決するための核心的な戦略と言えます。","src/content/docs/nextjsガイド/03_中級/05_CSR・SSR.mdx","d3b3a078ed8d63b1","nextjsガイド/03_中級/ws通信",{"id":834,"data":836,"body":841,"filePath":842,"digest":843,"deferredRender":16},{"title":837,"editUrl":16,"head":838,"template":18,"sidebar":839,"pagefind":16,"draft":20},"ws利用法",[],{"hidden":20,"attrs":840},{},"## 🌐 WebSocket（WS）通信の概要\n\nWebSocket（WS）通信は、クライアントとサーバー間で永続的な接続を確立し、双方向かつリアルタイムのデータ交換を可能にする技術です。これは、リアルタイムチャットや通知システム、オンラインゲームなどのアプリケーションに不可欠です。\n\n### 1. Next.jsにおけるWebSocket通信\n\nNext.jsは主にサーバーレス関数としてデプロイされるため、長期間の接続を維持するWebSocketサーバーを直接ホストするのには向いていません。代わりに、外部のWebSocketサーバーやサービスと連携するのが一般的です。\n\n- **外部WebSocketサービスの利用**\n  - Vercelのようなサーバーレスプラットフォームにデプロイする場合、PusherやAblyといったマネージドサービスを利用するのが最も現実的です。\n\n- **仕組み**:\n  - Next.jsのAPIルート（Route Handler）で、サービスの認証トークンを取得します。\n  - クライアントサイドのコンポーネントで、取得したトークンを使ってサービスに接続します。\n  - メッセージの送受信はすべてサービスを介して行われ、Next.jsサーバーは関与しません。\n\n### 2. RailsにおけるWebSocket通信\n\nRailsでは、Action Cableというフレームワークが組み込まれており、WebSocket通信を簡単に実装できます。\n\n- **仕組み**:\n  - **チャネル（Channel）の作成**: `bin/rails generate channel \u003Cchannel_name>`コマンドで、サーバーサイドのロジックを管理するチャネルを生成します。\n  - **ストリーム（Stream）への登録**: クライアントがチャネルに接続すると、特定のストリームに登録され、そのストリームにブロードキャストされたメッセージを受け取ります。\n  - **メッセージのブロードキャスト**: サーバーサイドのどこからでも、`ActionCable.server.broadcast`を使って、特定のストリームに接続している全クライアントにメッセージを送ることができます。\n\n- **Next.jsとの連携**:\n  - **フロントエンド**: Next.jsのコンポーネントで、JavaScriptのActionCableクライアントライブラリを使用してRailsのWebSocketサーバーに接続します。\n  - **バックエンド**: Railsのチャネルでメッセージを処理し、リアルタイムでNext.jsのクライアントにブロードキャストします。\n\n### 3. PhoenixにおけるWebSocket通信\n\nPhoenixは、Elixirで構築されたWebフレームワークで、**「Channel」**という独自のWebSocket実装をコア機能として持っています。PhoenixのWebSocketは、その優れたスケーラビリティと耐障害性で知られています。\n\n- **仕組み**:\n  - **チャネル（Channel）の定義**: Phoenixのチャネルは、Railsのチャネルと同様に、リアルタイムなロジックをカプセル化します。\n  - **トピック（Topic）への参加**: クライアントは、特定のトピック（例: \"room:lobby\"）に参加することで、そのトピックにブロードキャストされるメッセージを購読します。\n  - **メッセージのプッシュ**: サーバーサイドのチャネルは、`push`メソッドを使ってトピックにメッセージをプッシュし、接続中のクライアントすべてに配信されます。\n\n- **Next.jsとの連携**:\n  - **フロントエンド**: JavaScriptクライアントライブラリの`phoenix.js`をNext.jsプロジェクトにインストールし、Phoenixサーバーに接続します。\n  - **バックエンド**: Phoenixチャネルでメッセージを処理し、Next.jsのクライアントに効率的にブロードキャストします。\n\n### まとめ\n\n| フレームワーク | 特徴 | 連携方法 |\n|----------------|------|----------|\n| Next.js        | サーバーレス向き。直接ホスティングは困難。 | 外部WebSocketサービス（Pusher, Ablyなど）を利用。 |\n| Rails          | Action Cableが組み込み。WebSocketサーバーを簡単に立ち上げ可能。 | Next.jsからAction Cableクライアント経由で接続。 |\n| Phoenix        | Channelがコア機能。極めて高いスケーラビリティが魅力。 | Next.jsから`phoenix.js`ライブラリ経由で接続。 |\n\nNext.js単体ではWebSocketサーバーをホスティングするのに限界があるため、RailsやPhoenixのようなフルスタックなバックエンドと連携することで、リアルタイムな機能を堅牢に実装できます。","src/content/docs/nextjsガイド/03_中級/ws通信.mdx","d90ebb06360e8eac","nextjsガイド/03_中級/重要機能",{"id":844,"data":846,"body":851,"filePath":852,"digest":853,"deferredRender":16},{"title":847,"editUrl":16,"head":848,"template":18,"sidebar":849,"pagefind":16,"draft":20},"重要機能",[],{"hidden":20,"attrs":850},{},"## 📦 Lazy Loading（遅延ロード）とCode Splitting（コード分割）\n\nLazy Loadingとは、ユーザーが実際に必要とするまで、コンポーネントやアセットのロードを遅らせる技術です。Next.jsでは、これを簡単に実装できます。Code Splittingは、アプリケーション全体のJavaScriptバンドルを、小さなチャンクに分割するプロセスです。Next.jsはデフォルトでこれを自動的に行いますが、Lazy Loadingと組み合わせることで、さらに最適化できます。\n\n### 1. Dynamic Imports（動的インポート）\n\nNext.jsでLazy Loadingを実装する最も一般的な方法は、ReactのlazyやSuspenseと組み合わせて**Dynamic Imports（動的インポート）**を使うことです。これにより、特定のコンポーネントが画面に表示されるまで、そのコンポーネントのコードをロードしないように指示できます。\n\n#### 実装例：インタラクティブな地図コンポーネント\n\n地図コンポーネントは通常、サイズが大きく、ページ全体のパフォーマンスを低下させることがあります。これをLazy Loadingで最適化します。\n\n```typescript\n// components/Map.tsx\n// このコンポーネントは非常に大きいと仮定\n'use client';\n\nimport { MapContainer, TileLayer, Marker, Popup } from 'react-leaflet';\n\nexport default function Map() {\n  return (\n    \u003CMapContainer center={[51.505, -0.09]} zoom={13} style={{ height: '400px', width: '100%' }}>\n      \u003CTileLayer url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" />\n      \u003CMarker position={[51.505, -0.09]}>\n        \u003CPopup>ここにいます！\u003C/Popup>\n      \u003C/Marker>\n    \u003C/MapContainer>\n  );\n}\n```\n\n#### 動的インポートで地図コンポーネントを遅延ロード\n\n`next/dynamic`を使って、この地図コンポーネントを必要なときだけロードするようにします。\n\n```typescript\n// app/contact/page.tsx\n'use client';\n\nimport dynamic from 'next/dynamic';\nimport LoadingSpinner from '@/components/LoadingSpinner';\n\n// Dynamic ImportでMapコンポーネントを遅延ロード\nconst DynamicMap = dynamic(() => import('@/components/Map'), {\n  ssr: false, // サーバーサイドではレンダリングしない\n  loading: () => \u003CLoadingSpinner />,\n});\n\nexport default function ContactPage() {\n  return (\n    \u003Cdiv>\n      \u003Ch1>お問い合わせ\u003C/h1>\n      \u003Cp>私たちのオフィスはこちらです。\u003C/p>\n      {/* ユーザーがこの部分にスクロールするか、表示されるまでロードを遅延 */}\n      \u003CDynamicMap />\n    \u003C/div>\n  );\n}\n```\n\n- **ssr: false**: このオプションは、コンポーネントがクライアントサイドでのみレンダリングされるように指定します。地図コンポーネントはブラウザのAPIに依存するため、この設定が重要です。\n- **loading**: コンポーネントがロードされる間に表示する代替UI（ローディングスピナーなど）を指定できます。\n\n### 2. Next.jsの自動コード分割\n\nNext.jsのApp Routerは、ページやコンポーネントの単位で自動的にコードを分割します。これにより、ユーザーは必要なページのJavaScriptだけをダウンロードします。\n\n- **例**: ユーザーが/aboutページにアクセスした場合、Next.jsは/aboutページに必要なコードのみをロードします。/contactページのコードはロードされません。\n\n- **利点**:\n  - バンドルサイズの削減: ページのレンダリングに必要なコードだけをロードするため、初期ロードが高速になります。\n  - メモリ使用量の削減: 不要なコードをメモリにロードしないため、ブラウザのメモリ使用量を抑えられます。\n\n### 3. 画像の最適化とLazy Loading\n\nNext.jsの`next/image`コンポーネントも、デフォルトで画像のLazy Loadingをサポートしています。\n\n- **仕組み**: 画面外の画像は、ユーザーがスクロールして表示領域に入るまでロードされません。これにより、ページのLCP（Largest Contentful Paint）スコアが改善され、ページの初期ロードが高速になります。\n\n- **使用法**: `\u003Cimg>`タグの代わりに`next/image`コンポーネントを使用するだけです。\n\n```typescript\nimport Image from 'next/image';\n\nfunction ProductImage({ src, alt }) {\n  return (\n    \u003CImage\n      src={src}\n      alt={alt}\n      width={500}\n      height={300}\n      priority // この画像は優先してロードする\n    />\n  );\n}\n```\n\n`next/image`は、画像のサイズを自動的に最適化し、ブラウザがサポートする最新の形式（WebPなど）で提供する機能も備えています。\n\n## 📦 Next.jsにおけるキャッシュ戦略\n\nNext.jsのApp Routerは、デフォルトでサーバーコンポーネントのキャッシュ機能を内蔵しています。これにより、同じデータを繰り返しフェッチすることなく、高速なレンダリングが可能になります。キャッシュには主に3つの種類があり、それぞれが異なる役割を果たします。\n\n### 1. Request Memoization (リクエストメモ化)\n\nリクエストメモ化は、同じリクエスト内で、重複するデータフェッチを自動的に排除する仕組みです。`fetch()`関数やReactの`cache()`APIがこれを実現します。\n\n- **仕組み**: サーバーコンポーネント内で同じURLに対して複数の`fetch()`呼び出しがあっても、Next.jsは1回だけリクエストを送信し、その結果をキャッシュして他の呼び出しで再利用します。\n\n- **利点**:\n  - サーバーリクエストの削減: 複数のコンポーネントが同じデータを必要とする場合に、重複したAPI呼び出しを防ぎます。\n  - 開発体験の向上: 開発者はデータの重複を気にせず、各コンポーネントで必要なデータを自由にフェッチできます。\n\n#### 実装例:\n\n```typescript\n// app/products/[id]/page.tsx\nasync function getProduct(id: string) {\n  // 同じリクエスト内で複数回呼び出されても、このAPIは1回だけ実行される\n  const res = await fetch(`https://api.example.com/products/${id}`);\n  return res.json();\n}\n\nexport default async function ProductPage({ params }: { params: { id: string } }) {\n  // ページのヘッダーで同じデータを取得\n  const headerProduct = await getProduct(params.id);\n\n  // ページのメインコンテンツで同じデータを取得\n  const mainProduct = await getProduct(params.id);\n\n  // ... 実際には1回のAPIリクエストしか発生しない\n  return (\n    \u003Cdiv>\n      \u003Ch1>{mainProduct.name}\u003C/h1>\n      {/* ... */}\n    \u003C/div>\n  );\n}\n```\n\n### 2. Full Route Cache (フルルートキャッシュ)\n\nフルルートキャッシュは、レンダリングされたサーバーコンポーネントツリー全体をキャッシュする仕組みです。\n\n- **仕組み**: 初回リクエスト時にレンダリングされたサーバーコンポーネントのHTMLとReact Server Component Payload (RSC)をキャッシュします。同じルートに再度アクセスがあった場合、サーバーは再レンダリングをせず、キャッシュされたコンテンツをすぐに返します。\n\n- **利点**:\n  - 高速なページ表示: ユーザーは瞬時にキャッシュされたページを見ることができます。\n  - サーバー負荷の軽減: 繰り返し同じページがリクエストされても、サーバーの処理が不要になります。\n\n- **有効化/無効化**:\n  - デフォルトで有効です。\n  - 動的な関数（`cookies()`や`headers()`など）を使用したり、**動的なレンダリング（Dynamic Rendering）**を強制すると、このキャッシュは無効になります。\n\n### 3. Data Cache (データキャッシュ)\n\nデータキャッシュは、`fetch()` APIの結果をサーバーに永続的に保存する仕組みです。これにより、同じAPIリクエストが複数回発生しても、再フェッチすることなくキャッシュされたデータを再利用できます。\n\n- **仕組み**:\n  - **デフォルト**: `fetch()`は、**再検証（revalidation）が設定されていない限り、永続的にキャッシュされます。これは静的サイト生成（SSG）**に似ています。\n  - **再検証（Revalidation）**: 一定時間経過後（`revalidate`オプション）や、特定のイベント時（`revalidatePath`や`revalidateTag`）にキャッシュを無効化し、最新のデータを再フェッチできます。\n\n#### 実装例（再検証）:\n\n```typescript\n// app/blog/page.tsx\n// 60秒ごとにキャッシュを再検証する\nexport async function getPosts() {\n  const res = await fetch('https://api.example.com/posts', { next: { revalidate: 60 } });\n  return res.json();\n}\n\nexport default async function BlogPage() {\n  const posts = await getPosts();\n  // ... 投稿リストを表示\n}\n```\n\nこれらのキャッシュ戦略は、Next.jsがパフォーマンスを最適化する上で欠かせない機能です。適切に活用することで、アプリケーションの応答速度を大幅に向上させることができます。\n\n## 🌐 Server Actions (サーバーアクション)\n\nServer Actionsは、Next.js 13.4で導入された機能で、サーバーコンポーネント内から直接サーバー側の関数を実行できるようにするものです。これにより、APIルートを明示的に作成することなく、フォームの送信やデータベースの更新といった処理を簡潔に実装できます。\n\n- **特徴**:\n  - **シンプルさ**: クライアントからサーバーへデータを送信する際のボイラープレートコード（APIルートの定義、クライアントでのfetch呼び出しなど）が不要になります。\n  - **パフォーマンス**: フォームのデータが直接サーバー関数に渡されるため、クライアントへのJavaScriptの送信量が削減されます。\n  - **安全性**: クライアントコンポーネントから直接サーバーのアクションを呼び出すことも可能ですが、Server Actionsは自動的にCSRF攻撃などのセキュリティリスクを軽減します。\n\n#### 実装例: フォームの送信\n\n```typescript\n// app/contact/page.tsx\nimport { revalidatePath } from 'next/cache';\nimport { saveMessage } from '@/lib/messages'; // データベースに保存するサーバー側の関数\n\n// Server Actionとして定義\nasync function createMessage(formData: FormData) {\n  'use server'; // Server Actionを有効化\n  \n  const name = formData.get('name') as string;\n  const email = formData.get('email') as string;\n  const message = formData.get('message') as string;\n  \n  await saveMessage({ name, email, message });\n  \n  // キャッシュを無効化し、ページを最新の状態に再検証\n  revalidatePath('/contact');\n}\n\nexport default function ContactPage() {\n  return (\n    \u003Cform action={createMessage}>\n      \u003Cinput type=\"text\" name=\"name\" placeholder=\"お名前\" />\n      \u003Cinput type=\"email\" name=\"email\" placeholder=\"メールアドレス\" />\n      \u003Ctextarea name=\"message\" placeholder=\"メッセージ\">\u003C/textarea>\n      \u003Cbutton type=\"submit\">送信\u003C/button>\n    \u003C/form>\n  );\n}\n```\n\nこの例では、`\u003Cform>`要素の`action`属性に直接サーバー側の関数`createMessage`を指定しています。これにより、フォームが送信されると、JavaScriptを使わずにサーバー上で直接処理が実行されます。\n\n## 🌐 Next.jsのルーティング\n\nNext.jsのApp Routerは、ファイルシステムベースのルーティングを採用しており、ディレクトリ構造がそのままURLのパスになります。\n\n- **特徴**:\n  - **シンプルさ**: `app/`ディレクトリ内に新しいフォルダと`page.tsx`ファイルを作成するだけで、新しいルートが自動的に作成されます。\n  - **動的ルート**: `[slug]`のようにフォルダ名を角括弧で囲むことで、動的なURLを作成できます。\n  - **例**: `app/blog/[slug]/page.tsx` は `/blog/my-first-post` のようなURLに対応します。\n  - **ネストされたルートとレイアウト**: ルートはディレクトリとしてネストでき、`layout.tsx`ファイルを使って共通のUI（ヘッダーやフッターなど）を複数のページで共有できます。\n  - **例**: `app/dashboard/layout.tsx` は、`app/dashboard/settings/page.tsx` や `app/dashboard/profile/page.tsx` の両方に適用されます。\n\n#### 実装例: ネストされたルートとレイアウト\n\n```typescript\n// app/dashboard/layout.tsx\n// ダッシュボードの共通レイアウト\nexport default function DashboardLayout({ children }) {\n  return (\n    \u003Cdiv>\n      \u003Cnav>\n        \u003Ca href=\"/dashboard\">ホーム\u003C/a>\n        \u003Ca href=\"/dashboard/settings\">設定\u003C/a>\n      \u003C/nav>\n      \u003Cmain>{children}\u003C/main>\n    \u003C/div>\n  );\n}\n\n// app/dashboard/settings/page.tsx\n// 設定ページ\nexport default function SettingsPage() {\n  return (\n    \u003Ch1>設定\u003C/h1>\n  );\n}\n```\n\nこの構造により、開発者はコンポーネントを再利用しやすく、アプリケーションの全体的な構造を整理しやすくなります。Server Actionsとルーティングは、Next.jsが提供する強力な機能の一部であり、より効率的で現代的なウェブアプリケーション開発を可能にします。\n\n## 🌐 APIルート (Route Handlers)\n\nAPIルートは、Next.jsアプリケーション内にサーバーサイドのAPIエンドポイントを作成する機能です。これにより、外部APIを呼び出したり、データベースとやり取りしたりするなど、サーバーサイドのロジックを実装できます。App Routerでは、`app/api/`ディレクトリ内にRoute Handlersを作成します。\n\n- **特徴**:\n  - **サーバーサイドのロジック**: クライアントに公開したくない機密情報（APIキーなど）を安全に扱うことができます。\n  - **RESTful APIの構築**: GET、POST、PUT、DELETEなどのHTTPメソッドに対応し、RESTfulなAPIを簡単に構築できます。\n  - **データベースとの連携**: 認証情報を使ってデータベースを操作したり、外部サービスと連携したりできます。\n\n#### 実装例: ユーザー情報の取得\n\n```typescript\n// app/api/user/[id]/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function GET(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const { id } = params;\n    // データベースからユーザー情報を取得するロジック\n    const user = await db.getUser(id);\n\n    if (!user) {\n      return NextResponse.json({ message: 'User not found' }, { status: 404 });\n    }\n\n    return NextResponse.json(user);\n  } catch (error) {\n    return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });\n  }\n}\n```\n\nこの例では、`app/api/user/123`のようなリクエストに対して、サーバーサイドでユーザーIDを取得し、データベースから情報をフェッチしてJSON形式で返します。\n\n## 🛡️ ミドルウェア (Middleware)\n\nミドルウェアは、リクエストが完了する前に、特定のパスでコードを実行できる機能です。これにより、リクエストヘッダーの書き換え、リダイレクト、認証、A/Bテストなど、様々な処理を一元的に管理できます。\n\n- **特徴**:\n  - **グローバルなロジック**: アプリケーション全体に適用されるロジックを、各ページやAPIルートごとに書くことなく実装できます。\n  - **リクエストの制御**: ユーザーを別のページにリダイレクトしたり、特定の条件下でリクエストをブロックしたりできます。\n  - **認証・認可**: ログイン済みのユーザーのみが特定のページにアクセスできるようにするなどの認証チェックを簡単に行えます。\n\n#### 実装例: 認証チェック\n\n```typescript\n// middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport function middleware(request: NextRequest) {\n  const token = request.cookies.get('auth_token');\n  const loggedIn = !!token;\n  const url = request.nextUrl.clone();\n\n  // 認証が必要なルート\n  const protectedRoutes = ['/dashboard', '/profile'];\n\n  // 認証が必要なルートにアクセスしようとしているが、ログインしていない場合\n  if (protectedRoutes.includes(url.pathname) && !loggedIn) {\n    url.pathname = '/login';\n    return NextResponse.redirect(url);\n  }\n\n  // ログイン済みだが、ログインページにアクセスしようとしている場合\n  if (url.pathname === '/login' && loggedIn) {\n    url.pathname = '/dashboard';\n    return NextResponse.redirect(url);\n  }\n\n  return NextResponse.next();\n}\n```\n\n`middleware.ts`ファイルは、Next.jsのプロジェクトルートに配置することで自動的に認識されます。このミドルウェアは、ユーザーが保護されたページにアクセスする前に認証トークンをチェックし、ログインページへリダイレクトする役割を果たします。\n\n## 🎨 Tailwind CSSとの統合\n\nTailwind CSSは、ユーティリティファーストのCSSフレームワークで、HTMLに直接クラスを追加することで、迅速かつ柔軟にUIを構築できます。Next.jsは、Tailwind CSSとの統合を公式にサポートしており、セットアップが非常に簡単です。\n\n- **特徴**:\n  - **開発効率の向上**: `m-4`, `flex`, `text-center`といったユーティリティクラスを使うことで、カスタムCSSをほとんど書く必要がなくなります。\n  - **一貫したデザイン**: フレームワークが提供するデザインシステム（カラーパレット、スペーシング、フォントサイズなど）により、デザインの一貫性を保ちやすくなります。\n  - **不要なCSSの除去**: Tailwindのビルドプロセスは、使用されていないCSSクラスを自動的に削除し、本番環境のバンドルサイズを最小限に抑えます。\n\n### セットアップ方法\n\n`create-next-app`コマンドでプロジェクトを作成する際に、`Would you like to use Tailwind CSS?`の質問に`Yes`と答えるだけで、必要な設定がすべて自動で行われます。\n\n```bash\nnpx create-next-app@latest\n```\n\n手動でセットアップする場合は、以下の手順を実行します。\n\n#### 必要なパッケージをインストール:\n\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n#### `tailwind.config.ts`の設定:\n\nコンテンツファイル（`app`ディレクトリなど）へのパスを設定します。\n\n```typescript\n// tailwind.config.ts\nimport type { Config } from 'tailwindcss';\n\nconst config: Config = {\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\nexport default config;\n```\n\n#### `globals.css`にTailwindのディレクティブを追加:\n\n```css\n/* app/globals.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n## 🧪 ユニットテスト\n\nNext.jsプロジェクトの品質と信頼性を確保するために、ユニットテストは不可欠です。Next.jsの公式ドキュメントでは、テストフレームワークとしてJestとReact Testing Libraryの組み合わせが推奨されています。\n\n- **特徴**:\n  - **Jest**: JavaScriptのテストフレームワークで、テストの実行、アサーション、モックなどの機能を提供します。\n  - **React Testing Library (RTL)**: コンポーネントのテストに特化したライブラリで、ユーザーがコンポーネントとどのように対話するかをシミュレートすることに焦点を当てています。これにより、実装の詳細に依存しない堅牢なテストを作成できます。\n\n### セットアップと実装例\n\n#### 必要なパッケージをインストール:\n\n`create-next-app`でテスト環境をセットアップしていない場合、以下をインストールします。\n\n```bash\nnpm install -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom\n```\n\n#### Jestの設定:\n\n`jest.config.ts`ファイルを作成し、`jest-environment-jsdom`と`@testing-library/jest-dom`を使用するように設定します。\n\n#### コンポーネントのテスト例:\n\n例えば、シンプルな「こんにちは」を表示するコンポーネントをテストします。\n\n```typescript\n// components/Greeting.tsx\nexport default function Greeting({ name }: { name: string }) {\n  return \u003Ch1>こんにちは、{name}！\u003C/h1>;\n}\n```\n\n#### テストコード:\n\n```typescript\n// __tests__/Greeting.test.tsx\nimport '@testing-library/jest-dom';\nimport { render, screen } from '@testing-library/react';\nimport Greeting from '@/components/Greeting';\n\ndescribe('Greeting', () => {\n  it('should render a greeting with the provided name', () => {\n    render(\u003CGreeting name=\"太郎\" />);\n\n    // 「こんにちは、太郎！」というテキストがドキュメントに存在するか確認\n    expect(screen.getByText('こんにちは、太郎！')).toBeInTheDocument();\n  });\n});\n```\n\nこのテストは、コンポーネントが正しくテキストをレンダリングしているかを確認します。RTLは、UIが正しくユーザーに表示されているかをテストする上で非常に強力です。\n\nこれらの機能は、Next.jsが提供するエコシステムの一部であり、開発者がモダンで高品質なウェブアプリケーションを効率的に構築するための基盤となります。","src/content/docs/nextjsガイド/03_中級/重要機能.mdx","d63852d6d94e6c9a","nextjsガイド/04_上級最適化/01_cache戦略",{"id":854,"data":856,"body":861,"filePath":862,"digest":863,"deferredRender":16},{"title":857,"editUrl":16,"head":858,"template":18,"sidebar":859,"pagefind":16,"draft":20},"Next.jsのキャッシュ戦略",[],{"hidden":20,"attrs":860},{},"## 🗄️ Next.jsのキャッシュ戦略\n\nNext.jsは、アプリケーションのパフォーマンスを向上させるために、さまざまなキャッシュ戦略を提供しています。これらの戦略を適切に活用することで、ユーザー体験を大幅に向上させることができます。\n\n### 1. 静的サイト生成（SSG）\n\n静的サイト生成を使用すると、ビルド時にページを事前にレンダリングし、CDNにデプロイすることで、ユーザーからのリクエストに対して静的なHTMLファイルを直接提供できます。\n\n#### 実装例\n\n```typescript\n// pages/blog/[id].tsx\nimport { GetStaticPaths, GetStaticProps } from 'next';\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const res = await fetch('https://api.example.com/posts');\n  const posts = await res.json();\n\n  const paths = posts.map((post) => ({\n    params: { id: post.id.toString() },\n  }));\n\n  return { paths, fallback: false };\n};\n\nexport const getStaticProps: GetStaticProps = async (context) => {\n  const res = await fetch(`https://api.example.com/posts/${context.params.id}`);\n  const post = await res.json();\n\n  return {\n    props: {\n      post,\n    },\n  };\n};\n\nconst BlogPost = ({ post }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch1>{post.title}\u003C/h1>\n      \u003Cp>{post.content}\u003C/p>\n    \u003C/div>\n  );\n};\n\nexport default BlogPost;\n```\n\n### 2. サーバーサイドレンダリング（SSR）\n\nNext.jsは、サーバーサイドレンダリングをサポートしており、ページの初回ロードを高速化し、SEOを向上させることができます。SSRを利用することで、サーバーでHTMLを生成し、クライアントに送信することができます。\n\n#### 実装例\n\n```typescript\n// pages/index.tsx\nimport { GetServerSideProps } from 'next';\n\nexport const getServerSideProps: GetServerSideProps = async (context) => {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n  };\n};\n\nconst HomePage = ({ data }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch1>サーバーサイドレンダリング\u003C/h1>\n      \u003Cpre>{JSON.stringify(data, null, 2)}\u003C/pre>\n    \u003C/div>\n  );\n};\n\nexport default HomePage;\n```\n\n### 3. ISR（Incremental Static Regeneration）\n\nISRを使用すると、静的に生成されたページをバックグラウンドで再生成し、最新のデータを提供することができます。これにより、静的サイトのパフォーマンスを維持しつつ、動的なデータを提供できます。\n\n#### 実装例\n\n```typescript\n// pages/blog/[id].tsx\nimport { GetStaticPaths, GetStaticProps } from 'next';\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const res = await fetch('https://api.example.com/posts');\n  const posts = await res.json();\n\n  const paths = posts.map((post) => ({\n    params: { id: post.id.toString() },\n  }));\n\n  return { paths, fallback: 'blocking' };\n};\n\nexport const getStaticProps: GetStaticProps = async (context) => {\n  const res = await fetch(`https://api.example.com/posts/${context.params.id}`);\n  const post = await res.json();\n\n  return {\n    props: {\n      post,\n    },\n    revalidate: 60, // 60秒ごとに再生成\n  };\n};\n\nconst BlogPost = ({ post }) => {\n  return (\n    \u003Cdiv>\n      \u003Ch1>{post.title}\u003C/h1>\n      \u003Cp>{post.content}\u003C/p>\n    \u003C/div>\n  );\n};\n\nexport default BlogPost;\n```\n\nこれらのキャッシュ戦略を適切に活用することで、Next.jsアプリケーションのパフォーマンスとユーザー体験を大幅に向上させることができます。","src/content/docs/nextjsガイド/04_上級・最適化/01_cache戦略.mdx","6e71704443b1befd","nextjsガイド/04_上級最適化/02_cookie",{"id":864,"data":866,"body":871,"filePath":872,"digest":873,"deferredRender":16},{"title":867,"editUrl":16,"head":868,"template":18,"sidebar":869,"pagefind":16,"draft":20},"Next.jsのCookie管理",[],{"hidden":20,"attrs":870},{},"## 🍪 Next.jsのCookie管理\n\nNext.jsでは、サーバーコンポーネントとクライアントコンポーネントの両方でCookieを管理することができます。Cookieは、ユーザーのセッション情報や認証トークンを保存するために使用されます。\n\n### 1. サーバーコンポーネントでのCookie管理\n\nサーバーコンポーネントでは、`cookies()`関数を使用してCookieを読み取ることができます。これにより、サーバーサイドでの認証やセッション管理が可能になります。\n\n#### 実装例\n\n```typescript\n// app/dashboard/page.tsx\nimport { cookies } from 'next/headers';\n\nexport default function DashboardPage() {\n  const cookieStore = cookies();\n  const token = cookieStore.get('auth_token')?.value;\n\n  // トークンを使用して認証情報を取得\n  // ...\n\n  return (\n    \u003Cdiv>\n      \u003Ch1>ダッシュボード\u003C/h1>\n      {/* 認証情報に基づくコンテンツを表示 */}\n    \u003C/div>\n  );\n}\n```\n\n### 2. ルートハンドラーでのCookie設定\n\nルートハンドラーでは、`cookies()`関数を使用してCookieを設定することができます。これにより、サーバーサイドでのCookieの読み取りと書き込みが可能になります。\n\n#### 実装例\n\n```typescript\n// app/api/login/route.ts\nimport { cookies } from 'next/headers';\nimport { NextResponse } from 'next/server';\n\nexport async function POST(req) {\n  const token = 'generated_auth_token_123';\n\n  // Cookieを設定\n  cookies().set('auth_token', token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    maxAge: 60 * 60 * 24 * 7, // 1週間\n    path: '/',\n    sameSite: 'strict',\n  });\n\n  return NextResponse.json({ message: 'Login successful' });\n}\n```\n\n### 3. クライアントコンポーネントでのCookie管理\n\nクライアントコンポーネントでは、Cookieの読み取りと書き込みにライブラリを使用することが一般的です。これにより、クライアントサイドでの状態管理が容易になります。\n\n#### 実装例\n\n```typescript\n// クライアントサイドでのCookie管理\nimport Cookies from 'js-cookie';\n\nfunction setAuthToken(token) {\n  Cookies.set('auth_token', token, { expires: 7, path: '/' });\n}\n\nfunction getAuthToken() {\n  return Cookies.get('auth_token');\n}\n```\n\nこれらの方法を組み合わせることで、Next.jsアプリケーション内でのCookie管理が効率的に行えます。サーバーサイドでのセキュアなCookie設定と、クライアントサイドでの柔軟な状態管理を両立させることが可能です。","src/content/docs/nextjsガイド/04_上級・最適化/02_cookie.mdx","614244043457ed9c","nextjsガイド/04_上級最適化/03_css",{"id":874,"data":876,"body":881,"filePath":882,"digest":883,"deferredRender":16},{"title":877,"editUrl":16,"head":878,"template":18,"sidebar":879,"pagefind":16,"draft":20},"Next.jsのCSS管理",[],{"hidden":20,"attrs":880},{},"## 🎨 Next.jsのCSS管理\n\nNext.jsでは、さまざまな方法でCSSを管理することができます。これにより、スタイルの一貫性を保ちながら、効率的にUIを構築することが可能です。\n\n### 1. CSS Modules\n\nCSS Modulesは、コンポーネントごとにスタイルをスコープするための方法です。これにより、スタイルの競合を防ぎ、メンテナンス性を向上させることができます。\n\n#### 実装例\n\n```css\n/* styles/Home.module.css */\n.container {\n  padding: 20px;\n  background-color: #f0f0f0;\n}\n```\n\n```typescript\n// pages/index.tsx\nimport styles from '../styles/Home.module.css';\n\nexport default function Home() {\n  return (\n    \u003Cdiv className={styles.container}>\n      \u003Ch1>Welcome to Next.js!\u003C/h1>\n    \u003C/div>\n  );\n}\n```\n\n### 2. Styled Components\n\nStyled Componentsは、JavaScript内でスタイルを定義するためのライブラリです。これにより、コンポーネントとスタイルを一緒に管理することができます。\n\n#### 実装例\n\n```typescript\n// pages/index.tsx\nimport styled from 'styled-components';\n\nconst Container = styled.div`\n  padding: 20px;\n  background-color: #f0f0f0;\n`;\n\nexport default function Home() {\n  return (\n    \u003CContainer>\n      \u003Ch1>Welcome to Next.js!\u003C/h1>\n    \u003C/Container>\n  );\n}\n```\n\n### 3. Tailwind CSS\n\nTailwind CSSは、ユーティリティファーストのCSSフレームワークで、迅速なUI開発を可能にします。Next.jsと組み合わせることで、効率的にスタイルを適用できます。\n\n#### 実装例\n\n```typescript\n// pages/index.tsx\nexport default function Home() {\n  return (\n    \u003Cdiv className=\"p-5 bg-gray-100\">\n      \u003Ch1 className=\"text-2xl font-bold\">Welcome to Next.js!\u003C/h1>\n    \u003C/div>\n  );\n}\n```\n\nこれらの方法を組み合わせることで、Next.jsアプリケーション内でのCSS管理が効率的に行えます。プロジェクトの規模や要件に応じて、最適な方法を選択してください。","src/content/docs/nextjsガイド/04_上級・最適化/03_CSS.mdx","3245bfc83cf9efc1","nextjsガイド/04_上級最適化/04_routehandler",{"id":884,"data":886,"body":891,"filePath":892,"digest":893,"deferredRender":16},{"title":887,"editUrl":16,"head":888,"template":18,"sidebar":889,"pagefind":16,"draft":20},"Next.jsのルートハンドラー",[],{"hidden":20,"attrs":890},{},"## 🔄 Next.jsのルートハンドラー\n\nNext.jsのルートハンドラーは、App Router (`app/api/route.ts`) での新しいAPIルートのメカニズムです。これにより、Web標準API (`Request`, `Response`) に準拠した形で、HTTPメソッドごとの関数を定義し、App Routerのキャッシングや再検証機能と統合できます。\n\n### 1. ルートハンドラーの作成\n\nルートハンドラーは、`app/api/route.ts`ファイル内で定義されます。各HTTPメソッド（GET, POST, PUTなど）に対して専用の関数を定義できます。\n\n#### 実装例\n\n```typescript\n// app/api/hello/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n  return NextResponse.json({ message: 'Hello from Route Handler!' });\n}\n\nexport async function POST(request: Request) {\n  const data = await request.json();\n  return NextResponse.json({ message: 'POST request received', data });\n}\n```\n\n- `NextResponse`: 新しいApp Routerで推奨されるレスポンスオブジェクトで、より柔軟なレスポンス制御が可能です。\n- `HTTPメソッド関数`: 各HTTPメソッドに対応する関数をエクスポートすることで、ルーティングが自動的に処理されます。\n\n### 2. ルートハンドラーの利点\n\n- **Web標準APIの準拠**: `Request`や`Response`オブジェクトを使用することで、標準的なWeb APIの知識を活かしてルートを定義できます。\n- **キャッシングと再検証**: App Routerのキャッシング機能と統合することで、効率的なデータフェッチと再検証が可能です。\n- **柔軟なレスポンス制御**: `NextResponse`を使用することで、レスポンスのカスタマイズが容易になります。\n\n### 3. ルートハンドラーの活用例\n\nルートハンドラーを使用することで、Next.jsアプリケーション内でのAPIルートの管理が効率的に行えます。以下に、一般的な活用例を示します。\n\n- **データベースとの連携**: ルートハンドラー内でデータベースに接続し、データの取得、更新、削除を行うことができます。\n- **外部APIとの通信**: 外部のAPIを呼び出してデータを取得し、加工してからクライアントに渡すことができます。\n- **認証ロジックの実装**: ユーザー認証やセッション管理などのサーバーサイドロジックをルートハンドラー内に実装できます。\n\nこれらの利点を活かして、Next.jsアプリケーションのAPIルートを効率的に管理し、開発スピードを向上させることができます。","src/content/docs/nextjsガイド/04_上級・最適化/04_routeHandler.mdx","c3f8567aadc6816d","nextjsガイド/04_上級最適化/05_状態管理",{"id":894,"data":896,"body":901,"filePath":902,"digest":903,"deferredRender":16},{"title":897,"editUrl":16,"head":898,"template":18,"sidebar":899,"pagefind":16,"draft":20},"Next.jsの状態管理",[],{"hidden":20,"attrs":900},{},"## 🔄 Next.jsの状態管理\n\nNext.jsでは、さまざまな方法で状態管理を行うことができます。これにより、アプリケーションの状態を効率的に管理し、ユーザー体験を向上させることが可能です。\n\n### 1. ReactのuseStateとuseReducer\n\nReactの`useState`と`useReducer`フックを使用して、コンポーネント内で状態を管理することができます。\n\n#### 実装例\n\n```typescript\n// components/Counter.tsx\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \u003Cdiv>\n      \u003Cp>Count: {count}\u003C/p>\n      \u003Cbutton onClick={() => setCount(count + 1)}>Increment\u003C/button>\n    \u003C/div>\n  );\n}\n```\n\n### 2. Context API\n\nContext APIを使用すると、コンポーネントツリー全体で状態を共有することができます。これにより、プロップドリリングを避け、状態管理を簡素化できます。\n\n#### 実装例\n\n```typescript\n// context/ThemeContext.tsx\nimport { createContext, useContext, useState, ReactNode } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport function ThemeProvider({ children }: { children: ReactNode }) {\n  const [theme, setTheme] = useState('light');\n\n  return (\n    \u003CThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    \u003C/ThemeContext.Provider>\n  );\n}\n\nexport function useTheme() {\n  return useContext(ThemeContext);\n}\n```\n\n### 3. Zustand\n\nZustandは、軽量でシンプルな状態管理ライブラリです。Next.jsと組み合わせて使用することで、効率的に状態を管理できます。\n\n#### 実装例\n\n```typescript\n// store/useStore.ts\nimport create from 'zustand';\n\ninterface StoreState {\n  count: number;\n  increment: () => void;\n}\n\nconst useStore = create\u003CStoreState>((set) => ({\n  count: 0,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n}));\n\nexport default useStore;\n```\n\nこれらの方法を組み合わせることで、Next.jsアプリケーション内での状態管理が効率的に行えます。プロジェクトの規模や要件に応じて、最適な方法を選択してください。","src/content/docs/nextjsガイド/04_上級・最適化/05_状態管理.mdx","9a366f5704688c4b","nextjsガイド/04_上級最適化/パフォーマンスチューニング",{"id":904,"data":906,"body":910,"filePath":911,"digest":912,"deferredRender":16},{"title":328,"editUrl":16,"head":907,"template":18,"sidebar":908,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":909},{},"Next.jsのパフォーマンスチューニング方法を以下に示します。\n\n## 画像最適化\n\nNext.jsの`next/image`コンポーネントを使用して、画像を最適化します。\n\n```javascript\nimport Image from 'next/image';\n\nconst MyImage = () => (\n  \u003CImage\n    src=\"/me.png\"\n    alt=\"Picture of the author\"\n    width={500}\n    height={500}\n  />\n);\n```\n\n## 静的ファイルのキャッシュ\n\n`next.config.js`でキャッシュヘッダーを設定します。\n\n```javascript\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'Cache-Control',\n            value: 'public, max-age=31536000, immutable',\n          },\n        ],\n      },\n    ];\n  },\n};\n```","src/content/docs/nextjsガイド/04_上級・最適化/パフォーマンスチューニング.mdx","e07f14b8fad330b4","nodejsガイド/02_基本/フォルダ構成",{"id":913,"data":915,"body":919,"filePath":920,"digest":921,"deferredRender":16},{"title":408,"editUrl":16,"head":916,"template":18,"sidebar":917,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":918},{},"## Node.js Webアプリケーションのフォルダ構成\n\nNode.jsのプロジェクトには公式な標準構成はありませんが、アプリケーションの規模に応じて、複数のベストプラクティスが存在します。これらは、コードの可読性、メンテナンス性、およびチーム開発の効率性を高めることを目的としています。\n\n### 1. 小〜中規模向けの基本構成 (MVCベース)\n\nこの構成は、小規模から中規模のWebアプリケーションで最も広く採用されています。MVC (Model-View-Controller) の原則に基づいて、役割ごとにコードを分割します。\n\n```\nmy-app/\n├── node_modules/       # npmパッケージ\n├── public/             # 公開する静的ファイル（CSS, JS, 画像など）\n├── src/                # アプリケーションのソースコード\n│   ├── controllers/    # リクエストの制御とロジック\n│   ├── models/         # データベース操作とデータ定義\n│   ├── routes/         # ルーティング設定\n│   └── views/          # テンプレートファイル（HTMLなど）\n├── .env                # 環境変数\n├── .gitignore          # Gitの管理から除外するファイル\n├── package.json        # プロジェクトの設定\n└── server.js           # アプリケーションの起動ファイル\n```\n\n`src/` ディレクトリ内に、controllers、models、routes、views といったMVCの各レイヤーを配置することで、各ファイルの役割が明確になります。\n\n`.env` と `package.json` は、プロジェクト全体の設定を管理する上で不可欠なファイルです。\n\n### 2. 大規模向けの高機能な構成\n\nアプリケーションの規模が大きくなると、ビジネスロジックや共通の処理をより詳細に分離する必要があります。以下のディレクトリを追加することで、コードの再利用性と管理のしやすさが向上します。\n\n- **src/services/**: 複雑なビジネスロジックをコントローラーから分離します。ユーザー登録やメール送信など、複数のコントローラーで共通して使われる処理をここにまとめ、コードの再利用性とテスト性を高めます。\n- **src/middlewares/**: リクエストの共通処理を管理します。認証、ログ記録、CORS（オリジン間リソース共有）設定など、リクエストがコントローラーに到達する前に実行される処理をここに配置し、コードの重複を防ぎます。\n- **src/utils/ or src/helpers/**: 汎用的なヘルパー関数をまとめます。日付のフォーマット、データのバリデーション、共通の定数など、特定のレイヤーに属さないユーティリティ関数を格納します。\n- **src/config/**: 詳細な環境設定を管理します。データベース接続情報やAPIキーなどを、環境（開発、テスト、本番）ごとに分けて管理します。\n\n### 3. より高度な構成：機能（Feature）ベースの構造\n\nアプリケーションが非常に大規模で、多くの独立した機能を持つ場合、MVCのレイヤー別分割よりも、機能（Feature）ごとにコードをまとめる構成が有効です。これにより、特定の機能の追加や削除が容易になり、チーム開発の際のコンフリクトを減らせます。\n\n```\nmy-app/\n├── src/\n│   ├── modules/\n│   │   ├── users/            # ユーザー管理機能\n│   │   │   ├── user.controller.js\n│   │   │   ├── user.model.js\n│   │   │   └── user.routes.js\n│   │   └── products/         # 商品管理機能\n│   │       ├── product.controller.js\n│   │       ├── product.model.js\n│   │       └── product.routes.js\n│   └── shared/               # 共有モジュール\n│       ├── utils.js\n│       └── auth.middleware.js\n│ ...\n```\n\nこの構造では、usersやproductsといった各機能のディレクトリ内に、その機能に関連するすべてのファイル（コントローラー、モデル、ルートなど）を配置します。\n\nどの構成を選ぶかは、プロジェクトの規模とチームのニーズによって異なります。プロジェクトの初期段階ではシンプルなMVC構成から始め、必要に応じて徐々に高度な構成に移行していくのが良いでしょう。","src/content/docs/node.jsガイド/02_基本/フォルダ構成.mdx","19f68365bef7eadb","nodejsガイド/02_基本/環境構築",{"id":922,"data":924,"body":928,"filePath":929,"digest":930,"deferredRender":16},{"title":427,"editUrl":16,"head":925,"template":18,"sidebar":926,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":927},{},"Node.jsの環境構築手順を以下に示します。\n\n## インストール\n\nNode.jsをインストールするには、nvmを使用することをお勧めします。以下のコマンドでnvmをインストールします。\n\n```bash\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n```\n\nその後、Node.jsをインストールします。\n\n```bash\nnvm install node\n```\n\n## セットアップ\n\nNode.jsのバージョンを確認します。\n\n```bash\nnode -v\n```","src/content/docs/node.jsガイド/02_基本/環境構築.mdx","396674efbb88bf54","nodejsガイド/04_上級最適化/パフォーマンスチューニング",{"id":931,"data":933,"body":937,"filePath":938,"digest":939,"deferredRender":16},{"title":328,"editUrl":16,"head":934,"template":18,"sidebar":935,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":936},{},"Node.jsのパフォーマンスチューニング方法を以下に示します。\n\n## 非同期処理の最適化\n\nNode.jsでは、非同期処理を適切に管理することでパフォーマンスを向上させることができます。\n\n```javascript\nconst fs = require('fs').promises;\n\nasync function readFile() {\n  try {\n    const data = await fs.readFile('/path/to/file', 'utf8');\n    console.log(data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  }\n}\n\nreadFile();\n```\n\n## クラスターの利用\n\nNode.jsの`cluster`モジュールを使用して、マルチプロセスでアプリケーションを実行します。\n\n```javascript\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  for (let i = 0; i \u003C numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`worker ${worker.process.pid} died`);\n  });\n} else {\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('hello world\\n');\n  }).listen(8000);\n}\n```","src/content/docs/node.jsガイド/04_上級・最適化/パフォーマンスチューニング.mdx","7d43a48b8d909507","nodejsガイド/03_中級/api利用法",{"id":940,"data":942,"body":946,"filePath":947,"digest":948,"deferredRender":16},{"title":388,"editUrl":16,"head":943,"template":18,"sidebar":944,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":945},{},"Node.jsのAPI利用法を以下に示します。\n\n## HTTPサーバー\n\nNode.jsでは、`http`モジュールを使用してHTTPサーバーを作成できます。\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World\\n');\n});\n\nserver.listen(3000, '127.0.0.1', () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});\n```","src/content/docs/node.jsガイド/03_中級/API利用法.mdx","161a8af2e6006a93","nodejsガイド/05_別topics/excelでの使用方法",{"id":949,"data":951,"body":956,"filePath":957,"digest":958,"deferredRender":16},{"title":952,"editUrl":16,"head":953,"template":18,"sidebar":954,"pagefind":16,"draft":20},"excelでの使用方法",[],{"hidden":20,"attrs":955},{},"## Node.jsとExcel：高度な利用方法\n\nNode.jsでExcelを扱うための基本的な方法に加えて、頻出ライブラリ、データの出力方法、複数のブックを読み込む方法について解説します。\n\n### 1. 頻出ライブラリ\n\nNode.jsでExcelファイルを扱うための主要なライブラリは、`xlsx`と`exceljs`の2つです。\n\n- **xlsx**:\n  - **特徴**: 読み込みに特化しており、高速で軽量です。複雑なExcelファイルをJSON形式に変換するのに優れています。\n  - **用途**: 大量のExcelデータを高速に処理してデータベースに取り込んだり、データ分析のために変換したりするタスクに適しています。\n\n- **exceljs**:\n  - **特徴**: 読み書き両方の機能が充実しており、セル単位での書式設定やグラフの作成など、より高度な操作が可能です。\n  - **用途**: テンプレートとなるExcelファイルにデータを流し込んで新しいファイルを作成したり、レポートを動的に生成したりするタスクに適しています。\n\nどちらのライブラリも、`npm install \u003Cライブラリ名>`で簡単にインストールできます。\n\n### 2. Excelファイルへの出力方法\n\nExcelファイルを読み込むだけでなく、JavaScriptのデータをExcelに出力することもよくあります。ここでは`xlsx`ライブラリを使った基本的な出力方法を示します。\n\n```javascript\n// writeExcel.js\n\nconst XLSX = require('xlsx');\n\n// 出力するJSONデータ（例）\nconst data = [\n  { ID: 1, Name: 'Alice', Score: 95 },\n  { ID: 2, Name: 'Bob', Score: 88 },\n  { ID: 3, Name: 'Charlie', Score: 72 }\n];\n\n// JSONデータをワークシートに変換\nconst worksheet = XLSX.utils.json_to_sheet(data);\n\n// 新しいワークブックを作成し、ワークシートを追加\nconst newWorkbook = XLSX.utils.book_new();\nXLSX.utils.book_append_sheet(newWorkbook, worksheet, 'Results');\n\n// Excelファイルとして保存\nXLSX.writeFile(newWorkbook, 'output.xlsx');\n\nconsole.log('output.xlsx が正常に作成されました。');\n```\n\nこのコードは、JavaScriptの配列をExcelのシートに変換し、新しいExcelファイルとして保存します。\n\n### 3. 複数のExcelブックを読み込む方法\n\n複数のExcelファイルを一度に処理する場合、ファイルシステムを操作する`fs`モジュールと組み合わせて使うのが効率的です。\n\n```javascript\n// readMultipleExcels.js\n\nconst XLSX = require('xlsx');\nconst fs = require('fs');\nconst path = require('path');\n\n// Excelファイルがあるディレクトリ\nconst directoryPath = './excel_files';\n\n// ディレクトリ内のすべてのExcelファイルを読み込む\nfs.readdir(directoryPath, (err, files) => {\n  if (err) {\n    return console.log('ディレクトリをスキャンできませんでした: ' + err);\n  }\n\n  const allData = [];\n\n  files.forEach(file => {\n    // .xlsx拡張子を持つファイルのみを対象にする\n    if (path.extname(file) === '.xlsx') {\n      const filePath = path.join(directoryPath, file);\n      const workbook = XLSX.readFile(filePath);\n      const sheetName = workbook.SheetNames[0];\n      const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);\n      \n      // ファイル名とデータを統合して配列にプッシュ\n      allData.push({ fileName: file, data: jsonData });\n    }\n  });\n\n  // 全てのデータを表示\n  console.log(JSON.stringify(allData, null, 2));\n});\n```\n\nこのスクリプトは、指定したディレクトリ内のすべての.xlsxファイルを自動的にスキャンし、各ファイルからデータを読み込んで一つの配列にまとめます。これにより、手動で各ファイルを指定する手間が省け、作業を自動化できます。","src/content/docs/node.jsガイド/05_別TOPICS/excelでの使用方法.mdx","494047961303a76b","playwrightガイド/01_はじめに/01_install",{"id":959,"data":961,"body":967,"filePath":968,"digest":969,"deferredRender":16},{"title":962,"editUrl":16,"head":963,"template":18,"sidebar":964,"pagefind":16,"draft":20},"Playwrightのインストール",[],{"label":965,"hidden":20,"attrs":966},"インストール",{},"## Playwrightの概要とインストール方法 🚀\nPlaywrightは、Webアプリケーションをテストするための強力な自動化ライブラリです。Chromium、Firefox、WebKitという主要なブラウザを一つのAPIで制御できるのが最大の特徴です。\n\n### なぜPlaywrightを使用するのか？\nPlaywrightは、信頼性と効率性を両立させるための様々な機能を提供します。\n\n- **クロスブラウザ対応**: 異なるブラウザ間でコードを書き換える必要がなく、一つのスクリプトでテストが完結します。\n- **高速な実行速度**: ブラウザと直接通信するため、他のツールよりも高速に動作します。\n- **高い信頼性**: 自動ウェイト機能により、要素が表示されるまで賢く待機し、テストの不安定な動作を防ぎます。\n- **豊富なAPI**: ファイルのアップロード・ダウンロード、ネットワークトラフィックの監視など、実際のユーザーが行う操作をほぼすべて再現できます。\n\n### セットアップ手順 ⚙️\nPlaywrightは、Node.js環境で動作します。以下の3つのステップで簡単にセットアップできます。\n\n#### Node.jsのインストール:\nまず、Node.jsがインストールされているかを確認します。\n\n```bash\nnode -v\n```\n\nインストールされていない場合は、公式サイトから最新版をダウンロードしてインストールしてください。\n\n#### Playwrightのインストール:\nプロジェクトのディレクトリで、npmを使ってPlaywrightをインストールします。\n\n```bash\nnpm install playwright\n```\n\n#### ブラウザのインストール:\nPlaywrightが使用する主要なブラウザをインストールします。\n\n```bash\nnpx playwright install\n```\n\nこのコマンドにより、Chromium、Firefox、WebKitが自動的にダウンロードされ、テストを実行する準備が整います。\n\n### 簡単な使用例 📝\nNode.jsでの基本操作\n以下のJavaScriptコードは、ブラウザを起動し、指定したウェブサイトのタイトルを取得する簡単な例です。\n\n```javascript\nconst { chromium } = require('playwright');\n\n(async () => {\n  const browser = await chromium.launch(); // ブラウザを起動\n  const page = await browser.newPage(); // 新しいページを開く\n  await page.goto('https://playwright.dev'); // URLに移動\n  console.log(await page.title()); // ページのタイトルを出力\n  await browser.close(); // ブラウザを閉じる\n})();\n```\n\nこのファイルを`example.js`として保存し、`node example.js`コマンドで実行できます。\n\n### Reactでのテスト活用 ⚛️\nPlaywrightはReactアプリケーションのE2Eテストに最適です。ここでは、Reactプロジェクトでのセットアップとテストの書き方を紹介します。\n\n#### セットアップ\n- **プロジェクトの作成**:\n  Reactプロジェクトをまだ持っていない場合は、`create-react-app`で作成します。\n\n  ```bash\n  npx create-react-app my-app\n  cd my-app\n  ```\n\n- **Playwrightのインストール**:\n  Reactプロジェクト内で`@playwright/test`ライブラリをインストールします。このライブラリは、テストフレームワーク機能を提供し、テストコードをより簡潔に書けるようにします。\n\n  ```bash\n  npm install --save-dev @playwright/test\n  npx playwright install\n  ```\n\n#### テストスクリプトの作成\n`src/App.test.js`のようなテストファイルに、以下のコードを記述します。\n\n```javascript\nimport { test, expect } from '@playwright/test';\n\ntest('アプリケーションのタイトルを検証', async ({ page }) => {\n  await page.goto('http://localhost:3000');\n  await expect(page).toHaveTitle(/React App/);\n});\n\ntest('リンクのクリックとURLの検証', async ({ page }) => {\n  await page.goto('http://localhost:3000');\n  await page.click('text=Learn React');\n  await expect(page).toHaveURL(/reactjs.org/);\n});\n```\n\n#### テストの実行\nReactの開発サーバーを起動し、新しいターミナルでテストを実行します。\n\n```bash\nnpm start # 開発サーバーを起動\nnpx playwright test\n```\n\nPlaywrightが自動でブラウザを立ち上げ、テストを実行して結果を表示します。\n\nこのように、PlaywrightはReactの動的な挙動を考慮した信頼性の高いテストを簡単に実装できるため、Webアプリケーションの品質向上に不可欠なツールと言えます。","src/content/docs/playwrightガイド/01_はじめに/01_install.mdx","965c171f79accc00","playwrightガイド/01_はじめに/02_comparison",{"id":970,"data":972,"body":978,"filePath":979,"digest":980,"deferredRender":16},{"title":973,"editUrl":16,"head":974,"template":18,"sidebar":975,"pagefind":16,"draft":20},"Playwrightと他のE2Eテストツールの比較",[],{"label":976,"hidden":20,"attrs":977},"比較",{},"## PlaywrightとCypress、Seleniumの比較 🥊\nPlaywrightとCypress、そしてSeleniumという主要なE2Eテストフレームワークを比較し、それぞれの強みと弱みを解説します。\n\n## 詳細な比較と利用シナリオ 📊\n\n### Playwright 🚀\n- **強み**: Playwrightの最大の強みは、クロスブラウザと高い信頼性、そして広範なテスト範囲です。ブラウザと直接通信するため非常に高速で、新しいタブやiframe、異なるドメインへの遷移といった複雑なシナリオも簡単にテストできます。\n- **弱み**: 他のフレームワークに比べて、歴史が浅くコミュニティの規模は小さいですが、急速に成長しています。\n- **利用シナリオ**: 大規模なWebアプリケーションや、ブラウザ間の互換性テストを重視するプロジェクトに最適です。\n\n### Cypress 🟢\n- **強み**: Cypressは**開発者体験（Developer Experience）**に重点を置いています。リアルタイムのリロード機能や、テスト実行中の画面をタイムトラベルのように追跡できるデバッグツールが非常に優れています。テストコードが非常に読みやすく、学習コストも低いのが魅力です。\n- **弱み**: ブラウザ上で動作するため、**単一オリジン（同一ドメイン）**のテストに限定されます。また、新しいタブや異なるブラウザのテストには向いていません。\n- **利用シナリオ**: 開発初期段階のテストや、デバッグを迅速に行いたい中小規模のアプリケーションに適しています。\n\n### Selenium 🌐\n- **強み**: Seleniumは、E2Eテストフレームワークの元祖であり、その最大の強みは膨大なブラウザとプログラミング言語のサポートです。歴史が長いため、ドキュメントやコミュニティの知識が豊富にあります。\n- **弱み**: 各ブラウザのWebDriverを介して通信するため、PlaywrightやCypressに比べてセットアップが複雑で、実行速度も遅くなりがちです。また、要素の表示を待つための明示的なコード（手動ウェイト）が必要なため、テストが不安定になることがよくあります。\n- **利用シナリオ**: 既存の古いシステムや、Playwrightがサポートしていない特定のブラウザ（例: Internet Explorer）でのテストが必要な場合に選択されます。\n\n| 特徴 | Playwright | Cypress | Selenium |\n| --- | --- | --- | --- |\n| ブラウザサポート | ⚪ Chromium, Firefox, WebKit | 🟡 Chromium系、Firefox (実験的) | 🟢 ほぼ全てのブラウザ |\n| 実行速度 | 🟢 高速 (ブラウザと直接通信) | 🟢 高速 (ブラウザに直接注入) | 🟡 中速 (WebDriver経由) |\n| 信頼性 | 🟢 高い (自動ウェイト機能) | 🟢 高い (自動ウェイト機能) | 🟡 やや低い (手動ウェイトが必要) |\n| API/構文 | 🟢 モダンでシンプル | 🟢 シンプルで直感的 | 🟡 冗長で複雑 |\n| テスト範囲 | 🟢 広範 (複数オリジン、iframe、新しいタブ) | 🟡 制限あり (単一オリジン) | 🟢 広範 |\n| 並列実行 | 🟢 サポート (Workerプロセス) | 🟡 部分的 (有料プランでサポート) | 🟢 サポート (グリッド) |\n| テストコードの言語 | 🟢 JS, TS, Python, C#, Java | 🟡 JS, TS | 🟢 ほぼ全ての言語 |\n\n## まとめ 結論 🎯\n- **Playwright**は、高速かつ信頼性の高いテストを、多様なブラウザで実行したい場合に最適な、現代のオールラウンドなツールです。\n- **Cypress**は、開発中のデバッグや、シンプルで直感的なテストを素早く書きたい場合に優れた選択肢です。\n- **Selenium**は、幅広い互換性が最優先事項であり、レガシーな環境でのテストが必要な場合に適しています。\n\n多くの新規プロジェクトでは、PlaywrightがCypressやSeleniumの代替として選択されることが増えています。","src/content/docs/playwrightガイド/01_はじめに/02_comparison.mdx","cca48ad5a998278b","playwrightガイド/02_基本/syntax",{"id":981,"data":983,"body":989,"filePath":990,"digest":991,"deferredRender":16},{"title":984,"editUrl":16,"head":985,"template":18,"sidebar":986,"pagefind":16,"draft":20},"Playwrightの構文",[],{"label":987,"hidden":20,"attrs":988},"構文",{},"## Playwrightの基本構文 🧪\nPlaywrightのテストは、`@playwright/test`という組み込みのテストランナーを使用して記述します。これにより、テストの構造化とアサーションが簡単になります。\n\n### テストの作成\nテストは**`test`関数で定義し、検証には`expect`関数**を使用します。`page`オブジェクトは、ブラウザ操作（ページの移動、クリック、入力など）を行うための中心的な役割を果たします。\n\n```javascript\nconst { test, expect } = require('@playwright/test');\n\ntest('基本テスト：ページのタイトルを検証', async ({ page }) => {\n  await page.goto('https://example.com');\n  // ページのタイトルを検証します\n  await expect(page).toHaveTitle(/Example Domain/);\n});\n```\n\n`expect(page).toHaveTitle()`のように、アサーションは非常に読みやすく設計されています。\n\n### 高度なテストシナリオ 🎯\nPlaywrightは、複雑なユーザーインタラクションを簡単に再現できます。\n\n#### ユーザー操作の再現\n`page.click()`, `page.fill()`, `page.press()`といったメソッドを使用して、クリック、テキスト入力、キーボード操作をシミュレートします。\n\n```javascript\ntest('複雑なユーザーインタラクション', async ({ page }) => {\n  await page.goto('https://playwright.dev/login');\n  // フォームにユーザー名とパスワードを入力\n  await page.fill('#username', 'testuser');\n  await page.fill('#password', 'password123');\n  // ログインボタンをクリック\n  await page.click('#login-button');\n  \n  // ログイン後のウェルカムメッセージを検証\n  const welcomeMessage = await page.locator('#welcome-message');\n  await expect(welcomeMessage).toHaveText('Welcome, testuser!');\n});\n```\n\n### CI/CD統合 🤝\nPlaywrightは、GitHub ActionsなどのCI/CDプラットフォームに簡単に統合できます。CI/CDパイプラインにテストを組み込むことで、コードが変更されるたびに自動でテストが実行され、デプロイ前にバグを発見できます。\n\n#### GitHub Actionsの設定例\n`.github/workflows/playwright.yml`ファイルを作成し、以下の内容を記述します。\n\n```yaml\nname: Playwright Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - name: Install dependencies\n        run: npm install\n      - name: Install Playwright browsers\n        run: npx playwright install --with-deps\n      - name: Run Playwright tests\n        run: npx playwright test\n      - uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: playwright-report\n          path: playwright-report/\n          retention-days: 30\n```\n\nこのワークフローは、`push`または`pull_request`が発生するたびに自動でテストを実行し、テスト結果のレポートをアップロードします。\n\n### デバッグとトラブルシューティング 🐞\nPlaywrightには、テストのデバッグを助ける強力なツールが組み込まれています。\n\n#### Playwright UI\n`npx playwright test --ui`コマンドを実行すると、GUIでテストをステップ実行したり、DOMスナップショットを確認したりできます。\n\n#### コードの一時停止\n`page.pause()`をテストコードに挿入することで、特定の場所でテスト実行を一時停止し、ブラウザ上で要素の状態などを手動で確認できます。\n\n```javascript\ntest('デバッグテスト', async ({ page }) => {\n  await page.goto('https://example.com');\n  await page.pause(); // ここでテストが一時停止\n  // 手動で操作を確認後、ターミナルでresume\n});\n```\n\n### パフォーマンス最適化 ⚡️\nテストの実行時間を短縮し、効率を向上させるための手法です。\n\n#### 並列テスト実行\nPlaywrightはデフォルトで並列実行をサポートしています。設定ファイル`playwright.config.js`で`workers`の数を調整できます。\n\n```javascript\n// playwright.config.js\nmodule.exports = {\n  // 並列実行するworkerの数を指定\n  workers: process.env.CI ? 2 : undefined,\n};\n```\n\nCI環境では`workers`の数を明示的に指定することで、CIサーバーのリソースを最大限に活用できます。\n\n#### テストの分離\n各テストケースは独立して実行されるように設計します。これにより、並列実行の効果が最大化されます。\n\n### セキュリティテスト 🔐\nPlaywrightは、Webアプリケーションのセキュリティテストにも利用できます。\n\n#### ユーザー認証のテスト\n認証APIが正しく動作するか、不正な認証情報が拒否されるかをテストします。\n\n```javascript\ntest('不正なログイン', async ({ page }) => {\n  await page.goto('https://playwright.dev/login');\n  await page.fill('#username', 'invalid-user');\n  await page.fill('#password', 'wrong-password');\n  await page.click('#login-button');\n  \n  // エラーメッセージが表示されることを検証\n  const errorMessage = await page.locator('.error-message');\n  await expect(errorMessage).toBeVisible();\n});\n```\n\n#### APIリクエストの検証\n`page.route()`メソッドを使って、特定のリクエストをインターセプトし、レスポンスを検証することも可能です。これにより、アプリケーションが機密データを正しく扱っているかをテストできます。","src/content/docs/playwrightガイド/02_基本/syntax.mdx","28573e7b6a698145","playwrightガイド/02_基本/基本",{"id":992,"data":994,"body":999,"filePath":1000,"digest":1001,"deferredRender":16},{"title":995,"editUrl":16,"head":996,"template":18,"sidebar":997,"pagefind":16,"draft":20},"基本要素",[],{"hidden":20,"attrs":998},{},"ページの基本要素 📄\nPlaywrightで最も頻繁に使用する要素について解説します。\n\npageオブジェクト: Playwrightのすべてのブラウザ操作の起点となる中心的なオブジェクトです。\n\nLocator: Playwright 1.14以降で導入された推奨されるセレクタエンジンで、要素を一意に特定するための強力な機能です。page.getByRole(), page.getByLabel(), page.getByTestId()などのメソッドを通じて、より堅牢なテストを作成する方法を説明します。\n\n要素の操作 🖱️\nユーザーがWebページ上の要素とどのようにインタラクションするかを説明します。\n\nクリック: locator.click()やpage.click()を使用して要素をクリックする方法。\n\n入力: locator.fill()やpage.fill()を使用してテキストフィールドに入力する方法。\n\nキーボード操作: page.press()やpage.keyboardオブジェクトを使ってキーボードイベントをシミュレートする方法。\n\nその他の操作: ホバー、ドラッグ＆ドロップ、ファイルのアップロードなど、より複雑な操作を網羅します。\n\nアサーションと検証 ✅\n要素が期待通りの状態であることを検証するための方法を解説します。\n\nexpect: Playwrightのテストランナーに組み込まれているアサーションライブラリです。\n\n要素の可視性: toBeVisible()を使用して要素が表示されているか確認する方法。\n\nテキストの検証: toHaveText()やtoContainText()を使用して要素のテキストコンテンツを検証する方法。\n\n属性とプロパティ: toHaveAttribute()やtoHaveClass()を使用して要素の属性を検証する方法。\n\n高度なトピック 🚀\nより複雑なテストシナリオをカバーするための高度な概念を説明します。\n\n自動ウェイト: Playwrightが要素の状態変化をどのように自動的に待機するかを詳しく解説し、テストの不安定な動作を防ぐ方法を理解させます。\n\n複数の要素の操作: locator.nth(), locator.first(), locator.last()などを使って、複数の要素を扱う方法。\n\nフレームとタブ: frameやpageオブジェクトを使って、複数のフレームやタブを切り替えて操作する方法。\n\nネットワーク操作: page.route()メソッドを使って、APIリクエストをモックしたり、ネットワークリソースを監視したりする方法。\n\nこれらのセクションを網羅することで、Playwrightの初心者から上級者まで、誰にとっても価値のあるドキュメントを作成できます。","src/content/docs/playwrightガイド/02_基本/基本.mdx","ebeae9d9fcb57a01","playwrightガイド/03_中級/api利用法",{"id":1002,"data":1004,"body":1008,"filePath":1009,"digest":1010,"deferredRender":16},{"title":388,"editUrl":16,"head":1005,"template":18,"sidebar":1006,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1007},{},"## PlaywrightのAPI利用法\n\n### 基本的なテスト\n\nPlaywrightを使用して基本的なテストを作成します。\n\n```javascript\nconst { test, expect } = require('@playwright/test');\n\ntest('basic test', async ({ page }) => {\n  await page.goto('https://example.com');\n  const title = await page.title();\n  expect(title).toBe('Example Domain');\n});\n```\n\n### 高度なテスト\n\nPlaywrightを使用して高度なテストを作成します。\n\n```javascript\nconst { test, expect } = require('@playwright/test');\n\n// 並行テストの実行\n// 複数のブラウザコンテキストで同時にテストを実行します。\ntest('parallel test', async ({ browser }) => {\n  const context1 = await browser.newContext();\n  const page1 = await context1.newPage();\n  await page1.goto('https://example.com');\n\n  const context2 = await browser.newContext();\n  const page2 = await context2.newPage();\n  await page2.goto('https://example.org');\n\n  const title1 = await page1.title();\n  const title2 = await page2.title();\n\n  expect(title1).toBe('Example Domain');\n  expect(title2).toBe('Example Domain');\n});\n\n// ネットワークのモック\n// APIリクエストをモックしてテストを行います。\ntest('network mocking', async ({ page }) => {\n  await page.route('**/api/data', route => {\n    route.fulfill({\n      status: 200,\n      contentType: 'application/json',\n      body: JSON.stringify({ data: 'mocked data' })\n    });\n  });\n\n  await page.goto('https://example.com');\n  // ここでモックされたデータを使用したテストを行います。\n});\n\n// デバイスエミュレーション\n// モバイルデバイスをエミュレートしてテストを行います。\ntest('device emulation', async ({ browser }) => {\n  const iPhone = playwright.devices['iPhone 11'];\n  const context = await browser.newContext({ ...iPhone });\n  const page = await context.newPage();\n  await page.goto('https://example.com');\n  // モバイルビューでのテストを行います。\n});\n```\n\n### モックとスパイ\n\nPlaywrightでは、ネットワークのモックを行うことができますが、関数のスパイ機能は直接的には提供されていません。以下に、PlaywrightとJestを組み合わせたモックとスパイの例を示します。\n\n#### ネットワークのモック\n\nPlaywrightを使用して、特定のAPIリクエストをモックすることができます。これにより、外部APIのレスポンスを制御し、テストを行うことが可能です。\n\n```javascript\nawait page.route('**/api/data', route => {\n  route.fulfill({\n    status: 200,\n    contentType: 'application/json',\n    body: JSON.stringify({ data: 'mocked data' })\n  });\n});\n```\n\n#### 関数のスパイ\n\nJestを使用することで、関数の呼び出しをスパイし、どのように呼び出されたかを検証することができます。\n\n```javascript\n// Jestを使用した関数のスパイ例\nconst myFunction = jest.fn();\nmyFunction();\nexpect(myFunction).toHaveBeenCalled();\n```\n\nこれらの機能を組み合わせることで、より柔軟で強力なテストを作成することができます。\n\n### ベストプラクティス\n\n- テストは独立して実行できるように設計します。\n- テストデータはモックまたはスタブを使用して管理します。\n- テストの実行速度を最適化するために、並行テストを活用します。\n- エラーハンドリングを適切に行い、詳細なエラーメッセージを提供します。\n\n### PlaywrightのAPI利用法についての追加解説 📝\n\n提示された内容に加えて、テストの信頼性とメンテナンス性をさらに高めるための補足事項をいくつか追加します。\n\n1. **Locatorを使用したベストプラクティス**\n   - `page.click()`や`page.fill()`にセレクタ文字列を直接渡す方法は、要素のセレクタが変更された場合にテストが壊れやすくなる可能性があります。Playwrightの最新のベストプラクティスでは、Locatorを使用することが強く推奨されています。\n\n   **なぜLocatorを使うべきか？**\n   - Locatorは、ユーザーが要素とやり取りするのと同じように、HTMLのセマンティクスやアクセシビリティに基づいて要素を見つけます。これにより、セレクタが変更されてもテストコードを書き換える必要が少なくなり、テストの堅牢性が向上します。\n\n   | セレクタ | pageメソッド | page.locatorメソッド |\n   | --- | --- | --- |\n   | テキスト | `page.click('text=Log in')` | `page.getByText('Log in').click()` |\n   | ロール (ARIA) | `page.click('[role=button]')` | `page.getByRole('button').click()` |\n   | ラベル | `page.fill('label=Username', 'test')` | `page.getByLabel('Username').fill('test')` |\n   | テストID | `page.click('[data-testid=login-btn]')` | `page.getByTestId('login-btn').click()` |\n\n   **例の改善:**\n   - 提示されたコードの`page.fill('#username', 'testuser');`は、id属性に依存しています。より堅牢な方法として、`page.getByLabel()`やカスタムテストIDを使用する形に書き換えることができます。\n\n   ```javascript\n   test('より堅牢なユーザーインタラクション', async ({ page }) => {\n     await page.goto('https://playwright.dev/login');\n     // ラベルに基づいて要素を探す\n     await page.getByLabel('Username').fill('testuser');\n     await page.getByLabel('Password').fill('password123');\n     // テキストに基づいてボタンを探す\n     await page.getByText('Log in').click();\n     \n     const welcomeMessage = await page.locator('#welcome-message');\n     await expect(welcomeMessage).toHaveText('Welcome, testuser!');\n   });\n   ```\n\n2. **並行テストのWorkerプロセスについて**\n   - 提示された「並行テスト」の例では、`newContext()`を複数作成してテストしていますが、Playwrightのテストランナーは、デフォルトでWorkerプロセスを使用して並行テストを実行します。これは、`playwright.config.js`で設定された`workers`の数に応じて、複数のテストファイルまたはテストケースを同時に実行する機能です。\n\n   **Workerプロセスの利点:**\n   - テストの高速化: 複数のテストケースを同時に実行することで、実行時間を大幅に短縮できます。\n   - 分離された環境: 各Workerプロセスは独立したブラウザコンテキスト（クリーンなセッション）で実行されるため、テスト間でのデータの干渉を防ぎます。\n\n   **正しい並行テストの実装:**\n   - 特別な理由がない限り、テストケースごとに`test()`関数を記述するだけで、Playwrightが自動で並行実行してくれます。\n\n   ```javascript\n   // test-file1.spec.js\n   test('Test A', async ({ page }) => { ... });\n\n   // test-file2.spec.js\n   test('Test B', async ({ page }) => { ... });\n   ```\n   - 上記のテストは、`npx playwright test`を実行すると、異なるWorkerで並行して実行されます。\n\n3. **モックとスパイの使い分け**\n   - 提示されたモックとスパイの組み合わせは正しいアプローチです。\n\n   **モック:**\n   - 外部リソース（API、ファイルなど）の振る舞いを模倣し、テスト環境を制御します。Playwrightの`page.route()`がこれに該当します。\n\n   **スパイ:**\n   - 既存の関数の呼び出しを監視し、その呼び出し回数や引数などを検証します。JestやVitestのようなテストフレームワークの機能がこれに該当します。\n\n   - これらの概念を適切に使い分けることで、より堅牢な単体テストや統合テストを作成できます。PlaywrightとJestの組み合わせは、E2Eテストとユニットテストの境界を明確にするための良い例です。\n\n### APIテストと認証 🔐\n\nPlaywrightは、APIテストにおいて認証を扱うための強力な機能を提供します。APIリクエストに認証トークンやセッション情報を含めることで、保護されたエンドポイントをテストできます。\n\n#### requestフィクスチャ\n\nUIテストで使われる`page`フィクスチャとは別に、PlaywrightはAPIテスト専用の**`request`フィクスチャ**を提供しています。これにより、UIを介さずに直接APIリクエストを送信できます。\n\n```javascript\nimport { test, expect } from '@playwright/test';\n\ntest('認証されたAPIリクエストのテスト', async ({ request }) => {\n  // 認証トークンをヘッダーに含める\n  const response = await request.get('https://api.example.com/protected/data', {\n    headers: {\n      'Authorization': `Bearer YOUR_ACCESS_TOKEN`,\n    },\n  });\n\n  // レスポンスのステータスコードを検証\n  expect(response.status()).toBe(200);\n\n  // レスポンスのボディを検証\n  const data = await response.json();\n  expect(data.isProtected).toBe(true);\n});\n```\n\n- `request`フィクスチャは、**`playwright.config.js`**で`baseURL`や`extraHTTPHeaders`を設定することで、テスト全体で共通の認証情報を利用できます。\n\n#### 認証状態の再利用\n\n`test.use()`を使用して、認証状態をテスト間で共有することで、テストの実行時間を短縮できます。ログイン処理を一度だけ行い、その認証状態を後続のすべてのテストで再利用するシナリオに役立ちます。\n\n```javascript\ntest.use({ storageState: 'playwright/.auth/user.json' });\n\n// このブロック内のテストはすべてログイン済み\ntest('ログイン後のページアクセス', async ({ page }) => {\n  await page.goto('https://example.com/dashboard');\n  // ダッシュボードのコンテンツが表示されていることを確認\n  await expect(page.locator('h1')).toHaveText('Dashboard');\n});\n```\n\n- `playwright.config.js`にこの設定を追加することで、テストランナーが自動的に認証状態を読み込み、テストを高速化します。\n\n### APIテストとUIテストの連携 🔗\n\nPlaywrightの最大の強みの一つは、APIテストとUIテストを同じフレームワーク内でシームレスに連携できることです。\n\n#### APIでテストデータを準備する\n\nユーザーインターフェースを操作する前に、APIを使ってテストデータを準備するシナリオは非常に効率的です。\n\n```javascript\ntest('APIでデータを準備し、UIで検証', async ({ page, request }) => {\n  // 1. APIを使って新しい投稿を作成\n  const postResponse = await request.post('https://api.example.com/posts', {\n    data: { title: 'Test Post', content: 'Hello, World!' },\n  });\n  const newPost = await postResponse.json();\n\n  // 2. UIで新しく作成された投稿を検証\n  await page.goto(`https://example.com/posts/${newPost.id}`);\n  await expect(page.locator('h1')).toHaveText('Test Post');\n});\n```\n\n- このアプローチは、UIを介した複雑なセットアッププロセスを省略し、テストの信頼性と速度を向上させます。\n\nこれらのトピックを追加することで、Playwrightが単なるUIテストツールではなく、包括的なエンドツーエンドテストフレームワークとしていかに強力であるかをより明確に伝えられます。","src/content/docs/playwrightガイド/03_中級/API利用法.mdx","c801f75b5519bf2e","playwrightガイド/04_上級最適化/パフォーマンスチューニング",{"id":1011,"data":1013,"body":1017,"filePath":1018,"digest":1019,"deferredRender":16},{"title":328,"editUrl":16,"head":1014,"template":18,"sidebar":1015,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1016},{},"Playwrightのパフォーマンスチューニング方法を以下に示します。\n\n## 並列テストの実行\n\nPlaywrightでは、並列にテストを実行することで、テストスイートの実行時間を短縮できます。\n\n```javascript\n// playwright.config.js\nmodule.exports = {\n  projects: [\n    { name: 'firefox', use: { browserName: 'firefox' } },\n    { name: 'webkit', use: { browserName: 'webkit' } },\n    { name: 'chromium', use: { browserName: 'chromium' } },\n  ],\n};\n```\n\n## ヘッドレスモード\n\nヘッドレスモードでテストを実行することで、リソースの消費を抑えることができます。\n\n```javascript\nconst { chromium } = require('playwright');\n\n(async () => {\n  const browser = await chromium.launch({ headless: true });\n  const page = await browser.newPage();\n  await page.goto('https://example.com');\n  await browser.close();\n})();\n```","src/content/docs/playwrightガイド/04_上級・最適化/パフォーマンスチューニング.mdx","6641ab219becb619","nodejsガイド/01_はじめに/01_install",{"id":1020,"data":1022,"body":1027,"filePath":1028,"digest":1029,"deferredRender":16},{"title":1023,"editUrl":16,"head":1024,"template":18,"sidebar":1025,"pagefind":16,"draft":20},"Node.jsのインストール",[],{"hidden":20,"attrs":1026},{},"## Node.jsのインストール方法\n\nNode.jsをインストールする主な方法は、開発の目的や好みに応じて3つの選択肢があります。\n\n### 1. 公式サイトからのインストーラー利用\n\nNode.jsを単一のバージョンでシンプルに使い始めたい場合に最適な方法です。\n\n- **手順**: Node.jsの公式サイトからインストーラーをダウンロードして実行するだけです。LTS（長期サポート）版が推奨されています。\n- **メリット**:\n  - セットアップが最も簡単で直感的です。\n  - 特定のプロジェクトでバージョンの変更が不要な場合に適しています。\n- **デメリット**:\n  - 複数のNode.jsバージョンを管理したり、切り替えたりするのが困難です。\n\n### 2. nvm (Node Version Manager) の利用\n\nnvmは、複数のNode.jsバージョンを簡単にインストールし、切り替えて管理するためのツールです。多くの開発者が最も広く使用しています。\n\n- **インストール手順**: ターミナルでインストーラースクリプトを実行し、`nvm install \u003Cversion>`や`nvm use \u003Cversion>`などのコマンドでバージョンを管理します。\n- **メリット**:\n  - プロジェクトごとに異なるNode.jsバージョンを簡単に切り替えられます。\n  - 新しいバージョンを試すのが容易です。\n- **デメリット**:\n  - シェルスクリプトとして動作するため、Windows環境では互換性の問題が発生することがあります。\n  - プロジェクトディレクトリに移動しただけではバージョンが自動的に切り替わらないため、手動で`nvm use`を実行する必要があります。\n\n### 3. volta の利用\n\nvoltaは、Node.js、npm、yarnのバージョンを自動的に管理する新しいツールです。ユーザーはツールのバージョンを意識することなく開発に集中できます。\n\n- **インストール手順**: `curl | bash` または `npm install` コマンドで簡単にインストールできます。\n- **特徴**:\n  - **シームレスな自動切り替え**: プロジェクトディレクトリに移動すると、`package.json`ファイルに定義されたバージョン\n  ```bash\n  （\"engines\": { \"node\": \"16.x\" }など）\n  ```\n  を自動で検出し、適切なバージョンに切り替えます。手動で`volta use`などのコマンドを実行する必要はありません。\n  - **グローバルなツールセット**: Node.jsだけでなく、npmやyarnといったツールも管理できます。例えば、`volta install yarn@1.22.19`とすれば、そのバージョンがグローバルな環境で利用可能になります。\n  - **速度**: Rustで書かれているため、高速です。\n- **メリット**:\n  - 開発体験の向上: バージョン管理の手間が大幅に削減されます。\n  - 異なるプロジェクトを頻繁に切り替える場合に非常に便利です。\n- **デメリット**:\n  - nvmに比べて歴史が浅く、コミュニティの規模が小さいです。\n\n### 比較と使い分け\n\n| 特徴 | インストーラー | nvm | volta |\n|------|---------------|-----|-------|\n| 自動バージョン切り替え | ❌ | ❌（手動でnvm useが必要） | ✅（プロジェクトディレクトリで自動） |\n| 複数のバージョン管理 | ❌ | ✅ | ✅ |\n| グローバルツールの管理 | ❌ | ❌ | ✅ |\n| 導入の容易さ | ✅ | 🔺（シェルスクリプト） | ✅（シンプル） |\n| 用途 | 単一プロジェクト、初心者 | 複数のプロジェクト、Linux/macOSユーザー | 複数のプロジェクト、開発体験を重視するユーザー |\n\n個人的には、複数のプロジェクトを扱い、バージョン管理の手間を最小限に抑えたい場合は、volta が最も優れた選択肢です。インストールしてしまえば、Node.jsのバージョンを意識することなく開発に集中できます。","src/content/docs/node.jsガイド/01_はじめに/01_install.mdx","b33667f83454e92a","nodejsガイド/01_はじめに/02_basic_syntax",{"id":1030,"data":1032,"body":1037,"filePath":1038,"digest":1039,"deferredRender":16},{"title":1033,"editUrl":16,"head":1034,"template":18,"sidebar":1035,"pagefind":16,"draft":20},"基本的な構文",[],{"hidden":20,"attrs":1036},{},"## Node.jsの基本構文\n\nNode.jsは、Google ChromeのV8 JavaScriptエンジンを基盤として、サーバーサイドでJavaScriptを実行するための環境です。提供されたコードは、Node.jsの主要な特徴である「モジュールのインポート」と「非同期処理」を示しています。\n\n### 1. モジュールのインポート (require)\n\nNode.jsでは、`require()`関数を使って他のファイルや組み込みモジュールを読み込み、アプリケーションで利用します。これにより、コードを小さな部品に分割して管理できます。\n\n```javascript\nconst fs = require('fs');\n```\n\n- `fs`は「File System」の略で、Node.jsに標準で組み込まれているモジュールです。\n- この行は、ファイルシステムを操作するための機能（ファイルの読み書きなど）を、`fs`という定数にインポートしています。\n- このように、必要な機能だけを読み込むことで、メモリの消費を抑え、コードを整理できます。\n\n### 2. 非同期処理 (async/await)\n\nNode.jsは、シングルスレッドで動作するため、時間のかかるI/O処理（ファイルの読み書き、ネットワーク通信、データベースアクセスなど）を同期的に実行すると、後続の処理がすべて停止してしまいます。これを避けるために、非同期処理が不可欠です。\n\n```javascript\nasync function readFileAsync(path) {\n  const data = await fs.promises.readFile(path, 'utf8');\n  console.log(data);\n}\n```\n\n- `async`キーワードは、この関数が非同期であることを示します。この関数は`Promise`を返します。\n- この関数内では、時間のかかる処理を一時停止し、完了後に再開することができます。\n- `await`キーワードは、`Promise`が完了（解決または拒否）するまで、この行の実行を一時停止します。\n- `fs.promises.readFile()`は、ファイルを非同期に読み込む`Promise`ベースのメソッドです。\n- ファイル読み込みが完了すると、その結果が`data`変数に代入され、次の行の`console.log(data)`が実行されます。\n\nこれにより、ファイルI/Oの完了を待つ間も、Node.jsは他のリクエストを処理し続けることができます。\n\nこれらの構文は、Node.jsアプリケーションを効率的でスケーラブルにするための基本であり、サーバー開発において非常に重要です。","src/content/docs/node.jsガイド/01_はじめに/02_basic_syntax.mdx","90d66ab7fcfb6361","nodejsガイド/01_はじめに/03_server_setup",{"id":1040,"data":1042,"body":1047,"filePath":1048,"digest":1049,"deferredRender":16},{"title":1043,"editUrl":16,"head":1044,"template":18,"sidebar":1045,"pagefind":16,"draft":20},"サーバーの構築",[],{"hidden":20,"attrs":1046},{},"Node.jsの`http`モジュールを使用して、基本的なサーバーを構築します。\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello, World!\\n');\n});\n\nserver.listen(3000, '127.0.0.1', () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});\n```","src/content/docs/node.jsガイド/01_はじめに/03_server_setup.mdx","6c7d89000cf14179","nodejsガイド/01_はじめに/04_package_management",{"id":1050,"data":1052,"body":1057,"filePath":1058,"digest":1059,"deferredRender":16},{"title":1053,"editUrl":16,"head":1054,"template":18,"sidebar":1055,"pagefind":16,"draft":20},"パッケージ管理",[],{"hidden":20,"attrs":1056},{},"npmを使用してパッケージをインストールし、管理します。\n\n```bash\n# パッケージのインストール\nnpm install express\n```","src/content/docs/node.jsガイド/01_はじめに/04_package_management.mdx","357d9a3076784fd4","nodejsガイド/01_はじめに/05_express_framework",{"id":1060,"data":1062,"body":1067,"filePath":1068,"digest":1069,"deferredRender":16},{"title":1063,"editUrl":16,"head":1064,"template":18,"sidebar":1065,"pagefind":16,"draft":20},"Expressフレームワーク",[],{"hidden":20,"attrs":1066},{},"Expressを使用して、Webアプリケーションを構築します。\n\n```javascript\nconst express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('Hello, Express!');\n});\n\napp.listen(3000, () => {\n  console.log('Express server running on port 3000');\n});\n```","src/content/docs/node.jsガイド/01_はじめに/05_express_framework.mdx","ec21b1ad2b19c45d","nodejsガイド/01_はじめに/06_database_integration",{"id":1070,"data":1072,"body":1077,"filePath":1078,"digest":1079,"deferredRender":16},{"title":1073,"editUrl":16,"head":1074,"template":18,"sidebar":1075,"pagefind":16,"draft":20},"データベースとの連携",[],{"hidden":20,"attrs":1076},{},"MongoDBを使用して、データベースと接続します。\n\n```javascript\nconst mongoose = require('mongoose');\n\nmongoose.connect('mongodb://localhost:27017/mydatabase', { useNewUrlParser: true, useUnifiedTopology: true });\n\nconst db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'connection error:'));\ndb.once('open', () => {\n  console.log('Connected to MongoDB');\n});\n```","src/content/docs/node.jsガイド/01_はじめに/06_database_integration.mdx","9ff40aa6f4a9da83","nodejsガイド/01_はじめに/08_deployment",{"id":1080,"data":1082,"body":1087,"filePath":1088,"digest":1089,"deferredRender":16},{"title":1083,"editUrl":16,"head":1084,"template":18,"sidebar":1085,"pagefind":16,"draft":20},"デプロイメント",[],{"hidden":20,"attrs":1086},{},"Herokuを使用して、Node.jsアプリケーションをデプロイします。\n\n```bash\n# Heroku CLIのインストール\ncurl https://cli-assets.heroku.com/install.sh | sh\n\n# アプリケーションのデプロイ\nheroku create\nheroku git:remote -a your-app-name\ngit push heroku main\n```","src/content/docs/node.jsガイド/01_はじめに/08_deployment.mdx","ef5184a8c15a48fc","nodejsガイド/01_はじめに/09_why_nodejs",{"id":1090,"data":1092,"body":1097,"filePath":1098,"digest":1099,"deferredRender":16},{"title":1093,"editUrl":16,"head":1094,"template":18,"sidebar":1095,"pagefind":16,"draft":20},"なぜNode.jsを使用するのか",[],{"hidden":20,"attrs":1096},{},"## Node.jsは、JavaScriptを使用してサーバーサイドのアプリケーションを構築するためのランタイムです。\n\n### 理由\n\n- **非同期I/O**: 非同期I/Oモデルにより、高いスループットを実現します。\n- **JavaScriptの再利用**: フロントエンドとバックエンドで同じ言語を使用でき、開発が効率化されます。\n\n### 他の言語との差別化\n\n- **シングルスレッド**: シングルスレッドで動作し、イベント駆動型のアーキテクチャを採用しています。\n- **豊富なパッケージ**: npmを通じて、多数のパッケージが利用可能です。","src/content/docs/node.jsガイド/01_はじめに/09_why_nodejs.mdx","67c488b12100d900","nodejsガイド/01_はじめに/フォルダ構成",{"id":1100,"data":1102,"body":919,"filePath":1106,"digest":1107,"deferredRender":16},{"title":408,"editUrl":16,"head":1103,"template":18,"sidebar":1104,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1105},{},"src/content/docs/node.jsガイド/01_はじめに/フォルダ構成.mdx","cb3f658fed88772a","nodejsガイド/01_はじめに/初心者向けガイド",{"id":1108,"data":1110,"body":1114,"filePath":1115,"digest":1116,"deferredRender":16},{"title":505,"editUrl":16,"head":1111,"template":18,"sidebar":1112,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1113},{},"Node.jsの初心者向けガイドを以下に示します。\n\n## Node.jsとは\n\nNode.jsは、JavaScriptを使用してサーバーサイドのアプリケーションを構築するためのプラットフォームです。\n\n## 前提知識\n\n- JavaScriptの基本的な知識\n- サーバーサイドプログラミングの基礎","src/content/docs/node.jsガイド/01_はじめに/初心者向けガイド.mdx","2098043aef4ae27c","railsガイド/01_はじめに/01_初心者向けガイド",{"id":1117,"data":1119,"body":1123,"filePath":1124,"digest":1125,"deferredRender":16},{"title":505,"editUrl":16,"head":1120,"template":18,"sidebar":1121,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1122},{},"Railsの初心者向けガイドを以下に示します。\n\n## Railsとは\n\nRailsは、Rubyプログラミング言語を使用したWebアプリケーションフレームワークです。\n\n## 前提知識\n\n- Rubyの基本的な知識\n- Web開発の基礎\n\n### なぜRailsを使用するのか？\n\nRailsは、開発者がよりスムーズに、そして効率的に作業できるよう、多くのメリットを提供しているからです。\n\n#### 開発スピードの速さ\n\nRailsには、「Convention over Configuration（設定より規約）」という思想が根付いています。これは、開発者が細かな設定に時間をかける代わりに、フレームワークが推奨する「規約」に従うことで、すぐに開発を始められるという考え方です。これにより、開発者はアプリケーションの主要な機能開発に集中できます。\n\n#### 豊富なエコシステム\n\nRailsの大きな魅力の一つが「Gem（ジェム）」と呼ばれる、豊富なライブラリ（機能のパッケージ）です。これにより、ユーザー認証、画像アップロード、決済システムといった、多くのアプリケーションに共通する機能をゼロから作る必要がありません。既存の高品質なGemを組み込むだけで、開発時間を大幅に短縮できます。\n\n#### 強固なコミュニティとサポート\n\nRailsは世界中に熱心な開発者コミュニティを持っています。公式ドキュメントや豊富なチュートリアル、そしてオンラインフォーラムが充実しているため、もし開発中に問題に直面しても、解決策を見つけやすいのが特徴です。この強力なコミュニティサポートは、特に初心者にとって心強い味方となります。\n\n#### 効率的な設計パターン（MVC）\n\nRailsは**MVC（Model-View-Controller）**という設計パターンを採用しています。このパターンは、アプリケーションの役割を以下の3つに分割することで、コードの整理と管理を容易にします。\n\n- **Model（モデル）**: データの管理やビジネスロジックを担います。データベースとのやり取りを処理します。\n- **View（ビュー）**: ユーザーインターフェース（HTMLやCSS）を生成し、ユーザーに情報を表示します。\n- **Controller（コントローラー）**: ユーザーからのリクエストを受け取り、モデルとビューを連携させます。\n\nこの設計により、役割分担が明確になり、チームでの開発や大規模なアプリケーションのメンテナンスがしやすくなります。","src/content/docs/railsガイド/01_はじめに/01_初心者向けガイド.mdx","215f5139523ea8ce","railsガイド/01_はじめに/02_環境構築",{"id":1126,"data":1128,"body":1132,"filePath":1133,"digest":1134,"deferredRender":16},{"title":427,"editUrl":16,"head":1129,"template":18,"sidebar":1130,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1131},{},"## 環境構築\n\nRailsでの開発を始めるには、まず開発環境を整える必要があります。ここでは、RubyとRailsのインストール手順を解説します。\n\n### Rubyのインストール\n\nRubyのバージョン管理には「rbenv」の利用をおすすめします。これにより、複数のRubyバージョンを簡単に切り替えることができ、プロジェクトごとに最適なバージョンを使えます。\n\n#### rbenvのインストール\n\nターミナルを開き、以下のコマンドを実行してrbenvをインストールします。macOSをご利用の場合はHomebrewが便利です。\n\n```bash\nbrew install rbenv\nrbenv init\n```\n\n`rbenv init`を実行すると、ターミナル起動時にrbenvが自動的に読み込まれるよう設定が行われます。指示に従って、`.zshrc`や`.bash_profile`などのシェル設定ファイルに追記してください。\n\n#### Rubyのインストール\n\n次に、rbenvを使ってRubyをインストールします。ここでは例としてバージョン3.3.0をインストールしますが、Railsガイドなどで推奨されている最新の安定版を選ぶと良いでしょう。\n\n```bash\nrbenv install 3.3.0 # 最新の安定版を指定\nrbenv global 3.3.0 # このバージョンをシステム全体で使うように設定\n```\n\n### Railsのインストール\n\nRubyがインストールできたら、いよいよRailsをインストールします。\n\n#### Railsのインストール\n\n以下のコマンドを実行して、RailsをGemとしてインストールします。\n\n```bash\ngem install rails\n```\n\nこれにより、Railsフレームワークとその依存関係がすべてインストールされます。\n\n#### インストールの確認\n\nインストールが完了したら、以下のコマンドでRailsのバージョンを確認し、正しくインストールされたかを確認しましょう。\n\n```bash\nrails -v\n```\n\nバージョン情報が表示されれば、Railsの開発環境構築は完了です！ 🎉 これで、Webアプリケーション開発の準備が整いました。","src/content/docs/railsガイド/01_はじめに/02_環境構築.mdx","81d6c02e84582173","railsガイド/03_中級/01_apiモード",{"id":1135,"data":1137,"body":1141,"filePath":1142,"digest":1143,"deferredRender":16},{"title":388,"editUrl":16,"head":1138,"template":18,"sidebar":1139,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1140},{},"## API利用法\n\nRailsは、通常のWebアプリケーションだけでなく、API（Application Programming Interface）を構築するための機能も充実しています。ここでは、APIモードでの開発方法と、CORS（Cross-Origin Resource Sharing）の設定について解説します。\n\n### APIモード\n\nRailsでは、API専用のアプリケーションを簡単に作成できます。これにより、HTMLやCSSの生成といった、Webページ表示に必要な機能を省き、軽量で高速なアプリケーションを構築できます。\n\n以下のコマンドで新しいRailsアプリケーションを作成する際に、`--api`オプションを追加します。\n\n```bash\nrails new my_api --api\n```\n\nこのコマンドで作成されたアプリケーションは、以下の設定が自動的に適用されます。\n\n- **ミドルウェアの最適化**: Webページ表示用のミドルウェア（例：ActionView、sprockets）が読み込まれず、より高速に動作します。\n- **ジェネレーターの変更**: `rails generate`コマンドでビューファイル（.html.erbなど）が生成されなくなります。\n\n### コントローラーの作成\n\nAPIモードのアプリケーションで、JSONデータを返すためのコントローラーを作成します。\n\n```bash\nrails generate controller Api::V1::Posts index show create update destroy\n```\n\nこのコマンドは、`app/controllers/api/v1`ディレクトリに`posts_controller.rb`を作成し、`index`、`show`、`create`、`update`、`destroy`といったアクションを定義します。\n\n### CORS（Cross-Origin Resource Sharing）の設定\n\nAPIを開発する上で、異なるドメインからのリクエストを許可するCORSの設定は不可欠です。Railsでは`rack-cors`というGemを使って簡単に設定できます。\n\n#### Gemの追加\n\n`Gemfile`に以下の行を追加し、`bundle install`を実行します。\n\n```ruby\n# Gemfile\ngem 'rack-cors'\n```\n\n```bash\nbundle install\n```\n\n#### 設定ファイルの編集\n\n`config/initializers/cors.rb`ファイルを開き、コメントアウトされている部分を以下のように編集します。\n\n```ruby\n# config/initializers/cors.rb\n\nRails.application.config.middleware.insert_before 0, Rack::Cors do\n  allow do\n    origins '*'  # 任意のドメインからのリクエストを許可\n    resource '*',\n      headers: :any,\n      methods: [:get, :post, :put, :patch, :delete, :options, :head]\n  end\nend\n```\n\n`origins '*'`は、すべてのドメインからのアクセスを許可する設定です。セキュリティを考慮し、本番環境では特定のドメインのみを許可するように変更することが推奨されます。\n\n例: `origins 'http://example.com'` とすることで、`http://example.com`からのリクエストのみを許可できます。","src/content/docs/railsガイド/03_中級/01_APIモード.mdx","60c610dedbd7fb7c","railsガイド/03_中級/orm",{"id":1144,"data":1146,"body":1151,"filePath":1152,"digest":1153,"deferredRender":16},{"title":1147,"editUrl":16,"head":1148,"template":18,"sidebar":1149,"pagefind":16,"draft":20},"Rails ORM",[],{"hidden":20,"attrs":1150},{},"Rails ORM\nRailsにおけるORM（Object-Relational Mapping）は、Active Recordというライブラリを指します。Active Recordは、データベースのテーブルをRubyのクラスとして扱い、SQLを直接書かずにデータベース操作を可能にするフレームワークです。これにより、開発者はオブジェクト指向的なアプローチでデータと向き合うことができ、コードの可読性と保守性が向上します。\n\nActive Recordの主な機能\n1. データベースとの連携\nActive Recordは、モデルクラスとデータベーステーブルを自動でマッピングします。例えば、usersという名前のテーブルがあれば、Userというモデルクラスを定義するだけで、テーブルの各カラムがモデルの属性（attribute）として利用可能になります。\n\n例：データの取得\nUserクラスを使って、データベースからデータを取得できます。\n\nRuby\n\n# 全ユーザーを取得\nusers = User.all\n\n# IDが1のユーザーを取得\nuser = User.find(1)\n\n# メールアドレスでユーザーを検索\nuser = User.find_by(email: \"test@example.com\")\n2. データの作成・更新・削除\nActive Recordは、データのCRUD（Create, Read, Update, Delete）操作をメソッドとして提供します。\n\n例：データの作成\nRuby\n\n# 新しいユーザーインスタンスを作成し、データベースに保存\nuser = User.create(name: \"Alice\", email: \"alice@example.com\")\n例：データの更新\nRuby\n\n# 既存ユーザーの情報を更新\nuser.update(email: \"new_email@example.com\")\n例：データの削除\nRuby\n\n# ユーザーをデータベースから削除\nuser.destroy\n3. バリデーションとコールバック\nActive Recordは、データの整合性を保つための機能も提供します。\n\n例：バリデーション\nvalidatesメソッドを使って、データ保存前の検証ルールを定義できます。\n\nRuby\n\nclass User \u003C ApplicationRecord\n  validates :name, presence: true # 名前が必須であることを検証\n  validates :email, uniqueness: true # メールアドレスが一意であることを検証\nend\n例：コールバック\nデータの保存や削除といった特定のイベントが発生したときに、自動で実行されるメソッドを定義できます。\n\nRuby\n\nclass Post \u003C ApplicationRecord\n  before_save :set_slug\n\n  private\n  def set_slug\n    # タイトルからスラグを自動生成\n    self.slug = self.title.parameterize\n  end\nend\n4. 関連付け（Association）\n複数のモデル間の関係性を定義することで、関連するデータを簡単に操作できます。\n\n例：1対多の関係\nhas_many：Userは多数のPostを持つ。\n\nbelongs_to：Postは1つのUserに属する。\n\nRuby\n\nclass User \u003C ApplicationRecord\n  has_many :posts\nend\n\nclass Post \u003C ApplicationRecord\n  belongs_to :user\nend\nこの関連付けを定義することで、user.postsでそのユーザーの投稿一覧を、post.userでその投稿の作成者を取得できます。\n\nActive Recordは、これらの機能を通じてデータベース操作を抽象化し、Rails開発の生産性を大幅に向上させます。","src/content/docs/railsガイド/03_中級/ORM.mdx","fa6e67cf04ee4d69","railsガイド/03_中級/シリアライザー",{"id":1154,"data":1156,"body":1160,"filePath":1161,"digest":1162,"deferredRender":16},{"title":388,"editUrl":16,"head":1157,"template":18,"sidebar":1158,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1159},{},"## 💎 なぜシリアライザーを使用するのか？\n\nシリアライザーは、データベースに保存されているデータと、クライアント（Webブラウザやモバイルアプリなど）に提供するJSONデータの形式を分離するために使われます。\n\n1. **データの整形とフィルタリング**\n   - データベースのテーブルには、認証情報や内部管理用のデータなど、APIのレスポンスとして公開すべきではない情報が含まれていることがあります。シリアライザーを使うことで、必要な属性だけを選択してJSONに含めることができ、不必要なデータや機密情報の漏洩を防ぐことができます。\n\n2. **関連データの組み込み**\n   - ブログの投稿（Post）と、その投稿に紐づくコメント（Comment）のような関連するデータがある場合、シリアライザーはこれらの関連情報を一つのJSONレスポンスに含めることを可能にします。これにより、クライアントは複数のAPIリクエストを送信することなく、必要なすべてのデータを一度に取得できます。\n\n3. **パフォーマンスの向上**\n   - 余分なデータを含まない、軽量なJSONレスポンスを提供することで、ネットワークの負荷を減らし、APIのレスポンス速度を向上させることができます。\n\n## 💡 Active Model Serializers の利用方法\n\nActive Model Serializers を利用したJSONレスポンス形式の定義方法について、おさらいします。\n\n1. **Gem の追加**\n   - まず、`Gemfile` に `active_model_serializers` を追加し、ターミナルで `bundle install` を実行します。\n\n   ```ruby\n   # Gemfile\ngem 'active_model_serializers'\n   ```\n\n2. **シリアライザーの生成**\n   - `rails generate serializer` コマンドを使って、モデルに対応するシリアライザーを作成します。\n\n   ```bash\n   rails generate serializer post\n   ```\n\n3. **シリアライザーの定義**\n   - `app/serializers/post_serializer.rb` ファイルを開き、レスポンスに含めたい属性を定義します。\n\n   ```ruby\n   # app/serializers/post_serializer.rb\n   class PostSerializer \u003C ActiveModel::Serializer\n     attributes :id, :title, :content, :created_at\n   end\n   ```\n\n4. **コントローラーでの利用**\n   - コントローラーで `@posts` オブジェクトをJSONとしてレンダリングするだけで、定義したシリアライザーが自動的に適用されます。\n\n   ```ruby\n   class PostsController \u003C ApplicationController\n     def index\n       @posts = Post.all\n       render json: @posts\n     end\n   end\n   ```\n\nこのように、シリアライザーはAPI開発におけるデータ管理をシンプルかつ効率的にし、セキュリティとパフォーマンスの向上に貢献します。","src/content/docs/railsガイド/03_中級/シリアライザー.mdx","ef0aecb4062c49cf","railsガイド/02_基本/01_フォルダ構成",{"id":1163,"data":1165,"body":1169,"filePath":1170,"digest":1171,"deferredRender":16},{"title":408,"editUrl":16,"head":1166,"template":18,"sidebar":1167,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1168},{},"## Railsのフォルダ構成\n\nRailsのフォルダ構成は、**MVC（Model-View-Controller）**の原則に基づいており、開発者がファイルを探しやすく、またアプリケーションの役割を理解しやすくなるよう設計されています。\n\n以下は、主要なフォルダとその役割です。\n\n```\n.\n├── app                # アプリケーションの核となるコードを格納\n│   ├── assets         # スタイルシート、JavaScript、画像などの静的ファイル\n│   │   ├── config\n│   │   ├── images\n│   │   ├── javascript\n│   │   └── stylesheets\n│   ├── channels       # Action Cable（WebSocket）関連のファイルを格納\n│   ├── controllers    # ユーザーからのリクエストを処理するコントローラー\n│   ├── helpers        # ビューで使用するヘルパーモジュール\n│   ├── jobs           # Active Jobによるバックグラウンドジョブ\n│   ├── mailers        # メール送信のためのクラス\n│   ├── models         # アプリケーションのデータとビジネスロジックを扱うモデル\n│   └── views          # ユーザーインターフェース（HTMLなど）を生成するビューテンプレート\n├── bin                # 実行可能なスクリプト\n│   ├── bundle\n│   ├── rails          # Railsコマンドの実行スクリプト\n│   └── rake           # Rakeタスクの実行スクリプト\n├── config             # アプリケーション全体の設定ファイル\n│   ├── environments   # 開発、テスト、本番など、環境ごとの設定\n│   ├── initializers   # アプリケーション起動時に実行されるカスタム設定\n│   ├── locales        # I18n（国際化）のための翻訳ファイル\n│   ├── application.rb # アプリケーション全体のコア設定\n│   ├── database.yml   # データベース接続設定\n│   └── routes.rb      # URLとコントローラーを結びつけるルーティング定義\n├── db                 # データベース関連のファイル\n│   ├── migrate        # データベーススキーマを変更するマイグレーションファイル\n│   └── seeds.rb       # データベースに初期データを投入するためのファイル\n├── lib                # アプリケーション全体で共有される独自のライブラリ\n├── log                # アプリケーションのログファイル\n├── public             # ウェブサーバーから直接アクセス可能な静的ファイル\n├── test               # テストファイル\n├── tmp                # 一時ファイル\n├── vendor             # 外部から取得したベンダー依存のコード\n└── Gemfile            # プロジェクトの依存関係（Gem）を管理\n```\n\n### `app`\n\nアプリケーションの核となるコードが置かれるフォルダです。MVCの各コンポーネントがこの中にあります。\n\n- **app/controllers**: リクエストを処理するコントローラーのコードを格納します。\n- **app/models**: アプリケーションのデータとビジネスロジックを扱うモデルのコードを格納します。\n- **app/views**: ユーザーインターフェース（HTMLやCSSなど）を生成するビューのテンプレートを格納します。\n- **app/assets**: スタイルシート（CSS）、JavaScript、画像などのアセットファイルが置かれます。\n\n### `bin`\n\n実行可能なスクリプトが格納されるフォルダです。\n\n- **bin/rails**: Railsコマンドを実行するためのスクリプト。\n- **bin/rake**: Rakeタスク（データベースのマイグレーションなど）を実行するためのスクリプト。\n\n### `config`\n\nアプリケーションの設定ファイルが格納されるフォルダです。\n\n- **config/routes.rb**: アプリケーションのルーティング（URLとコントローラーのアクションの紐付け）を定義します。\n- **config/database.yml**: データベースの接続設定を定義します。\n- **config/environments**: 開発、テスト、本番など、各環境ごとの設定を定義します。\n\n### `db`\n\nデータベースに関連するファイルが格納されます。\n\n- **db/migrate**: データベースのスキーマを変更するためのマイグレーションファイルが置かれます。\n- **db/schema.rb**: 現在のデータベーススキーマの構造を記録したファイルです。\n\n### `Dockerfile`\n\nアプリケーションをDockerコンテナとして動かすための設定ファイルです。本番環境でのデプロイを想定して作成されます。\n\n### `lib`\n\nアプリケーション全体で共有されるライブラリやモジュールを格納するフォルダです。\n\n### `log`\n\nアプリケーションのログファイルが格納されます。\n\n### `public`\n\nウェブサーバーから直接アクセス可能な静的ファイル（HTML、画像など）を格納します。\n\n### `test`\n\nアプリケーションのテストファイルが格納されます。\n\n### `vendor`\n\n外部から取得したベンダー依存のコード（サードパーティライブラリなど）を格納するフォルダです。\n\nこれらのフォルダは、Railsの「設定より規約」の思想に基づいているため、開発者はファイルを作成する場所を迷うことなく、効率的に開発を進めることができます。\n\nなお、ここからはRails7系以降の解説です。\n\n### 1. HotwireとStimulus\n\nRails 7以降、Hotwire（HTML Over The Wire）がデフォルトのフロントエンドアプローチとして採用されました。これは、JavaScriptを最小限に抑え、HTMLを通じてサーバーとやり取りすることで、SPA（Single Page Application）のような高速なユーザー体験を実現するものです。\n\n- **app/javascript/controllers**: このディレクトリは、Hotwireの一部であるStimulusのコントローラを格納するために使用されます。Stimulusは、HTMLに直接アクションやターゲットを記述することで、JavaScriptの振る舞いをカプセル化し、再利用可能なコンポーネントを作成できます。\n\n### 2. Propshaftとアセットパイプラインの進化\n\nRails 7では、従来のSprocketsに代わる新しいアセットマネジメントツールとしてPropshaftが導入されました。Propshaftは、CSSやJavaScriptのトランスパイルやバンドルをよりシンプルかつ高速に行うことを目的としています。\n\n- **app/assets** ディレクトリの役割は変わりませんが、内部的な処理がPropshaftに置き換わることで、ビルドのパフォーマンスが向上します。\n\n### 3. ImportmapとNode.js依存の削減\n\nRails 7では、Importmapを使用してJavaScriptの依存関係を管理する方法が標準となりました。これにより、開発者は`npm install`を使わずに、ブラウザが直接ESモジュールをロードできるようになります。\n\n- **config/importmap.rb**: このファイルは、各JavaScriptモジュールをURLにマッピングするために使用されます。これにより、フロントエンドの依存関係をNode.jsなしで管理できます。\n\nこれらの変更点は、Railsの最新のトレンドを反映しており、特にフロントエンド開発におけるアプローチに大きな影響を与えています。このドキュメントにこれらのトピックを追加することで、Railsの進化を捉えた、より現代的で実践的な内容になります。","src/content/docs/railsガイド/02_基本/01_フォルダ構成.mdx","8dfb32fc5e2acf46","railsガイド/02_基本/02_mvcとは",{"id":1172,"data":1174,"body":1179,"filePath":1180,"digest":1181,"deferredRender":16},{"title":1175,"editUrl":16,"head":1176,"template":18,"sidebar":1177,"pagefind":16,"draft":20},"MVCとは",[],{"hidden":20,"attrs":1178},{},"### 🎨 MVC（Model-View-Controller）とは？\n\nMVCは、Model（モデル）、View（ビュー）、Controller（コントローラー）の頭文字をとった、Webアプリケーション開発で最も広く使われている設計パターンのひとつです。このパターンは、アプリケーションのコードを3つの独立した役割に分けて整理することで、開発をスムーズで効率的にします。まるで、プロの料理チームが役割分担をするようなものです！👨‍🍳\n\n### なぜMVCがすごいのか？\n\nMVCを使う最大のメリットは、アプリケーションの異なる部分を「分離」できることです。これにより、以下のような素晴らしい効果が生まれます。\n\n- **壊れにくい！💪**: 各コンポーネントが独立しているので、例えばデザイン（View）を変更しても、データの扱い（Model）には影響しません。\n- **チーム開発が楽に！🤝**: デザイナーはViewに、エンジニアはModelやControllerに集中できるので、みんなが同時に作業を進められます。\n- **再利用性が高い！♻️**: 各コンポーネントが特定の役割に特化しているため、他のプロジェクトでも使い回しやすくなります。\n\n### MVCの各コンポーネントの役割\n\nMVCは、まるで「ウェブアプリケーションという名のレストラン」のチームです。\n\n#### Model（モデル） 👩‍🍳\n\n- **役割**: アプリの「データ」と「頭脳」です。データベースとやり取りし、データの読み書き、検証、関連付けといった、料理の「材料」を管理します。\n- **例**: ユーザー情報、商品リスト、ブログ記事など、アプリケーションの「実体」となるものです。\n\n#### View（ビュー） 🖼️\n\n- **役割**: ユーザーに提供される「見た目」を担当します。モデルから受け取ったデータを、HTMLやCSSといった美しい「お皿」に盛り付けて表示します。\n- **例**: ウェブページのレイアウト、フォーム、ボタンなど、ユーザーが目にするすべての要素です。\n\n#### Controller（コントローラー） 🗣️\n\n- **役割**: ユーザーからの「注文」を受け取り、モデルとビューをつなぐ「ウェイター」です。ユーザーのリクエストを分析し、どのデータを準備し（モデルに指示）、どのように提供するか（ビューに指示）を調整します。\n- **例**: 「このURLにアクセスされたら、ユーザー一覧を準備して表示して！」といった司令塔の役割を果たします。\n\n### 動作の流れ（レストランの注文プロセス風）\n\nMVCがどのように連携しているかを、注文プロセスで見てみましょう。\n\n1. **ユーザーからのリクエスト**: お客様が「ハンバーガーください！」と注文します。\n2. **コントローラーが受信**: ウェイター（Controller）が注文を受け取ります。\n3. **コントローラーがモデルに指示**: ウェイターは、ハンバーガーの材料（データ）を準備するようにシェフ（Model）に伝えます。\n4. **モデルがデータを処理**: シェフは、レシピ（ロジック）に従って材料を調理します。\n5. **モデルがデータを返す**: 調理が終わり、シェフは完成したハンバーガーをウェイターに渡します。\n6. **コントローラーがビューに指示**: ウェイターは、ハンバーガーを素敵なお皿（View）に盛り付けるように指示します。\n7. **ビューがレンダリング**: 盛り付けが完了し、お客様の元へ届けられます！\n\n### コード スニペット\n\n```mermaid\ngraph TD\n    A[ユーザー] --> |リクエストを送信| B(Controller);\n    B --> |モデルに指示| C(Model);\n    C --> |データ取得・処理| B;\n    B --> |ビューにデータを渡す| D(View);\n    D --> |HTMLをレンダリング| A;\n```","src/content/docs/railsガイド/02_基本/02_MVCとは.mdx","4c591a11e9799065","railsガイド/02_基本/03_modelについて",{"id":1182,"data":1184,"body":1189,"filePath":1190,"digest":1191,"deferredRender":16},{"title":1185,"editUrl":16,"head":1186,"template":18,"sidebar":1187,"pagefind":16,"draft":20},"Modelとは",[],{"hidden":20,"attrs":1188},{},"## 💡 RailsにおけるModelとは？\n\nRailsにおけるModelは、Webアプリケーションの「データ」と「頭脳」を司る重要な存在です。データベースのテーブルと直接対話するだけでなく、アプリケーションのビジネスロジックを管理する役割を担っています。\n\n### Active Recordの魔法 ✨\n\nRailsのModelの心臓部にあるのが、Active Recordという強力なORM（オブジェクト関係マッピング）ライブラリです。この「魔法のツール」を使うことで、私たちはSQL文を一切書くことなく、Rubyのオブジェクトとしてデータベースを操作できます。\n\n例えば、`users`というデータベーステーブルがあれば、Railsは自動的に`User`というModelクラスを紐づけてくれます。\n\n```ruby\n# Userクラスのインスタンスは\n# データベースのusersテーブルの1つの行に対応します\nuser = User.new(name: \"Alice\")\nuser.save # 魔法！データベースに新しい行が追加される\n```\n\n### Modelの3つの超能力 🦸\n\nModelは単なるデータ置き場ではありません。データを扱う上で欠かせない3つの強力な機能を持っています。\n\n#### 1. バリデーション（Validation）✅\n\nModelは、データをデータベースに保存する前に、それが「有効なデータか？」を厳しくチェックします。これにより、誤ったデータが入り込むのを防ぎ、データの品質を保ちます。\n\n```ruby\nclass User \u003C ApplicationRecord\n  # 名前が空でないか、メールアドレスが一意であるかチェック！\n  validates :name, presence: true\n  validates :email, uniqueness: true\nend\n```\n\n#### 2. 関連付け（Association）🔗\n\n複数のModelが互いにどのように関係しているかを定義します。これにより、複雑なデータ間のつながりを簡単に扱えるようになります。\n\n| 関連付け | 意味合い | 具体例 |\n| --- | --- | --- |\n| `has_many` | 1対多 | ユーザーは多くの投稿を持つ |\n| `belongs_to` | 多対1 | 投稿は1人のユーザーに属する |\n| `has_one` | 1対1 | ユーザーは1つのプロフィールを持つ |\n| `has_and_belongs_to_many` | 多対多 | 投稿は多くのタグを持ち、タグは多くの投稿を持つ |\n\n関連付けを定義しておけば、`user.posts`のように直感的なコードで関連データを取得できます。\n\n#### 3. コールバック（Callback）🔄\n\nデータのライフサイクル（作成、更新、削除など）の特定のタイミングで、自動的に実行される処理を定義します。\n\n```ruby\nclass Post \u003C ApplicationRecord\n  # 投稿が保存される前に実行される\n  before_save :set_default_title\n\n  private\n\n  def set_default_title\n    # タイトルが空なら「Untitled」を設定\n    self.title = \"Untitled\" if self.title.blank?\n  end\nend\n```\n\n### 📂 Modelファイルの場所\n\nModelのファイルは、`app/models` ディレクトリに配置されます。慣習として、ファイル名はクラス名を単数形（例：`User`クラスなら`user.rb`）にします。\n\n## まとめ\n\nRailsのModelは、単にデータベースとやり取りするだけでなく、データの検証、関連性の管理、そして自動実行されるロジックを担う、まさにアプリケーションの「心臓部」です。Active Recordという強力なツールのおかげで、私たちは複雑なデータベース操作から解放され、より本質的なアプリケーションの機能開発に集中できるのです。","src/content/docs/railsガイド/02_基本/03_Modelについて.mdx","b9826fab03936619","railsガイド/02_基本/04_controllerについて",{"id":1192,"data":1194,"body":1199,"filePath":1200,"digest":1201,"deferredRender":16},{"title":1195,"editUrl":16,"head":1196,"template":18,"sidebar":1197,"pagefind":16,"draft":20},"Controllerとは",[],{"hidden":20,"attrs":1198},{},"## 👨‍✈️ RailsにおけるControllerとは？\n\nRailsにおけるControllerは、ウェブアプリケーションの「司令塔」です。ユーザーからのリクエストを最初に受け取り、アプリケーションのModelとViewに適切な指示を出す役割を担います。\n\n### Controllerの役割と流れ 🗺️\n\nControllerの仕事は、ユーザーの「行動」を理解し、次の「反応」を決定することです。\n\n1. **リクエストの受信**: ユーザーがブラウザで特定のURLにアクセスすると、まずそのリクエストをControllerが受け取ります。\n2. **Modelへの指示**: Controllerは、リクエストの内容（例：ユーザー一覧を表示、新しい投稿を作成）に応じて、Modelにデータの取得や保存を指示します。\n3. **Viewへの命令**: Modelから受け取ったデータを使って、どのView（HTMLテンプレート）をユーザーに表示するかを決定します。\n\n### Controllerファイルの構成 📁\n\nControllerのファイルは、`app/controllers`ディレクトリに配置されます。慣例として、クラス名は扱うリソース（例：ユーザー）の複数形に「Controller」を付けたものになります。\n\n- **例**: ユーザーを管理するコントローラーは `app/controllers/users_controller.rb` となります。\n\n### Controllerのアクション 🎬\n\nControllerクラス内にある各メソッドをアクションと呼びます。各アクションは、特定のユーザーリクエストに対応する独立した処理単位です。\n\n#### ユーザー管理の例 (UsersController)\n\n| アクション | 対応するリクエスト | 役割 |\n| --- | --- | --- |\n| `index` | GET /users | 全ユーザーを一覧表示します。 |\n| `show` | GET /users/:id | 特定のユーザーの詳細を表示します。 |\n| `new` | GET /users/new | 新しいユーザー作成フォームを表示します。 |\n| `create` | POST /users | フォーム送信を受け、新しいユーザーを保存します。 |\n| `edit` | GET /users/:id/edit | 既存ユーザーの編集フォームを表示します。 |\n| `update` | PATCH /users/:id | ユーザーの情報を更新します。 |\n| `destroy` | DELETE /users/:id | ユーザーを削除します。 |\n\n### paramsとStrong Parameters\n\n- **params**: Controllerの各アクションでは、`params`というハッシュを通じて、URLやフォームから送信されたデータにアクセスできます。\n- **Strong Parameters**: ユーザーからの入力を安全に受け取るためのセキュリティ機能です。これにより、悪意のあるデータがデータベースに保存されるのを防ぎます。`user_params` のように、許可された属性のみを明示的に指定します。\n\n## まとめ\n\nRailsのControllerは、ユーザーのリクエストとアプリケーションの内部ロジックを仲介する重要な役割を果たします。これにより、データ操作（Model）と表示（View）の責任が明確に分離され、アプリケーションが整理され、理解しやすくなります。この役割分担こそが、Railsの強力な開発効率を支える基盤なのです。","src/content/docs/railsガイド/02_基本/04_Controllerについて.mdx","c64c7d299492cd1a","railsガイド/02_基本/05_viewについて",{"id":1202,"data":1204,"body":1209,"filePath":1210,"digest":1211,"deferredRender":16},{"title":1205,"editUrl":16,"head":1206,"template":18,"sidebar":1207,"pagefind":16,"draft":20},"Viewとは",[],{"hidden":20,"attrs":1208},{},"## 🖼️ RailsにおけるViewとは？\n\nRailsにおけるViewは、アプリケーションの「顔」です。ユーザーがブラウザで見るウェブページのすべて、つまりHTML、CSS、JavaScriptを生成する役割を担っています。Controllerから渡されたデータを、美しく整理された形で表示することに特化したコンポーネントです。\n\n### Viewの役割と特徴\n\nViewの主な仕事は、ユーザーが理解しやすいようにデータを「視覚化」することです。決してビジネスロジックやデータベース操作は行わず、表示だけに専念します。これは、MVCの原則である関心の分離を徹底するためです。\n\n### テンプレートエンジンの魔法 ✨\n\nRailsはデフォルトでERB (Embedded RuBy) というテンプレートエンジンを使います。これは、HTMLの中にRubyのコードを埋め込むことで、静的なHTMLを動的に生成する魔法のような仕組みです。ERBファイルは、`.html.erb`という拡張子を持ちます。\n\n- **`\u003C%= ... %>`**: このタグは、Rubyコードの実行結果をHTMLに出力します。例えば、`\u003C%= @user.name %>`と書けば、`@user`という変数の`name`属性が表示されます。\n- **`\u003C% ... %>`**: このタグは、Rubyコードを実行するだけで、結果は出力しません。`if`文や`each`ループなど、制御構造に使われます。\n\n### 📂 Viewファイルの整理術\n\nViewファイルは、対応するControllerの名前にちなんだディレクトリ内に配置されます。これにより、どのControllerのアクションがどのViewを使っているか一目で分かります。\n\n- **例**: `UsersController`の`index`アクションに対応するViewファイルは、`app/views/users/index.html.erb`となります。\n\n### コードの再利用で効率アップ 🚀\n\nRailsのViewには、同じコードを何度も書く手間を省くための強力な機能が備わっています。\n\n- **レイアウト (Layout)**:\n  - アプリケーション全体の共通デザイン（ヘッダー、フッター、ナビゲーションバーなど）を定義するテンプレートです。すべてのページがこのレイアウトを共有することで、見た目の一貫性が保たれます。\n  - `app/views/layouts/application.html.erb` がデフォルトのレイアウトファイルです。\n  - `yield`という特別なキーワードが、各ページのコンテンツを挿入する「穴」の役割を果たします。\n\n- **部分テンプレート (Partial)**:\n  - ウェブページの一部として何度も再利用されるUIコンポーネント（例：ユーザーカード、投稿フォーム）を、独立したファイルに切り出します。ファイル名の先頭には`_`（アンダースコア）を付けます（例：`_user.html.erb`）。\n  - `\u003C%= render 'user' %>`のように、`render`メソッドで簡単に呼び出すことができます。\n\n## まとめ\n\nRailsのViewは、単なるHTMLファイルではありません。ERB、レイアウト、そして部分テンプレートといった機能を通じて、動的で、効率的で、再利用性の高いユーザーインターフェースを構築する強力なツールです。MVCの「顔」として、アプリケーションのデータをユーザーに分かりやすく届ける重要な役割を担っています。","src/content/docs/railsガイド/02_基本/05_Viewについて.mdx","a400c2805e204601","railsガイド/02_基本/06_コマンド集",{"id":1212,"data":1214,"body":1219,"filePath":1220,"digest":1221,"deferredRender":16},{"title":1215,"editUrl":16,"head":1216,"template":18,"sidebar":1217,"pagefind":16,"draft":20},"Rails ジェネレーターコマンド",[],{"hidden":20,"attrs":1218},{},"## 🛠️ Railsの魔法の杖：ジェネレーターコマンド\n\n`rails generate`（省略形: `rails g`）は、Rails開発のスピードを劇的に加速させる魔法のコマンドです。アプリケーションの部品（Model、Controllerなど）を自動で生成してくれるので、手作業を減らし、開発に集中できます。\n\n### 🚀 主要なジェネレーターコマンド\n\n| コマンド | 役割 | 例 |\n| --- | --- | --- |\n| `rails g model` | データベースのテーブルに対応するモデルとマイグレーションファイルを生成。 | `rails g model Product name:string price:integer` |\n| `rails g controller` | コントローラーと、対応するビューフォルダを生成。 | `rails g controller Pages home about` |\n| `rails g scaffold` | CRUD（作成・読み取り・更新・削除）機能を一気に生成！ Model, Controller, View, ルーティングまでまとめて作ります。 | `rails g scaffold Post title:string content:text` |\n| `rails g migration` | データベースのスキーマを変更するためのマイグレーションファイルだけを生成。 | `rails g migration AddCategoryToPosts category:string` |\n| `rails g resource` | ビューを生成しないScaffold。API開発に最適です。 | `rails g resource User name:string` |\n\n### 🗄️ データベース関連コマンド\n\nデータベース操作も、これらのコマンドを使えば簡単です。\n\n| コマンド | 役割 |\n| --- | --- |\n| `rails db:migrate` | 未実行のマイグレーションファイルをすべて実行し、データベースを最新の状態に更新します。 |\n| `rails db:rollback` | 最後に実行したマイグレーションを取り消し、データベースの状態を元に戻します。 |\n| `rails db:seed` | `db/seeds.rb` に書かれた初期データをデータベースに投入します。テストデータを用意する際に便利です。 |\n| `rails db:drop` | データベースを完全に削除します。⚠️慎重に使いましょう！ |\n| `rails db:create` | データベースを作成します。 |\n\n### 💻 開発・サーバー関連コマンド\n\n日々の開発で頻繁に使う、便利なコマンドです。\n\n| コマンド | 役割 |\n| --- | --- |\n| `rails s` | ローカル開発用のウェブサーバーを起動します。`s`は`server`の省略形です。 |\n| `rails c` | アプリケーションのコンテキストで対話型コンソールを起動。データの確認やデバッグに役立ちます。`c`は`console`の省略形です。 |\n| `rails routes` | アプリケーションのすべてのルーティング情報（URLと対応するコントローラー・アクション）を一覧で表示します。 |\n| `rails t` | アプリケーションのテストを実行します。`t`は`test`の省略形です。 |\n| `rails about` | Railsのバージョンや環境設定など、現在のプロジェクト情報を表示します。 |\n\nこれらのコマンドを使いこなすことで、あなたのRails開発はさらに効率的で楽しいものになります。","src/content/docs/railsガイド/02_基本/06_コマンド集.mdx","1f5b9a1e75611020","railsガイド/02_基本/07_頻出gem",{"id":1222,"data":1224,"body":1229,"filePath":1230,"digest":1231,"deferredRender":16},{"title":1225,"editUrl":16,"head":1226,"template":18,"sidebar":1227,"pagefind":16,"draft":20},"Rails開発で役立つ！人気のGemガイド",[],{"hidden":20,"attrs":1228},{},"💎 Rails開発で役立つ！人気のGemガイド\nGemは、RubyGems.orgに公開されているRubyのライブラリのことで、Rails開発の生産性を飛躍的に高めてくれます。ここでは、GitHubのスター数（2025年8月時点）を参考に、特に多くの開発者に支持されている人気のGemを紹介します。\n\n1. 認証\n認証は、ほとんどのWebアプリケーションで必須の機能です。\n\nDevise (約25k ⭐)\nRailsの認証Gemの決定版です。ユーザー登録、ログイン、パスワードリセット、アカウント確認など、認証に関するあらゆる機能を数分で実装できます。シンプルなコマンドで必要なファイルが自動生成されるため、初心者から上級者まで幅広く使われています。\n\nOmniAuth (約8k ⭐)\nGoogle、GitHub、Facebookといった外部サービスを使った認証を簡単に導入するためのGemです。Deviseと組み合わせることで、ソーシャルログイン機能をスムーズに実装できます。\n\n2. デバッグと開発効率化\n開発プロセスを快適にするためのGemです。\n\nPry (約6k ⭐)\nプログラムの実行を任意の場所で一時停止し、その時点での変数やオブジェクトの状態を対話的に調べられる多機能なデバッガーです。binding.pryをコードに書くだけで、開発中の問題解決が格段に早くなります。\n\nBullet (約6.5k ⭐)\nWebアプリケーションのパフォーマンスを低下させる最大の原因の一つであるN+1クエリ問題を自動的に検出して警告してくれます。開発中にこのGemを導入するだけで、パフォーマンスボトルネックを早期に発見できます。\n\nRails-ERD (約3.5k ⭐)\nModel間の関連付けを読み取り、データベースのER図を自動生成してくれます。複雑なアプリケーションの全体像を視覚的に理解するのに非常に役立ちます。\n\n3. テスト\n堅牢なアプリケーション開発にはテストが不可欠です。\n\nRSpec-Rails (約5k ⭐)\nRailsのテストを簡潔で読みやすい構文で書けるテストフレームワークです。Railsのデフォルト（Minitest）よりも表現力が高いため、多くのプロジェクトで採用されています。\n\nFactory Bot Rails (約3.2k ⭐)\nテストデータを簡単に、かつ再利用可能な形で生成するためのGemです。毎回手動でテストデータを作成する手間を省き、テストコードをよりクリーンに保つことができます。\n\n4. APIとデータ表示\nAPI開発やデータ表示を効率化するためのGemです。\n\nKaminari (約8.3k ⭐)\nユーザー数の多いWebサイトやECサイトなどで必須となる、**ページネーション（ページ分割）**を簡単に実装できます。直感的なAPIで、大規模なデータセットも扱いやすくなります。\n\nActiveModel::Serializers (約5k ⭐)\nAPI開発において、データベースから取得したデータをJSON形式でクライアントに返す際に利用されます。レスポンスの整形や、関連データの含める・含めないといった設定を効率的に行えます。\n\n5. コード品質とセキュリティ\nチーム開発において、コードの健全性と安全性を保つためのGemです。\n\nRuboCop (約14k ⭐)\nRubyのコードスタイルを自動チェックし、統一されたコーディング規約を強制してくれます。チーム開発におけるコードレビューの時間を大幅に削減し、品質を保ちます。\n\nBundler-audit (約2.5k ⭐)\nアプリケーションが使用しているGemに既知のセキュリティ脆弱性がないかをチェックします。定期的な実行を推奨することで、アプリケーションの安全性を高めることができます。\n\n6. データ処理とバックグラウンドジョブ\nSidekiq (約13k ⭐)\nバックグラウンドで重い処理（メール送信、画像処理など）を非同期的に実行するためのGemです。ユーザーはウェブサイトの応答を待つことなく、すぐに次の操作に移れるようになります。SidekiqはRedisを使用し、信頼性の高い非同期処理を提供します。\n\n7. ファイルアップロード\nActive Storage\nRails 5.2以降、フレームワークに組み込まれたファイルアップロード機能です。画像、動画、ドキュメントなどをAmazon S3、Google Cloud Storage、またはローカルディスクに簡単にアップロード、管理できます。これにより、外部のGemに依存することなく、ファイルアップロード機能を実装できます。\n\nCarrierWave (約8.7k ⭐)\nActive Storageが登場する前から広く使われている、多機能なファイルアップロードGemです。画像のリサイズやファイルタイプの検証など、多くのカスタマイズオプションを提供します。\n\n8. 認証と認可\nPundit (約8k ⭐)\n**認可（Authorization）に特化したGemです。「誰が何ができるか」**を管理するロジックをシンプルに記述できます。例えば、「管理者は投稿を削除できるが、一般ユーザーは自分の投稿しか削除できない」といったルールを、クリーンなコードで実装できます。Deviseなどの認証Gemと組み合わせて使われることが多いです。\n\n9. データベース管理\nFaker (約11k ⭐)\nテストや開発環境で、本物に近いダミーデータを簡単に生成するためのGemです。ユーザー名、住所、メールアドレスなど、様々な種類のデータを自動で生成できるため、テストデータの準備が効率化します。\n\nこれらのトピックを追加することで、ドキュメントはより実践的で、開発者が直面する様々な課題に対応できる、包括的なガイドになります。\n\nこれで、Rails開発における主要なGemの解説は完了です。さらに深掘りしたいトピックはありますか？","src/content/docs/railsガイド/02_基本/07_頻出gem.mdx","3f05d0906b34d19f","railsガイド/05_学び記事/07_orm",{"id":1232,"data":1234,"body":1238,"filePath":1239,"digest":1240,"deferredRender":16},{"title":1147,"editUrl":16,"head":1235,"template":18,"sidebar":1236,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1237},{},"RailsはActiveRecordというORMを使用して、データベース操作を簡素化します。\n\n## モデルの定義\n\n```ruby\nclass Book \u003C ApplicationRecord\n  validates :title, presence: true\n  validates :author, presence: true\nend\n```\n\n- **`ApplicationRecord`**: すべてのモデルの基底クラス\n- **`validates`**: データのバリデーションを定義","src/content/docs/railsガイド/05_学び記事/07_orm.mdx","dab1582706a46c4d","railsガイド/05_学び記事/08_testing",{"id":1241,"data":1243,"body":1248,"filePath":1249,"digest":1250,"deferredRender":16},{"title":1244,"editUrl":16,"head":1245,"template":18,"sidebar":1246,"pagefind":16,"draft":20},"Railsのテスト",[],{"hidden":20,"attrs":1247},{},"RailsはRSpecを使用して、テストを自動化します。\n\n## RSpecのインストール\n\n```bash\ngem install rspec\n```\n\n## テストの作成\n\n```ruby\nrequire 'rails_helper'\n\nRSpec.describe Book, type: :model do\n  it 'is valid with valid attributes' do\n    book = Book.new(title: 'Sample Book', author: 'Author Name')\n    expect(book).to be_valid\n  end\nend\n```\n\n- **`RSpec.describe`**: テスト対象を指定\n- **`expect`**: 期待する結果を定義","src/content/docs/railsガイド/05_学び記事/08_testing.mdx","d8263578bd780b31","railsガイド/05_学び記事/setup",{"id":1251,"data":1253,"body":1258,"filePath":1259,"digest":1260,"deferredRender":16},{"title":1254,"editUrl":16,"head":1255,"template":18,"sidebar":1256,"pagefind":16,"draft":20},"Railsの環境構築",[],{"label":427,"hidden":20,"attrs":1257},{},"# Railsの環境構築\n\nRailsをインストールするには、以下の手順を実行します。\n\n## インストール\n\n```bash\ngem install rails\n```\n\nこのコマンドを実行することで、Railsがインストールされます。\n\n# Railsの基本構文\n\nRailsの基本的な構文を以下に示します。\n\n## MVCアーキテクチャ\n\nRailsは、MVC（Model-View-Controller）アーキテクチャに基づいて設計されています。\n\n- **モデル（Model）**: データベースとのやり取りを管理します。\n- **ビュー（View）**: ユーザーに表示されるUIを管理します。\n- **コントローラ（Controller）**: リクエストを処理し、適切なビューを返します。\n\n## ルーティング\n\nRailsでは、ルーティングを使用して、URLとコントローラのアクションをマッピングします。\n\n```ruby\n# config/routes.rb\nRails.application.routes.draw do\n  resources :articles\nend\n```\n\n## ActiveRecord\n\nActiveRecordは、RailsのORM（Object-Relational Mapping）ライブラリで、データベース操作を簡単に行えます。\n\n```ruby\nclass Article \u003C ApplicationRecord\nend\n\n# データの作成\narticle = Article.new(title: \"Hello Rails\")\narticle.save\n```\n\n## ビュー\n\nビューは、HTMLテンプレートを使用して、ユーザーに表示されるUIを生成します。\n\n```erb\n\u003C!-- app/views/articles/index.html.erb -->\n\u003Ch1>Articles\u003C/h1>\n\u003C% @articles.each do |article| %>\n  \u003Ch2>\u003C%= article.title %>\u003C/h2>\n\u003C% end %>\n```\n\n## コントローラ\n\nコントローラは、リクエストを処理し、適切なビューを返します。\n\n```ruby\nclass ArticlesController \u003C ApplicationController\n  def index\n    @articles = Article.all\n  end\nend\n```\n\n# セキュリティ対策\n\nRailsアプリケーションのセキュリティ対策を以下に示します。\n\n## CSRF対策\n\nRailsは、デフォルトでCSRF（Cross-Site Request Forgery）対策を提供しています。\n\n```ruby\n# app/controllers/application_controller.rb\nclass ApplicationController \u003C ActionController::Base\n  protect_from_forgery with: :exception\nend\n```\n\n## セッション管理\n\nセッションを安全に管理するために、セッションストアを設定します。\n\n```ruby\n# config/initializers/session_store.rb\nRails.application.config.session_store :cookie_store, key: '_my_app_session', secure: Rails.env.production?\n```\n\n# セキュリティ対策の詳細\n\nRailsアプリケーションのセキュリティ対策をさらに強化する方法を以下に示します。\n\n## SQLインジェクション対策\n\nRailsは、デフォルトでSQLインジェクションを防ぐための機能を提供していますが、さらに安全性を高めるためのベストプラクティスを紹介します。\n\n```ruby\n# SQLクエリを直接書かずに、ActiveRecordを使用する\nUser.where(\"name = ?\", params[:name])\n```\n\n## XSS対策\n\nRailsは、デフォルトでXSS（クロスサイトスクリプティング）攻撃を防ぐためのエスケープ機能を提供しています。\n\n```erb\n\u003C%= h @user.name %>\n```\n\n# テストの自動化\n\nRailsアプリケーションのテスト自動化方法を以下に示します。\n\n## RSpecを使用したテスト\n\nRSpecを使用して、Railsアプリケーションのテストを自動化します。\n\n### インストール\n\n```bash\ngem install rspec-rails\n```\n\n### テストの実装\n\n```ruby\n# spec/models/article_spec.rb\nrequire 'rails_helper'\n\nRSpec.describe Article, type: :model do\n  it 'is valid with valid attributes' do\n    article = Article.new(title: 'Hello Rails')\n    expect(article).to be_valid\n  end\nend\n```\n\n# テストの自動化の詳細\n\nRailsアプリケーションのテスト自動化をさらに強化する方法を以下に示します。\n\n## FactoryBotを使用したテストデータの生成\n\nFactoryBotを使用して、テストデータを効率的に生成します。\n\n```ruby\n# spec/factories/users.rb\nFactoryBot.define do\n  factory :user do\n    name { \"John Doe\" }\n    email { \"john.doe@example.com\" }\n  end\nend\n```\n\n# デプロイメントのベストプラクティス\n\nRailsアプリケーションのデプロイメントにおけるベストプラクティスを以下に示します。\n\n## Herokuを使用したデプロイメント\n\nHerokuを使用して、Railsアプリケーションをデプロイします。\n\n### デプロイ\n\n```bash\ngit push heroku main\n```\n\n- **`Heroku`**: Railsアプリケーションを簡単にデプロイできるクラウドプラットフォームです。\n\n# デプロイメントのベストプラクティスの詳細\n\nRailsアプリケーションのデプロイメントにおけるベストプラクティスをさらに詳しく解説します。\n\n## Dockerを使用したコンテナ化\n\nDockerを使用して、Railsアプリケーションをコンテナ化します。\n\n### Dockerfileの例\n\n```dockerfile\nFROM ruby:2.7\nWORKDIR /app\nCOPY . .\nRUN bundle install\nCMD [\"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n```\n\n- **`Docker`**: アプリケーションをコンテナ化することで、環境の一貫性を保ち、デプロイメントを簡素化します。","src/content/docs/railsガイド/05_学び記事/setup.mdx","eab7f3c257e7ffcf","railsガイド/05_学び記事/実践で得た教訓",{"id":1261,"data":1263,"body":1267,"filePath":1268,"digest":1269,"deferredRender":16},{"title":475,"editUrl":16,"head":1264,"template":18,"sidebar":1265,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1266},{},"Railsの実践で得た教訓を以下に示します。\n\n## よくある疑問\n\n- **MVCアーキテクチャ**: MVCアーキテクチャを理解することで、コードの構造を整理しやすくなります。\n- **ActiveRecordの活用**: ActiveRecordを活用することで、データベース操作を簡潔に記述できます。","src/content/docs/railsガイド/05_学び記事/実践で得た教訓.mdx","4e913537800fa4d1","flutterガイド/01_はじめに/01_flutterの理由/01_why_flutter",{"id":1270,"data":1272,"body":1277,"filePath":1278,"digest":1279,"deferredRender":16},{"title":1273,"editUrl":16,"head":1274,"template":18,"sidebar":1275,"pagefind":16,"draft":20},"なぜFlutterか？",[],{"label":1273,"hidden":20,"attrs":1276},{},"# なぜFlutterか？\n\nFlutterは、クロスプラットフォーム開発を可能にする強力なフレームワークです。以下に、Flutterの主な利点を詳しく説明します。\n\n## クロスプラットフォーム開発\n\nFlutterを使用することで、単一のコードベースからiOSとAndroidの両方のアプリを開発できます。これにより、開発時間とコストを大幅に削減できます。\n\n## 高速なパフォーマンス\n\nFlutterは、ネイティブコードにコンパイルされるため、高速なパフォーマンスを実現します。特に、スムーズなアニメーションや複雑なUIを実装する際に、その性能が発揮されます。\n\n## 豊富なウィジェット\n\nFlutterは、豊富なウィジェットを提供しており、これを利用することで美しいUIを簡単に構築できます。Material DesignやCupertinoデザインに対応しており、プラットフォームに応じたUIを実現できます。\n\n## ホットリロード\n\n開発中にコードを変更すると、アプリを再起動せずに即座に変更を反映できるホットリロード機能を備えています。これにより、開発の効率が大幅に向上します。\n\n---\n\nFlutter SDKは、**Flutterアプリケーションを開発・実行するために必要なツールセット一式**です。\n\nFlutterは、Dart言語で書かれたコードを、iOSやAndroidが理解できるネイティブコードに変換したり、UIを描画したりする仕組みを持っています。SDKには、そのための**コンパイラ**や**フレームワークのライブラリ**、そして開発を助けるための様々な**コマンドラインツール**が含まれています。\n\nSDKをインストールすることで、ローカルPCがFlutter開発環境として機能するようになります。\n\n---\n\n### `bin`ディレクトリの中身について\n\n`bin`ディレクトリは「Binary」の略で、主に**実行可能なコマンドラインツール**が格納されています。\n\n| ファイル/ディレクトリ | 役割 |\n| --- | --- |\n| `flutter` | **最も重要なコマンドラインツール**です。`flutter run`、`flutter build`、`flutter doctor`など、Flutter開発で使うほとんどのコマンドは、この実行ファイルを介して実行されます。 |\n| `dart` | Dart言語のコンパイラやランタイムを操作するためのツールです。`flutter`コマンドの内部でも使われますが、Dartのプロジェクトを個別に実行する際にも使用されます。 |\n| `cache` | DartとFlutterのSDKがダウンロードした、**依存関係やツールの中間ファイル**が格納されます。開発中に自動的に管理されるもので、通常は直接触る必要はありません。 |\n\n---\n\n### `bin`以外の主要なディレクトリ構成\n\n`bin`以外にも、SDKには重要なディレクトリがいくつかあります。\n\n- **`packages`**: Flutterフレームワークそのものが含まれています。UIを構築するための`material.dart`や`cupertino.dart`といった主要なライブラリがここにあります。\n- **`dev/tools`**: 開発者向けのユーティリティツールが格納されています。\n- **`flutter_tools`**: FlutterのCLI（`flutter`コマンド）を実装しているDartパッケージです。\n\nこれらのファイル群が連携して、開発者が書いたDartコードを最終的なアプリに変換する役割を担っています。\n\n### flutterの階層構造\n\n---\n\n```dart\nmy_flutter_app/\n├── android/\n├── ios/\n├── lib/\n├── linux/\n├── macos/\n├── web/\n├── windows/\n└── pubspec.yaml\n```\n\n- **ネイティブ機能の利用**:\n    - **カメラ、GPS、通知、NFC**などのハードウェア機能を使う際に、**権限の設定**が必要です。\n    - iOSの場合は`Info.plist`、Androidの場合は`AndroidManifest.xml`に、その機能を使うための権限を記述します。\n- **ネイティブのコード実装**:\n    - Flutterのパッケージが存在しない、または特定の機能だけをネイティブコードで実装したい場合、**Platform Channel**を介して、Java/Kotlin（Android）やSwift/Objective-C（iOS）のコードを書く必要があります。\n- **アプリのアイコン設定**:\n    - アプリのアイコンや起動時のスプラッシュスクリーン（Splash Screen）を設定する場合。\n- **外部ライブラリ（SDK）の導入**:\n    - **決済SDK**や**広告SDK**など、サードパーティのネイティブSDKを統合する場合。\n    - iOSの場合は`Podfile`、Androidの場合は`build.gradle`ファイルを編集して、依存関係を追加します。\n\n# SDKの構成\n\nFlutter SDKは、開発者が効率的にアプリを開発するためのツールセットを提供します。以下に、SDKの主要なディレクトリとその役割を詳しく説明します。\n\n## `bin`ディレクトリ\n\n`bin`ディレクトリには、Flutterのコマンドラインツールが含まれています。これにより、開発者は様々なコマンドを使用してプロジェクトを管理できます。\n\n- **`flutter`**: Flutterの主要なコマンドラインツールで、プロジェクトのビルドや実行、デバッグを行います。\n- **`dart`**: Dart言語のコンパイラやランタイムを操作するためのツールです。\n\n## `packages`ディレクトリ\n\nこのディレクトリには、Flutterフレームワークそのものが含まれています。UIを構築するための主要なライブラリがここにあります。\n\n- **`material.dart`**: Material Designに基づいたUIを構築するためのライブラリです。\n- **`cupertino.dart`**: iOSスタイルのUIを構築するためのライブラリです。\n\n## `flutter_tools`ディレクトリ\n\nFlutterのCLI（`flutter`コマンド）を実装しているDartパッケージです。これにより、開発者はコマンドラインからプロジェクトを管理できます。\n\n# 実践的なアドバイス\n\nFlutterを使用する際のベストプラクティスや、よくある問題の解決策を以下に示します。\n\n## ベストプラクティス\n\n- **状態管理**: Flutterでは、状態管理が重要です。`Provider`や`Riverpod`、`Bloc`などのパッケージを使用して、状態を効率的に管理しましょう。\n- **レスポンシブデザイン**: さまざまなデバイスサイズに対応するために、`MediaQuery`や`LayoutBuilder`を使用してレスポンシブなUIを構築します。\n- **コードの再利用**: ウィジェットを小さく分割し、再利用可能なコンポーネントとして設計することで、コードのメンテナンス性を向上させます。\n\n## よくある問題の解決策\n\n- **依存関係の競合**: `pubspec.yaml`で依存関係を管理する際に、バージョンの競合が発生することがあります。`flutter pub outdated`コマンドを使用して、依存関係のバージョンを確認し、適切に更新しましょう。\n- **パフォーマンスの最適化**: `Flutter DevTools`を使用して、アプリのパフォーマンスを分析し、ボトルネックを特定して最適化します。\n- **ビルドエラーの解決**: ビルドエラーが発生した場合は、エラーメッセージをよく読み、必要に応じて`flutter clean`コマンドを実行してキャッシュをクリアします。","src/content/docs/flutterガイド/01_はじめに/01_flutterの理由/01_why_flutter.mdx","486594358ce1db60","flutterガイド/01_はじめに/01_flutterの理由/02_flutter以外の比較",{"id":1280,"data":1282,"body":1287,"filePath":1288,"digest":1289,"deferredRender":16},{"title":1283,"editUrl":16,"head":1284,"template":18,"sidebar":1285,"pagefind":16,"draft":20},"FlutterとReact Nativeとの比較",[],{"label":1283,"hidden":20,"attrs":1286},{},"# FlutterとReact Nativeとの比較\n\n## FlutterとReact Nativeの決定的な違い 🤝\n提供された内容に加えて、両者の根本的な違いである**「UI描画方法」と「言語」**に焦点を当てて詳しく見ていきましょう。\n\n### UI描画の仕組み\n- **React Native**: JavaScriptのコードをネイティブコンポーネントに変換してUIを描画します。ボタンやテキストなどのコンポーネントは、iOSではUIButton、Androidではandroid.widget.Buttonといったネイティブの要素にマッピングされます。このアプローチは、ネイティブUIの見た目と挙動を完全に再現できる利点がありますが、ネイティブブリッジ（JavaScriptとネイティブコード間の通信）がボトルネックとなり、複雑なアニメーションではパフォーマンスが低下する可能性があります。\n\n- **Flutter**: UIを完全にゼロから描画します。Flutterは、Skiaという高性能な2Dグラフィックエンジンを使用して、画面上のすべてのピクセルを独自に描画します。これにより、OSのバージョンやデバイスに関係なく、すべてのプラットフォームで完全に同じUIを実現します。このアプローチは、ネイティブブリッジを必要としないため、非常に高速なパフォーマンスを実現します。\n\n### 使用言語とエコシステム\n- **React Native**: JavaScriptとTypeScriptを使用します。JavaScriptの広範なエコシステム（npm、Yarn）と膨大なライブラリを活用できます。Web開発者がモバイル開発に参入する際の学習コストが低いのが大きな魅力です。\n\n- **Flutter**: Dartという言語を使用します。Dartは、JavaScriptに似た構文を持ちながらも、静的型付けやasync/awaitのサポートが充実しているため、大規模なアプリケーション開発に適しています。エコシステムはpub.devという専用のパッケージ管理システムで管理されており、Flutter専用の高品質なパッケージが豊富に揃っています。\n\n## 実践的なアドバイスと新たな視点 🧐\n提供されたチェックリストに加えて、プロジェクトの成功を左右するさらに重要なポイントを付け加えます。\n\n### コミュニティと学習リソース\n- **React Native**: 長い歴史を持つため、ドキュメント、チュートリアル、Stack OverflowのQ&Aなど、学習リソースが非常に豊富です。問題解決のための情報を見つけやすいという利点があります。\n\n- **Flutter**: Googleが強力に支援しており、公式ドキュメントが非常に充実しています。また、活発なコミュニティと、Googleのエンジニアによる継続的なサポートが魅力です。新しいフレームワークであるため、最新の情報が公式ドキュメントで迅速に提供されます。\n\n### 開発体験 (Developer Experience)\n- **ホットリロード**: 両者ともにホットリロード機能を備えていますが、Flutterのホットリロードはより高速で安定していると評価されることが多いです。コードの変更が数秒以内に画面に反映されるため、UIの調整やデバッグが非常にスムーズに行えます。\n\n- **開発ツール**: FlutterにはFlutter DevToolsという強力なプロファイリングツールが標準で付属しています。これにより、パフォーマンスのボトルネックやメモリ使用量を視覚的に簡単に分析できます。\n\n## 最終的な結論 🎯\nどちらのフレームワークも素晴らしいですが、プロジェクトの目標に応じて最適な選択をすることが重要です。\n\n### React Nativeを選ぶべき場合:\n- チームがJavaScriptとReactの経験が豊富で、学習コストを最小限に抑えたい場合。\n- Webとモバイルの両方でコードを共有し、統一的な開発をしたい場合。\n- 既存のネイティブモジュールやライブラリを積極的に活用したい場合。\n\n### Flutterを選ぶべき場合:\n- iOSとAndroidで完全に統一された美しいUI/UXを、高いパフォーマンスで実現したい場合。\n- 複雑なアニメーションやゲーム、カスタムUIを多用するアプリを開発する場合。\n- 将来的にWebやデスクトップアプリにも展開することを視野に入れている場合。\n\n最終的な決定は、単に技術的な優位性だけでなく、チームのスキルセット、プロジェクトのスケジュール、そして長期的なメンテナンス計画を総合的に考慮して下すべきです。","src/content/docs/flutterガイド/01_はじめに/01_flutterの理由/02_flutter以外の比較.mdx","959790aa6cddc452","flutterガイド/01_はじめに/01_why_flutter/03_why_use_flutter",{"id":1290,"data":1292,"body":1297,"filePath":1298,"digest":1299,"deferredRender":16},{"title":1293,"editUrl":16,"head":1294,"template":18,"sidebar":1295,"pagefind":16,"draft":20},"なぜFlutterを使用するのか",[],{"hidden":20,"attrs":1296},{},"## Flutterを選ぶ主な理由 ✨\nFlutterは単なるクロスプラットフォームフレームワークではなく、開発体験とパフォーマンスの両面で独自の強みを持っています。\n\n### 1. 卓越した開発体験 🚀\nFlutterの最大の魅力の一つは、開発のスピードと効率性を飛躍的に高めるツールと機能です。\n\n- **ホットリロード**: コードを変更すると、アプリケーションを再起動せずに即座に変更が反映されます。これにより、UIの微調整やバグ修正を素早く繰り返すことができ、開発サイクルが劇的に短縮されます。\n\n- **豊富なウィジェット群**: FlutterはUIを構築するための豊富なウィジェットを標準で提供しています。これらのウィジェットは、カスタマイズ性が高く、プラットフォームごとのデザイン（Material DesignやCupertino）に簡単に適応させることができます。\n\n- **シンプルで強力な言語**: 使用言語であるDartは、シンプルで学習しやすい上に、静的型付けやasync/awaitといったモダンな言語機能を備えており、大規模なプロジェクトでもコードを管理しやすくなります。\n\n### 2. ネイティブに迫るパフォーマンス 💪\nFlutterは、JavaScriptブリッジを介さずにネイティブコードに直接コンパイルされます。\n\n- **ネイティブコードへのコンパイル**: Flutterは、DartコードをARMやx86などのネイティブコードにコンパイルします。これにより、JavaScriptを実行する中間層がないため、高いパフォーマンスとスムーズなアニメーションを実現できます。\n\n- **独自のUIレンダリング**: UIは、Skiaという高性能な2Dグラフィックエンジンを使って、完全にゼロから描画されます。これにより、OSのバージョンやデバイスに左右されることなく、どのプラットフォームでも一貫した美しいUIを提供できます。\n\n### 3. マルチプラットフォーム展開 🌐\nFlutterは、モバイルアプリ開発から始まりましたが、現在ではさらに広範なプラットフォームに対応しています。\n\n- **Web**: Flutter for Webにより、モバイルアプリと同じコードベースでWebアプリケーションも開発できます。\n\n- **デスクトップ**: macOS、Windows、Linuxといったデスクトップアプリケーションも、単一のコードで構築できます。\n\n- **組み込み**: 組み込み機器向けのUI開発にも利用が広がっています。\n\nこれらの特徴により、Flutterは開発者にとって非常に魅力的な選択肢となっており、一つのコードで複数のプラットフォームに対応する現代の開発トレンドに非常に適しています。","src/content/docs/flutterガイド/01_はじめに/01_why_flutter/03_why_use_flutter.mdx","16b280d40a60b6da","flutterガイド/01_はじめに/02_flutterの基本構文/syntax",{"id":1300,"data":1302,"body":1307,"filePath":1308,"digest":1309,"deferredRender":16},{"title":1303,"editUrl":16,"head":1304,"template":18,"sidebar":1305,"pagefind":16,"draft":20},"基本構文",[],{"label":1303,"hidden":20,"attrs":1306},{},"## 1. MyApp ウィジェットの詳細解説\nMyAppは、Flutterアプリの**「顔」**となる、最も基本的なウィジェットです。アプリ全体の骨組みとテーマを定義する重要な役割を担っています。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const MyHomePage(title: 'Flutter Demo Home Page'),\n    );\n  }\n}\n```\n\n- **runApp()**: アプリケーションを起動し、指定されたウィジェット（通常はMyApp）を画面に表示します。\n- **MaterialApp**: アプリのルートウィジェットとして使われます。titleやthemeといったアプリ全体の情報を設定し、マテリアルデザインのウィジェットを使えるようにします。\n- **home**: アプリの最初の画面を定義します。\n\n## 2. Scaffold ウィジェット\nScaffoldは、マテリアルデザインの基本的なレイアウト構造を提供するウィジェットです。\n\n```dart\nScaffold(\n  appBar: AppBar(\n    title: const Text('タイトル'),\n  ),\n  body: const Center(\n    child: Text('Hello, Flutter!'),\n  ),\n  floatingActionButton: FloatingActionButton(\n    onPressed: () {},\n    child: const Icon(Icons.add),\n  ),\n)\n```\n\n- **appBar**: アプリの上部に表示されるバーです。タイトルやアクションを配置できます。\n- **body**: メインコンテンツを配置する領域です。\n- **floatingActionButton**: 画面の右下に表示されるアクションボタンです。\n\n## 3. ColumnとRow ウィジェット\nColumnとRowは、ウィジェットを縦または横に並べるための最も基本的なレイアウトウィジェットです。\n\n```dart\nColumn(\n  mainAxisAlignment: MainAxisAlignment.center, // 垂直方向の中央揃え\n  children: const \u003CWidget>[\n    Text('First'),\n    Text('Second'),\n    Text('Third'),\n  ],\n)\n```\n\n- **Column**: ウィジェットを縦に並べます。\n- **Row**: ウィジェットを横に並べます。\n\nこれらのウィジェットを組み合わせることで、複雑なレイアウトを構築できます。\n\n## 実践的なアドバイスと教訓 💡\n\n### 状態管理は最初に決めておくべし 🧠\nプロジェクトを始める前に、状態管理の方法を決めておかないと、後で大変なことになります。\n\n- **小規模なアプリならProvider**から始めるのがおすすめです。学習コストが低く、シンプルに扱えます。\n- 大規模アプリやチーム開発では、RiverpodやBlocといった、より厳密な状態管理が可能なライブラリを検討すべきです。これらのライブラリは、コードの予測可能性とテスト容易性を高めてくれます。\n\n### StatelessWidgetとStatefulWidgetの使い分けを理解する 🤔\nFlutterのウィジェットは、状態を持つか持たないかで2種類に分けられます。\n\n- **StatelessWidget**: 状態を持たないウィジェットです。一度描画されたら、再描画されることはありません。ボタンやアイコンなど、変化しないUI要素に使います。\n- **StatefulWidget**: 状態を持つウィジェットです。ユーザーの操作などによって状態が変化し、再描画されます。テキスト入力フォームやチェックボックスなど、状態が変わるUI要素に使います。\n\n最初のうちはStatefulWidgetばかり使ってしまいがちですが、可能な限りStatelessWidgetを使うことで、アプリのパフォーマンスとメンテナンス性が向上します。\n\n### レスポンシブデザインの工夫 📐\nモバイルアプリは、様々な画面サイズで使われます。\n\n画面サイズに応じてレイアウトを調整するために、**MediaQueryやLayoutBuilder**を積極的に使いましょう。LayoutBuilderは、親ウィジェットが提供する制約（幅や高さ）に基づいてUIを構築できるため、特に柔軟なUIを組むのに便利です。\n\n### 依存関係の競合とpubコマンド 🐛\nパッケージを大量に追加すると、バージョンの競合が頻繁に起こります。\n\n- **flutter pub outdated**: どのパッケージに新しいバージョンがあるかを確認できます。\n- **flutter pub get**: 依存関係を最新の状態に更新します。\n- **flutter pub upgrade**: pubspec.yamlに指定されたバージョン範囲内で、パッケージを最新のものにアップグレードします。\n- **flutter clean**: どうにもならなくなったときは、まずこのコマンドを試してみましょう。ビルドキャッシュをクリアし、依存関係を再構築してくれます。\n\n## 複雑なウィジェットの組み合わせ例 🧩\nこれらの基本ウィジェットを組み合わせることで、より複雑なUIを構築できます。\n\n```dart\nScaffold(\n  appBar: AppBar(\n    title: const Text('ウィジェットの組み合わせ'),\n  ),\n  body: SingleChildScrollView( // 画面がスクロールできるようにする\n    child: Column(\n      children: [\n        const Text('縦に並ぶウィジェット'),\n        Row( // 横に並ぶウィジェット\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: const [\n            Icon(Icons.star, color: Colors.yellow),\n            Icon(Icons.star, color: Colors.yellow),\n            Icon(Icons.star, color: Colors.yellow),\n          ],\n        ),\n        Container(\n          height: 150,\n          color: Colors.blue,\n          child: const Center(\n            child: Text('コンテナ'),\n          ),\n        ),\n      ],\n    ),\n  ),\n);\n```\n\nこの例では、SingleChildScrollView、Column、Row、Containerといったウィジェットを組み合わせて、より豊かなレイアウトを実現しています。\n\n## 1. Container ウィジェット 📦\nContainerは、Flutterで最も汎用的なウィジェットの一つです。パディング、マージン、色、ボーダー、角丸などの装飾を施したり、サイズを指定したりするのに使われます。\n\n```dart\nContainer(\n  margin: const EdgeInsets.all(16), // 外側の余白（マージン）\n  padding: const EdgeInsets.all(16), // 内側の余白（パディング）\n  height: 100, // 高さを指定\n  width: 100, // 幅を指定\n  decoration: BoxDecoration( // コンテナの装飾\n    color: Colors.blue,\n    borderRadius: BorderRadius.circular(12), // 角を丸くする\n    border: Border.all(color: Colors.red, width: 2), // ボーダー\n    boxShadow: const [ // 影をつける\n      BoxShadow(\n        color: Colors.black26,\n        blurRadius: 10,\n        offset: Offset(0, 5),\n      ),\n    ],\n  ),\n  child: const Center(\n    child: Text('コンテナ'),\n  ),\n)\n```\n\n## 2. Expanded と Flexible ウィジェット\nRowやColumnの子ウィジェットを、利用可能なスペースに合わせて拡張または調整するために使われます。レスポンシブなレイアウトを構築する上で非常に重要です。\n\n- **Expanded**: 親ウィジェットの残りのスペースをすべて占有します。flexプロパティを使って、複数のExpandedウィジェット間でスペースを分配できます。\n\n```dart\nRow(\n  children: \u003CWidget>[\n    Container(width: 50, color: Colors.red),\n    Expanded( // 残りのスペースをすべて占有\n      child: Container(color: Colors.green),\n    ),\n    Container(width: 50, color: Colors.blue),\n  ],\n)\n```\n\n- **Flexible**: 親ウィジェットの残りのスペースを、子ウィジェットのコンテンツサイズに合わせて柔軟に調整します。fitプロパティでフィット方法を制御できます。ExpandedはFlexibleの特殊なケース（fit: FlexFit.tight）です。\n\n```dart\nRow(\n  children: \u003CWidget>[\n    Flexible( // コンテンツサイズに合わせてスペースを調整\n      child: Text('長いテキストを折り返す'),\n    ),\n    Flexible(\n      child: Container(color: Colors.orange, height: 50),\n    ),\n  ],\n)\n```\n\n## 3. Stack ウィジェット 🎭\nStackウィジェットは、複数のウィジェットを重ねて配置するために使われます。ウィジェットをz軸方向（手前/奥）に重ねたい場合に便利です。\n\n```dart\nStack(\n  alignment: Alignment.center, // 子ウィジェットを中央に配置\n  children: \u003CWidget>[\n    Container(\n      width: 200,\n      height: 200,\n      color: Colors.red,\n    ),\n    Container(\n      width: 150,\n      height: 150,\n      color: Colors.blue,\n    ),\n    Positioned( // 特定の位置に子ウィジェットを配置\n      bottom: 10,\n      right: 10,\n      child: Icon(Icons.star, size: 50, color: Colors.yellow),\n    ),\n  ],\n)\n```\n\nPositionedウィジェットをStackの子として使うことで、上、下、左、右からの距離を指定してウィジェットを正確に配置できます。\n\n## 1. SizedBox ウィジェット 📏\nSizedBoxは、特定のサイズの空きスペースや、子ウィジェットのサイズを固定したいときに使う、非常にシンプルなウィジェットです。widthとheightプロパティを使って、簡単にサイズを調整できます。特に、RowやColumnの中で、ウィジェット間に一定のスペースを空けるのに便利です。\n\n```dart\nRow(\n  children: const \u003CWidget>[\n    Text('商品名'),\n    SizedBox(width: 8), // 8ピクセルの横の余白\n    Text('¥1,200'),\n    SizedBox(width: 16), // 16ピクセルの横の余白\n    Text('在庫あり'),\n  ],\n)\n```\n\n## 2. Padding ウィジェット 🛡️\nPaddingは、子ウィジェットの外側に一定の余白（パディング）を追加するウィジェットです。これにより、ウィジェット間の見栄えを整えることができます。EdgeInsetsを使って、上下左右のパディングを細かく設定できます。\n\n```dart\nPadding(\n  padding: const EdgeInsets.all(16), // 上下左右に16ピクセルのパディング\n  child: Container(\n    color: Colors.blue,\n    child: const Text('パディング付きのコンテナ'),\n  ),\n)\n```\n\n- **EdgeInsets.all(double)**: 全方向に同じパディングを適用します。\n- **EdgeInsets.symmetric(horizontal: double, vertical: double)**: 垂直方向と水平方向のパディングを個別に設定します。\n- **EdgeInsets.fromLTRB(left, top, right, bottom)**: 上下左右のパディングをすべて個別に設定します。\n\n## 3. FlexibleとExpandedの応用 📐\nFlexibleとExpandedは、RowやColumn内でのウィジェットのサイズを動的に調整するのに不可欠です。特に、flexプロパティを使うことで、子ウィジェット間のスペース配分をより細かく制御できます。\n\n```dart\nColumn(\n  children: \u003CWidget>[\n    Flexible(\n      flex: 1, // 1/3のスペースを占有\n      child: Container(color: Colors.red),\n    ),\n    Flexible(\n      flex: 2, // 2/3のスペースを占有\n      child: Container(color: Colors.blue),\n    ),\n  ],\n)\n```\n\nこの例では、Columnの利用可能なスペース全体を3つの部分に分け、赤いコンテナが1つの部分を、青いコンテナが2つの部分を占めるようにしています。","src/content/docs/flutterガイド/01_はじめに/02_flutterの基本構文/syntax.mdx","250c4e0d2ffaa0a4","flutterガイド/01_はじめに/02_flutterの基本構文/type",{"id":1310,"data":1312,"body":1316,"filePath":1317,"digest":1318,"deferredRender":16},{"title":118,"editUrl":16,"head":1313,"template":18,"sidebar":1314,"pagefind":16,"draft":20},[],{"label":118,"hidden":20,"attrs":1315},{},"## Flutterにおける型定義\nFlutterにおける型定義について、実践的な開発現場での使い方やNull安全性に関する詳細を解説します。\n\n### 型定義の基本 ✍️\nDartは静的型付け言語であり、変数がどのような種類のデータを保持するかをコンパイル時にチェックします。これにより、コードの安全性と可読性が大幅に向上します。\n\n#### よく使う基本型\n- **int**: 整数（例: 10）\n- **double**: 浮動小数点数（例: 3.14）\n- **String**: 文字列（例: 'Hello'）\n- **bool**: 真偽値（true または false）\n\n#### コレクション型\n```\n- **List\u003CT>**: 順序のある要素の集まりです。Tはリスト内の要素の型（例: List\u003CString>）。\n- **Map\u003CK, V>**: キーと値のペアの集まりです。Kはキーの型、Vは値の型（例: Map\u003CString, int>）。\n```\n\n```dart\n// 型の使用例\nint count = 0;\ndouble price = 19.99;\nString name = 'Flutter';\nbool isActive = true;\nList\u003CString> items = ['Item1', 'Item2'];\nMap\u003CString, int> scores = {'Alice': 90, 'Bob': 85};\n```\n\n### 実践的な型定義の応用 💡\n開発現場では、型定義の知識を活かして、より堅牢で保守しやすいコードを書くことが求められます。\n\n#### 1. 関数とメソッドの型指定\n関数の引数と戻り値に型を明示的に指定することで、コードの意図が明確になり、バグを防ぎやすくなります。\n\n```dart\n// 引数と戻り値に型を明示的に指定\nString createFullName(String firstName, String lastName) {\n  return '$firstName $lastName';\n}\n\n// 戻り値がなくてもvoidで型を指定\nvoid printMessage(String message) {\n  print(message);\n}\n```\n\n#### 2. Null安全性（Null Safety）の活用\nDartはNull安全性を厳密にチェックします。これにより、nullによるランタイムエラー（Null Pointer Exception）をコンパイル時に防ぐことができます。\n\n- **?（Null許容型）**: 型の末尾に?を付けることで、その変数がnullになる可能性を明示します。\n- **!（Null非許容演算子）**: 開発者がnullではないことを保証する場合に使用します。注意: 予期せずnullだった場合、ランタイムエラーが発生します。\n- **??（Null合体演算子）**: 値がnullの場合にデフォルト値を指定します。\n\n```dart\n// null許容型を定義\nString? nullableName;\n\n// 値がnullではないことを確認してから使用する\nif (nullableName != null) {\n  print('Hello, $nullableName!');\n}\n\n// Null合体演算子\nString displayName = nullableName ?? 'Guest'; // nullableNameがnullなら'Guest'を代入\n\n// Null非許容演算子の使用（注意が必要）\nString requiredName = nullableName!; // nullableNameがnullでないことを保証\n```\n\n#### 3. late修飾子の利用\nlateは、変数を後で初期化することを約束する修飾子です。インスタンス化の際に初期化できないが、使用する前には必ず初期化されることが分かっている場合に便利です。\n\n```dart\nclass User {\n  late final String username;\n\n  User(String name) {\n    // コンストラクタの本体で初期化\n    username = name;\n  }\n}\n```\n\n#### 4. final と const の使い分け\n- **final**: 変数が一度だけ初期化されることを保証します。実行時に値が決定される定数に使用します。\n- **const**: コンパイル時に値が決定される定数です。パフォーマンスが最も高いです。\n\n```dart\nfinal now = DateTime.now(); // 実行時に値が決定\nconst appName = 'My App'; // コンパイル時に値が決定\n```\n\n#### 5. var、dynamic、そして型推論 🕵️\nDartには、型を明示的に指定しない方法がいくつかありますが、それぞれ異なる役割を持っています。\n\n- **var**: コンパイラが初期値から自動的に型を推論します。一度型が推論されると、その変数の型は変更できません。これにより、コードの記述量を減らしつつ、型安全性を維持できます。\n\n```dart\nvar name = 'Alice'; // コンパイラは `String` と推論\n// name = 123; // エラー: String型ではない\n\nvar age = 30; // コンパイラは `int` と推論\n```\n\n- **dynamic**: すべての型を受け入れることができます。これは、コンパイル時の型チェックを無効にするため、実行時まで型が確定しません。必要な場合にのみ使用すべきで、多用すると型安全性の利点を失います。\n\n```dart\ndynamic value = 'Hello';\nvalue = 123; // エラーにならない\nprint(value.length); // 実行時にエラーになる可能性がある\n```\n\n#### 6. ジェネリクス（Generics）の応用 🎁\nジェネリクスは、型をパラメータとして受け取ることで、一つのコードで複数の型を扱えるようにする機能です。これにより、コードの再利用性を高めながら、型安全性を維持できます。\n\n##### カスタムクラスでの活用\nコレクション型だけでなく、独自のクラスでもジェネリクスを活用することで、汎用的なデータ構造を設計できます。\n\n```dart\nclass Box\u003CT> {\n  T value;\n  Box(this.value);\n}\n\n// Boxクラスを異なる型で再利用\nvar intBox = Box\u003Cint>(123);\nprint(intBox.value); // 123\nprint(intBox.value.runtimeType); // int\n\nvar stringBox = Box\u003CString>('Dart');\nprint(stringBox.value); // Dart\nprint(stringBox.value.runtimeType); // String\n```\n\n#### 7. 列挙型（enum） 📋\nenumは、固定された一連の定数を定義するために使用します。これにより、コードの可読性を高め、入力ミスによるバグを防ぐことができます。\n\n```dart\nenum Status {\n  pending,\n  inProgress,\n  completed,\n  cancelled,\n}\n\nvoid updateTaskStatus(Status status) {\n  if (status == Status.completed) {\n    print('タスクが完了しました。');\n  } else {\n    print('タスクの状態: $status');\n  }\n}\n\nupdateTaskStatus(Status.completed);\n```\n\nenumを使用することで、マジックナンバー（意味のわからない数字や文字列）を排除し、コードの意図を明確にすることができます。\n\n### 8. classと継承 (Inheritance) 🏛️\nDartは、クラスベースのオブジェクト指向言語です。UIをウィジェットとして表現するFlutterでは、クラスの概念がUIの構造そのものに直結しています。\n\n- **継承**: 既存のクラス（親クラス）の機能を再利用し、新しいクラス（子クラス）を作成することです。Flutterでは、StatelessWidgetやStatefulWidgetを継承して独自のウィジェットを作成します。\n\n```dart\n// 親クラス\nclass Animal {\n  void eat() {\n    print('動物が食べています。');\n  }\n}\n\n// 子クラスが親クラスを継承\nclass Dog extends Animal {\n  void bark() {\n    print('ワンワン！');\n  }\n}\n\n// 使い方\nvar dog = Dog();\ndog.eat(); // 親クラスのメソッドを呼び出し\ndog.bark();\n```\n\n### 9. 抽象クラス (Abstract Classes) と Mixins 🧩\n- **抽象クラス**: 完全に実装されていないメソッドを持つクラスです。他のクラスに継承されて、そのメソッドを実装させることを目的とします。\n\n```dart\n// 抽象クラス\nabstract class Shape {\n  void draw(); // 実装を持たない抽象メソッド\n}\n\nclass Circle extends Shape {\n  @override\n  void draw() {\n    print('円を描画します。');\n  }\n}\n```\n\n- **Mixins**: 多重継承に似た機能を提供しますが、クラスの継承ツリーに縛られることなく、複数のクラス間で機能を共有できます。これにより、コードの再利用性を高め、柔軟な設計を可能にします。Flutterでは、アニメーションや状態管理のロジックを複数のウィジェットで共有する際に非常によく使われます。\n\n```dart\nmixin Flyable {\n  void fly() {\n    print('飛んでいます。');\n  }\n}\n\nclass Bird with Flyable {\n  // mixinのfly()メソッドを使用できる\n}\n```\n\n### 10. Typedef による型のエイリアス (Type Aliases) 🏷️\ntypedefは、既存の関数や複雑な型の別名を定義するために使用されます。これにより、コードの可読性を高め、冗長な記述を避けることができます。特に、コールバック関数や複雑なジェネリクス型を扱う際に役立ちます。\n\n```dart\n// 複雑な関数型の別名を定義\ntypedef OnTapCallback = void Function(int index);\n\nclass MyButtonList {\n  final OnTapCallback onTap;\n  \n  const MyButtonList({required this.onTap});\n  \n  // 使うときはシンプルに\n  void handleTap(int index) {\n    onTap(index);\n  }\n}\n```\n\nこれらの概念をマスターすることで、より高度で拡張性の高いFlutterアプリケーションを構築できるようになります。","src/content/docs/flutterガイド/01_はじめに/02_flutterの基本構文/type.mdx","1bbb7a8a2fc3de30","flutterガイド/02_基本/04_uiコンポーネント/ui_components",{"id":1319,"data":1321,"body":1326,"filePath":1327,"digest":1328,"deferredRender":16},{"title":1322,"editUrl":16,"head":1323,"template":18,"sidebar":1324,"pagefind":16,"draft":20},"UIコンポーネント",[],{"label":1322,"hidden":20,"attrs":1325},{},"# ウィジェットのカスタマイズ\n\nFlutterでは、カスタムウィジェットを作成してアプリのUIを柔軟にデザインできます。ウィジェットは、アプリのUIを構成する基本単位であり、再利用可能なコンポーネントとして設計することが重要です。\n\n## カスタムウィジェットの作成\n\nカスタムウィジェットを作成することで、アプリの一貫性を保ちつつ、特定のデザイン要件を満たすことができます。以下に、カスタムボタンの例を示します。\n\n```dart\nclass CustomButton extends StatelessWidget {\n  final String label;\n  final VoidCallback onPressed;\n\n  CustomButton({required this.label, required this.onPressed});\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      child: Text(label),\n    );\n  }\n}\n```\n\n- **`StatelessWidget`**: 状態を持たないウィジェットを作成する際に使用します。\n- **`StatefulWidget`**: 状態を持つウィジェットを作成する際に使用します。\n\n## よく使われるウィジェット\n\n- **`Container`**: レイアウトや装飾を行うための基本的なウィジェットです。\n- **`Text`**: テキストを表示するためのウィジェットです。\n- **`Image`**: 画像を表示するためのウィジェットです。\n\n## レイアウト\n\n`Row`や`Column`、`Stack`を使って複雑なレイアウトを構築できます。これらのウィジェットを組み合わせることで、柔軟なUIを実現できます。\n\n## RowとColumnの例\n\n```dart\nRow(\n  children: \u003CWidget>[\n    Icon(Icons.star),\n    Icon(Icons.star),\n    Icon(Icons.star),\n  ],\n)\n```\n\n- **`Row`**: ウィジェットを横に並べます。\n- **`Column`**: ウィジェットを縦に並べます。\n- **`Stack`**: ウィジェットを重ねて配置します。\n\n# 実践的なアドバイス\n\nUIコンポーネントを使用する際のベストプラクティスや、よくある問題の解決策を以下に示します。\n\n## ベストプラクティス\n\n- **一貫したデザイン**: カスタムウィジェットを使用して、アプリ全体で一貫したデザインを保ちましょう。\n- **レスポンシブデザイン**: `MediaQuery`や`LayoutBuilder`を使用して、さまざまなデバイスサイズに対応するレスポンシブなUIを構築します。\n- **コードの再利用**: ウィジェットを小さく分割し、再利用可能なコンポーネントとして設計することで、コードのメンテナンス性を向上させます。\n\n## よくある問題の解決策\n\n- **レイアウトのオーバーフロー**: レイアウトが画面サイズを超える場合、`SingleChildScrollView`を使用してスクロール可能にします。\n\n```dart\nSingleChildScrollView(\n  child: Column(\n    children: \u003CWidget>[\n      // ウィジェットのリスト\n    ],\n  ),\n)\n```\n\n- **パフォーマンスの最適化**: `ListView.builder`を使用して、大量のデータを効率的に表示します。\n\n```dart\nListView.builder(\n  itemCount: items.length,\n  itemBuilder: (context, index) {\n    return ListTile(\n      title: Text(items[index]),\n    );\n  },\n)\n```","src/content/docs/flutterガイド/02_基本/04_UIコンポーネント/ui_components.mdx","77fa651207302809","flutterガイド/02_基本/03_状態管理/riverpod",{"id":1329,"data":1331,"body":1337,"filePath":1338,"digest":1339,"deferredRender":16},{"title":1332,"editUrl":16,"head":1333,"template":18,"sidebar":1334,"pagefind":16,"draft":20},"Riverpodによる状態管理",[],{"label":1335,"hidden":20,"attrs":1336},"Riverpod",{},"## RiverpodとProviderの比較 ⚖️\nRiverpodとProviderは、どちらもFlutterで状態管理を行うためのライブラリですが、依存関係の管理方法と安全性に大きな違いがあります。\n\n| 特徴 | Provider | Riverpod |\n| --- | --- | --- |\n| 依存関係 | ウィジェットツリーに依存 | ウィジェットツリーから独立 |\n| 安全性 | 実行時にエラーが発生する可能性あり | 型安全で、コンパイル時にエラーを検知 |\n| ボイラープレート | 多い | 少ない |\n| テスト | ウィジェットツリーをモックする必要あり | プロバイダ単体をテスト可能 |\n\n### Provider\nProviderは、ウィジェットツリーを介して状態を供給します。そのため、`Provider.of(context)`のように、状態にアクセスする際に`BuildContext`を必要とします。この依存性から、状態にアクセスするウィジェットがツリーのどこに位置するかを常に意識する必要があります。\n\n### Riverpod\nRiverpodは、ウィジェットツリーから独立しています。プロバイダはグローバルに定義され、どのウィジェットからでも安全にアクセスできます。これにより、複雑なウィジェットツリーを持つアプリケーションでも、依存関係をシンプルに管理できます。\n\n## Providerの基本的な使い方 💡\nProviderは、シンプルで直感的な状態管理に適しています。\n\n### 1. プロバイダの定義\n`ChangeNotifierProvider`は、状態が変更されたときにリスナーに通知する機能を提供します。\n\n```dart\n// 状態を管理するモデルクラス\nclass Counter with ChangeNotifier {\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners(); // 状態が変更されたことを通知\n  }\n}\n\n// プロバイダの定義\nfinal counterProvider = ChangeNotifierProvider((ref) => Counter());\n```\n\n### 2. 状態へのアクセス\n`Provider.of`や`Consumer`ウィジェットを使って、状態にアクセスします。\n\n```dart\n// Provider.ofを使用\nfinal counter = Provider.of\u003CCounter>(context);\ncounter.increment();\n\n// Consumerウィジェットを使用\nConsumer\u003CCounter>(\n  builder: (context, counter, child) {\n    return Text('${counter.count}');\n  },\n)\n```\n\n## Riverpodの基本的な使い方 ✨\nRiverpodは、より安全で、テストしやすい状態管理を提供します。\n\n### 1. プロバイダの定義\n`StateNotifierProvider`は、状態とロジックを分離するのに適しています。\n\n```dart\n// 状態を管理するクラス（StateNotifierを継承）\nclass CounterNotifier extends StateNotifier\u003Cint> {\n  CounterNotifier() : super(0); // 初期値は0\n\n  void increment() {\n    state++; // stateで状態を直接更新\n  }\n}\n\n// プロバイダの定義\nfinal counterProvider = StateNotifierProvider\u003CCounterNotifier, int>((ref) {\n  return CounterNotifier();\n});\n```\n\n### 2. 状態へのアクセス\n`ConsumerWidget`または`Consumer`ウィジェットを使い、`ref`を介して状態にアクセスします。\n\n```dart\n// ConsumerWidgetを使用\nclass CounterPage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 状態を監視（変化を検知）\n    final count = ref.watch(counterProvider);\n    \n    return Text('$count');\n  }\n}\n```\n\n## 実践的な使い分け 🗺️\n- **Provider**:\n  - 小規模なアプリケーションや、状態管理の概念を学び始める場合に適しています。\n  - 既存のコードベースに部分的に状態管理を導入したい場合に、シンプルで扱いやすいです。\n\n- **Riverpod**:\n  - 大規模で複雑なアプリケーションに適しています。\n  - 堅牢なテスト体制を構築したい場合。\n  - ウィジェットツリーの階層に依存しない、より安全で予測可能な状態管理を求める場合。\n\n多くの開発者は、新しいプロジェクトを始める際にはRiverpodを選択することが多くなっています。Riverpodは、Providerの利点をすべて持ちつつ、より多くの問題点を解決しているからです。\n\n## Riverpodの概要\nRiverpodは、Flutterアプリケーションでの状態管理を簡素化するためのライブラリです。Providerの進化版として、より柔軟で安全な状態管理を提供します。\n\n### なぜRiverpodを使うのか\n- **型安全**: 型安全な状態管理が可能です。コンパイル時に型チェックが行われるため、バグを未然に防ぐことができます。\n- **ホットリロード対応**: 状態を保持したままホットリロードが可能です。開発中にコードを変更しても、アプリの状態を失うことなく即座に反映されます。\n- **依存関係の管理**: Riverpodは、プロバイダ間の依存関係を明示的に定義できるため、複雑なアプリケーションでも管理が容易です。\n- **テストの容易さ**: Riverpodは、状態管理のロジックを分離してテストしやすくします。プロバイダをモック化することで、ユニットテストが簡単に行えます。\n\n### よく使われるプロバイダの種類\n- **`Provider`**: 読み取り専用の状態を提供します。\n- **`StateProvider`**: 状態を持ち、変更可能な状態を提供します。\n- **`FutureProvider`**: 非同期処理の結果を提供します。\n- **`StreamProvider`**: ストリームのデータを提供します。\n\n## Riverpodのインストール\nRiverpodをプロジェクトに追加するには、以下のコマンドを実行します。\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^1.0.0 // ここに追加\n```\n\n```bash\nflutter pub add flutter_riverpod\n```\n\n## Riverpodによる状態管理の実践 🚀\nRiverpodは、Flutterの状態管理ライブラリの中でも特に人気が高く、大規模アプリケーション開発に適しています。\n\n### 1. なぜRiverpodを使うのか\nRiverpodは、従来のProviderライブラリの弱点を克服するために開発されました。\n\n- **型安全性の向上**: Providerは特定のウィジェットツリーに依存していましたが、Riverpodはグローバルにプロバイダを定義するため、より安全に型を扱えます。\n- **ボイラープレートの削減**: `ConsumerWidget`や`Consumer`を使用することで、状態の監視と利用を簡潔に記述できます。\n\n### 2. よく使われるプロバイダの種類\nプロバイダは、アプリケーションの状態を保持し、ウィジェットに提供するための「箱」です。\n\n- **Provider**: 単純な値を渡す際に使います。変更されない設定値や、サービスインスタンスなどに適しています。\n- **StateProvider**: 変更可能な状態を管理します。シンプルなカウンターアプリなど、UIから直接変更される状態に使います。\n- **StateNotifierProvider**: より複雑な状態（複数のプロパティを持つクラスなど）と、その状態を変更するロジックを管理します。ビジネスロジックをUIから分離する際に非常に重要です。\n- **FutureProvider & StreamProvider**: 非同期処理（API通信など）の結果を管理します。ローディング、エラー、データの各状態を自動的に処理してくれるため、非常に便利です。\n\n### 3. カウンターアプリのより実践的な例\n単純なカウンターアプリでも、`StateNotifierProvider`を使うことで、ビジネスロジックを分離できます。\n\n```dart\n// 状態を管理するクラス（ビジネスロジック）\nclass CounterNotifier extends StateNotifier\u003Cint> {\n  CounterNotifier() : super(0); // 初期値は0\n\n  void increment() {\n    state++; // 状態を更新\n  }\n}\n\n// StateNotifierProviderを定義\nfinal counterProvider = StateNotifierProvider\u003CCounterNotifier, int>((ref) {\n  return CounterNotifier();\n});\n\nclass CounterPage extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // 状態を監視\n    final count = ref.watch(counterProvider);\n    \n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Counter')),\n      body: Center(\n        child: Text('$count', style: Theme.of(context).textTheme.headline4),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // ビジネスロジックを呼び出す\n          ref.read(counterProvider.notifier).increment();\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n## UIコンポーネントのカスタマイズと再利用 🎨\nFlutterは「すべてがウィジェット」という思想に基づいています。カスタムウィジェットを作成し、再利用することは、大規模アプリ開発の基本です。\n\n### 1. なぜカスタムウィジェットを作るのか\n- **コードの重複を避ける**: 複数の画面で同じデザインのボタンやカードを使う場合に、カスタムウィジェットとして定義することで、コードの重複をなくせます。\n- **メンテナンス性の向上**: UIの変更が必要になった場合、カスタムウィジェットを1箇所修正するだけで、アプリ全体のUIが更新されます。\n- **関心の分離**: UIのデザインとロジックを分離することで、コードが読みやすくなります。\n\n### 2. カスタムウィジェットのベストプラクティス\n- カスタムウィジェットは、可能な限り**StatelessWidget**として作成しましょう。これにより、不要な再構築を防ぎ、パフォーマンスを向上させます。\n- 親ウィジェットから受け取るデータは`final`で宣言し、コンストラクタで受け取るようにします。\n- ウィジェット内で状態を持つ必要がある場合は、`StatefulWidget`を使用しますが、必要最低限に留めます。\n\n## パフォーマンス最適化の実践 ⚙️\n美しいUIだけでなく、スムーズな動作も重要です。\n\n### 1. イメージの最適化\n画像はアプリのサイズとパフォーマンスに大きく影響します。\n\n- **適切なフォーマットの選択**: WebPやPNGは、JPEGよりも透明度をサポートし、より高い圧縮率を提供します。\n- **画像の解像度**: デバイスの画面サイズに合わせて、適切な解像度の画像を準備しましょう。\n- **画像のキャッシュ**: `CachedNetworkImage`のようなライブラリを使って、ネットワークから取得した画像をキャッシュすることで、再度ダウンロードする手間を省きます。\n\n### 2. ウィジェットの再構築の最適化\nFlutterは高速ですが、不必要なウィジェットの再構築はパフォーマンス低下の原因になります。\n\n- **constコンストラクタ**: コンパイル時に値が確定するウィジェットには、`const`を付けましょう。これにより、再構築時にウィジェットが再作成されるのを防ぎます。\n- **Consumerウィジェット**: `Consumer`は、監視しているプロバイダが更新されたときのみ、その子ウィジェットを再構築します。これにより、不要なUIの再構築を最小限に抑えられます。\n- **selectメソッド**: プロバイダ内の複数のプロパティのうち、特定のプロパティが変更されたときのみ再構築したい場合に`select`を使用します。これにより、よりピンポイントな再構築が可能になります。\n\nこれらの実践的なアドバイスを適用することで、より効率的で、パフォーマンスの高いFlutterアプリケーションを開発できます。","src/content/docs/flutterガイド/02_基本/03_状態管理/riverpod.mdx","a3b4fe3a55a0b7df","flutterガイド/02_基本/test/testing",{"id":1340,"data":1342,"body":1347,"filePath":1348,"digest":1349,"deferredRender":16},{"title":1343,"editUrl":16,"head":1344,"template":18,"sidebar":1345,"pagefind":16,"draft":20},"テスト",[],{"label":1343,"hidden":20,"attrs":1346},{},"# テスト\n\nFlutterでのテストは、アプリケーションの品質を保証するために重要です。以下に、テストの方法を紹介します。\n\n## ユニットテスト\n\nユニットテストは、個々の関数やメソッドが正しく動作することを確認するためのテストです。`test`パッケージを使用して、ユニットテストを実行します。\n\n### ユニットテストの例\n\n```dart\ntest('Counter increments smoke test', () {\n  final counter = Counter();\n\n  counter.increment();\n\n  expect(counter.value, 1);\n});\n```\n\n- **`test`**: テストケースを定義するための関数です。\n- **`expect`**: 実際の値と期待される値を比較します。\n\n## ウィジェットテスト\n\nウィジェットテストは、UIの動作を確認するためのテストです。`flutter_test`パッケージを使用して、ウィジェットテストを実行します。\n\n### ウィジェットテストの例\n\n```dart\ntestWidgets('MyWidget has a title and message', (WidgetTester tester) async {\n  await tester.pumpWidget(MyWidget());\n\n  final titleFinder = find.text('T');\n  final messageFinder = find.text('M');\n\n  expect(titleFinder, findsOneWidget);\n  expect(messageFinder, findsOneWidget);\n});\n```\n\n- **`testWidgets`**: ウィジェットテストを定義するための関数です。\n- **`pumpWidget`**: ウィジェットをテスト環境にロードします。\n\n## その他のテスト手法\n\n- **`インテグレーションテスト`**: アプリ全体の動作を確認するためのテストです。`integration_test`パッケージを使用して、インテグレーションテストを実行します。\n- **`モックテスト`**: 外部依存をモック化して、特定の機能をテストします。\n\n# 実践的なアドバイス\n\nテストを行う際のベストプラクティスや、よくある問題の解決策を以下に示します。\n\n## ベストプラクティス\n\n- **テストの自動化**: CI/CDパイプラインにテストを組み込み、自動化することで、継続的な品質保証を実現します。\n- **テストのカバレッジ**: テストカバレッジを高めるために、重要な機能やエッジケースを網羅するテストケースを作成します。\n- **テストの分離**: 各テストケースは独立して実行できるように設計し、他のテストに依存しないようにします。\n\n## よくある問題の解決策\n\n- **テストの失敗**: テストが失敗した場合、エラーメッセージをよく読み、原因を特定して修正します。`flutter test --verbose`を使用して、詳細なログを確認します。\n\n- **非同期処理のテスト**: 非同期処理をテストする際は、`async`/`await`を使用して、テストが完了するまで待機します。\n\n```dart\ntest('Async test example', () async {\n  final result = await fetchData();\n  expect(result, isNotNull);\n});\n```\n\n- **モックの使用**: 外部依存をモック化して、特定の機能をテストします。`mockito`パッケージを使用して、モックを作成します。","src/content/docs/flutterガイド/02_基本/test/testing.mdx","65492f790d1b108a","fastapiガイド/05_学び記事/apiリファレンス/設定ファイルの詳細",{"id":1350,"data":1352,"body":1357,"filePath":1358,"digest":1359,"deferredRender":16},{"title":1353,"editUrl":16,"head":1354,"template":18,"sidebar":1355,"pagefind":16,"draft":20},"設定ファイルの詳細",[],{"hidden":20,"attrs":1356},{},"FastAPIの設定ファイルの詳細を以下に示します。\n\n## main.py\n\n`main.py`ファイルは、FastAPIアプリケーションのエントリーポイントです。\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n```","src/content/docs/fastapiガイド/05_学び記事/APIリファレンス/設定ファイルの詳細.mdx","8dbd9b93793a2902","fastapiガイド/05_学び記事/より深く/パフォーマンス最適化",{"id":1360,"data":1362,"body":1366,"filePath":1367,"digest":1368,"deferredRender":16},{"title":58,"editUrl":16,"head":1363,"template":18,"sidebar":1364,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1365},{},"FastAPIアプリケーションのパフォーマンス最適化方法を以下に示します。\n\n## 非同期処理\n\nFastAPIは、非同期処理をサポートしており、リクエストの処理を効率化します。\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: str = None):\n    return {\"item_id\": item_id, \"q\": q}\n```","src/content/docs/fastapiガイド/05_学び記事/より深く/パフォーマンス最適化.mdx","61c42b79a4b3f929","fastapiガイド/05_学び記事/より高度な使用例/トラブルシューティング",{"id":1369,"data":1371,"body":1376,"filePath":1377,"digest":1378,"deferredRender":16},{"title":1372,"editUrl":16,"head":1373,"template":18,"sidebar":1374,"pagefind":16,"draft":20},"トラブルシューティング",[],{"hidden":20,"attrs":1375},{},"FastAPIアプリケーションのトラブルシューティング方法を以下に示します。\n\n## よくあるエラー\n\n- **`HTTPException`**: リクエストが不正な場合に発生します。\n- **`ValidationError`**: リクエストデータがバリデーションに失敗した場合に発生します。\n\n## デバッグ\n\nFastAPIでは、`print`関数を使用して、変数の値をデバッグできます。\n\n```python\nvalue = \"Hello, World!\"\nprint(value)\n```","src/content/docs/fastapiガイド/05_学び記事/より高度な使用例/トラブルシューティング.mdx","37b4017bc9f913df","railsガイド/04_上級最適化/apiモード認証認可",{"id":1379,"data":1381,"body":1386,"filePath":1387,"digest":1388,"deferredRender":16},{"title":1382,"editUrl":16,"head":1383,"template":18,"sidebar":1384,"pagefind":16,"draft":20},"API認証認可",[],{"hidden":20,"attrs":1385},{},"## 🔑 API認証・認可の比較\n\nNext.js（フロントエンド）とRails（バックエンド）を連携させるAPI認証において、主要な2つの方法を比較します。\n\n### 1. JWT + HttpOnly Cookie\n\nこの方法は、セキュリティを最優先する場合に最適なアプローチです。\n\n**仕組み:**\n\n- 認証成功後、JWT（JSON Web Token）を生成し、HttpOnly属性付きのCookieに格納してフロントエンドに送ります。\n- ブラウザは以降のAPIリクエストにこのCookieを自動的に添付します。\n\n**メリット:**\n\n- 高いセキュリティ: HttpOnly属性により、JavaScriptからのトークンアクセスを遮断し、XSS（クロスサイト・スクリプティング）攻撃によるトークン盗難のリスクを大幅に減らせます。\n\n**デメリット:**\n\n- 実装の複雑性: クロスドメイン通信の場合、CORS設定や認証情報を含むリクエストの制御が必要となり、実装が少し複雑になります。\n- CSRF対策: Cookieを使用するため、別途CSRF対策（SameSite=Laxなど）が必要です。\n\n### 2. Bearerトークン (localStorage保管)\n\nこの方法は、実装のシンプルさと汎用性が大きな利点です。\n\n**仕組み:**\n\n- 認証成功後、サーバーはJWTを発行し、JSONレスポンスとしてフロントエンドに返します。\n- フロントエンドは、このトークンを**localStorage**に保存します。\n- APIリクエスト時に、`Authorization: Bearer \u003Cyour_token>`というヘッダーを付けてトークンを送信します。\n\n**メリット:**\n\n- 高い汎用性: Webブラウザだけでなく、モバイルアプリなど様々なクライアントと共通の認証方式として利用しやすいです。\n- 実装がシンプル: ヘッダーにトークンをセットするだけで、異なるドメイン間でも比較的簡単に実装できます。\n\n**デメリット:**\n\n- 低いセキュリティ: localStorageはJavaScriptからアクセス可能なため、XSS攻撃に非常に脆弱です。トークンが盗まれると、その有効期限が切れるまで不正利用されるリスクがあります。\n\n### どちらを選ぶべきか？\n\n- セキュリティを最優先するなら、JWT + HttpOnly Cookieを選びましょう。これは、Webアプリケーションにおける現代のベストプラクティスと見なされています。\n- 実装のシンプルさや、Webアプリとモバイルアプリで認証基盤を共通化したい場合は、Bearerトークンも選択肢になります。ただし、その場合はXSS対策（CSPなど）を厳重に行う必要があります。\n\n## 🛡️ API認証方式の比較\n\n| 項目 | JWT + HttpOnly Cookie | Bearerトークン (localStorage) |\n| --- | --- | --- |\n| **セキュリティ** | 最高 🛡️ \u003Cbr/>XSS（クロスサイト・スクリプティング）攻撃に非常に強い。HttpOnly属性により、JavaScriptからのトークンアクセスを完全に遮断。 | 低い 🚨 \u003Cbr/>XSS攻撃に非常に弱い。localStorageに保存されるため、悪意あるスクリプトによって簡単にトークンが盗まれる。 |\n| **利便性** | 中 \u003Cbr/>ブラウザが自動的にCookieを添付するため、フロントエンドでの手動管理は不要。 | 高 \u003Cbr/>JavaScriptからトークンを簡単に取得・設定でき、実装がシンプル。 |\n| **汎用性** | 中 \u003Cbr/>主にブラウザベースのWebアプリケーションに適している。 | 最高 \u003Cbr/>Web、モバイル、デスクトップなど、様々なクライアントで利用可能。 |\n| **クロスドメイン** | 複雑 \u003Cbr/>異なるドメイン間での通信には、CORS設定や認証情報の制御が必要。 | シンプル \u003Cbr/>ヘッダーにトークンをセットするだけなので、比較的簡単に通信が可能。 |\n| **CSRF耐性** | 弱い \u003Cbr/>Cookieを使用するため、SameSite属性などの追加的な対策が必要。 | 強い \u003Cbr/>Authorizationヘッダーを使用するため、CSRFの脅威にさらされにくい。 |\n| **主なユースケース** | Webアプリケーション \u003Cbr/>セキュリティを最優先する場合。 | モバイルアプリやSPA \u003Cbr/>シンプルさや、多様なクライアントへの対応を重視する場合。 |\n\n**結論:** Webアプリケーションにおいて、セキュリティを重視するなら「JWT + HttpOnly Cookie」が最善の選択肢です。一方で、モバイルアプリとの連携や実装のシンプルさを優先する場合は「Bearerトークン」も選択肢となりえますが、その際にはXSS対策を厳重に行う必要があります。\n\n## 1. Sorceryとは？\n\nSorceryは、Rails用の認証ライブラリです。他の認証ライブラリ（Deviseなど）と比較して、非常に軽量で、必要に応じて機能をプラグインとして追加できる柔軟性が特徴です。これにより、最小限の機能から始めて、プロジェクトの要件に合わせてカスタマイズできます。\n\n## 2. Railsプロジェクトのセットアップ\n\n**Step 1: Railsプロジェクトの作成**\n\nまず、新しいRailsプロジェクトを作成します。Next.jsとの連携を想定しているため、`--api`フラグを付けてAPIモードで生成します。\n\n```bash\nrails new your_app_name --api\n```\n\n**Step 2: Gemのインストール**\n\nGemfileにSorceryと関連Gemを追加します。`jwt`はJWTのエンコード/デコード用、`sorcery-jwt`はSorceryでJWTを扱うためのプラグインです。\n\n```ruby\n# Gemfile\ngem 'sorcery'\ngem 'sorcery-jwt'\ngem 'jwt'\n```\n\n`bundle install` を実行して、Gemをインストールします。\n\n```bash\nbundle install\n```\n\n## 3. Sorceryのセットアップ\n\n**Step 1: Sorceryの初期化**\n\nSorceryをプロジェクトに組み込むためのコマンドを実行します。ここでは、`jwt`プラグインと、ユーザー認証を可能にするための`core`プラグインを指定します。\n\n```bash\nrails g sorcery:install jwt\n```\n\nこのコマンドは以下のファイルを生成します。\n\n- **マイグレーションファイル**: `db/migrate/xxxxxx_sorcery_core.rb` が作成され、ユーザーを管理するための`users`テーブルが生成されます。\n- **モデルファイル**: `app/models/user.rb` が生成され、Sorceryの機能が組み込まれます。\n- **設定ファイル**: `config/initializers/sorcery.rb` が作成され、Sorceryの全体設定を記述します。\n\n**Step 2: データベースのマイグレーション**\n\n生成されたマイグレーションファイルを実行して、`users`テーブルを作成します。\n\n```bash\nrails db:migrate\n```\n\n## 4. JWT認証の設定とコントローラーの実装\n\n**Step 1: JWTの秘密鍵の設定**\n\nJWTの署名には秘密鍵が必要です。`Rails.application.credentials`に安全に保管します。\n\n```bash\nrails credentials:edit\n```\n\nエディタが開いたら、以下のように`jwt_secret_key`を追加して保存します。\n\n```yaml\n# config/credentials.yml.enc\nsecret_key_base: \u003C自動生成された値>\njwt_secret_key: 'your_strong_and_secret_key' # ここに独自の秘密鍵を設定\n```\n\n**Step 2: アプリケーションコントローラーの設定**\n\nJWTのペイロードと秘密鍵を定義します。これは、JWTの生成と検証に必要です。\n\n```ruby\n# app/controllers/application_controller.rb\nclass ApplicationController \u003C ActionController::API # APIモードのためActionController::APIを継承\n  # Sorceryのログイン/ログアウトメソッドを有効にする\n  include Sorcery::Controller\n  \n  # JWTのペイロードに含める情報を定義\n  def jwt_payload_for(user)\n    { user_id: user.id }\n  end\n\n  # JWTの秘密鍵を定義\n  def jwt_secret_key\n    Rails.application.credentials.jwt_secret_key\n  end\nend\n```\n\n**Step 3: 認証コントローラーの作成**\n\nログイン・ログアウト処理を行うコントローラーを作成します。\n\n```bash\nrails g controller api/v1/sessions create destroy\n```\n\n生成されたファイルに以下のコードを記述します。\n\n- **createアクション**: ユーザー名とパスワードで認証し、成功すればJWTを生成してCookieにセットします。\n- **destroyアクション**: ログアウト処理を行い、CookieからJWTを削除します。\n\n```ruby\n# app/controllers/api/v1/sessions_controller.rb\nclass Api::V1::SessionsController \u003C ApplicationController\n  def create\n    user = User.authenticate(params[:email], params[:password])\n\n    if user\n      jwt = sorcery_login(user) # SorceryがJWTを生成\n      cookies.signed[:jwt] = {\n        value: jwt,\n        httponly: true,\n        secure: Rails.env.production?\n      }\n      render json: { message: 'Logged in successfully' }\n    else\n      render json: { error: 'Invalid email or password' }, status: :unauthorized\n    end\n  end\n\n  def destroy\n    sorcery_logout # Sorceryがユーザーをログアウト\n    cookies.delete(:jwt, secure: Rails.env.production?)\n    render json: { message: 'Logged out successfully' }\n  end\nend\n```\n\n**Step 4: ルーティングの設定**\n\nAPIエンドポイントを定義します。\n\n```ruby\n# config/routes.rb\nRails.application.routes.draw do\n  namespace :api do\n    namespace :v1 do\n      resources :sessions, only: [:create] do\n        delete :destroy, on: :collection\n      end\n    end\n  end\nend\n```\n\n## 5. Next.jsとの連携\n\n**Step 1: APIクライアントのセットアップ**\n\nNext.js側でAPIと通信するためのクライアント（ここではaxios）を設定します。認証情報（Cookie）を自動で送信するよう設定することが重要です。\n\n```javascript\n// utils/api.js (例)\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'http://localhost:3000/api/v1',\n  withCredentials: true, // これが重要！\n});\n\nexport default api;\n```\n\n**Step 2: ログイン処理の実装**\n\nログインフォームの送信時に、JWTをJSONで受け取るのではなく、Cookieの保存をブラウザに任せます。\n\n```javascript\n// pages/login.js (例)\nimport { useState } from 'react';\nimport api from '../utils/api'; // 先ほど作成したaxiosクライアント\n\nexport default function LoginPage() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleLogin = async (e) => {\n    e.preventDefault();\n    try {\n      await api.post('/sessions', { email, password });\n      window.location.href = '/dashboard'; \n    } catch (error) {\n      console.error('Login failed', error);\n    }\n  };\n\n  return (\n    // ... フォームのJSX\n  );\n}\n```\n\n**Step 3: 認証が必要なAPIへのアクセス**\n\nログイン後、認証が必要なAPIにアクセスする際は、特別なヘッダー設定は不要です。`withCredentials: true`の設定により、ブラウザが自動的にCookieを添付してくれます。\n\n```javascript\n// pages/dashboard.js (例)\nimport { useEffect, useState } from 'react';\nimport api from '../utils/api';\n\nexport default function DashboardPage() {\n  const [profile, setProfile] = useState(null);\n\n  useEffect(() => {\n    const fetchProfile = async () => {\n      try {\n        const response = await api.get('/profile'); // Railsの認証が必要なエンドポイント\n        setProfile(response.data);\n      } catch (error) {\n        console.error('Failed to fetch profile', error);\n      }\n    };\n    fetchProfile();\n  }, []);\n\n  return (\n    \u003Cdiv>\n      {profile ? (\n        \u003Ch1>Welcome, {profile.name}!\u003C/h1>\n      ) : (\n        \u003Cp>Loading...\u003C/p>\n      )}\n    \u003C/div>\n  );\n}\n```\n\n**Step 4: 認証の検証（Rails側）**\n\nRails側では、認証が必要なコントローラーに`before_action :require_login_from_jwt`を追加します。\n\n```ruby\n# app/controllers/api/v1/profiles_controller.rb\nclass Api::V1::ProfilesController \u003C ApplicationController\n  before_action :require_login_from_jwt\n\n  def show\n    render json: current_user.to_json\n  end\nend\n```\n\nこれにより、リクエストヘッダーに有効なJWTがCookieとして含まれているか自動で検証し、`current_user`がセットされます。無効な場合は401 Unauthorizedエラーが返されます。\n\nStep 2: マイグレーションファイルの追加\nリフレッシュトークンをデータベースに保存するためのテーブルを追加します。\n\n```bash\nrails g model refresh_token token:string user:references\n```\n\n```bash\nrails db:migrate\n```\n\nStep 3: JWT生成ロジックの変更\nJWTのペイロードに有効期限とJTIを含めるようにApplicationControllerを修正します。\n\n```ruby\n# app/controllers/application_controller.rb\n\nclass ApplicationController \u003C ActionController::API\n  include Sorcery::Controller\n  \n  # JWTのペイロードに含める情報を定義\n  def jwt_payload_for(user)\n    {\n      user_id: user.id,\n      exp: Time.now.to_i + 300, # アクセストークンを5分で期限切れに設定 (例)\n      jti: SecureRandom.uuid # 一意なJWT ID\n    }\n  end\n\n  def jwt_secret_key\n    Rails.application.credentials.jwt_secret_key\n  end\nend\n```\n\nStep 4: 認証コントローラーの修正\nログイン時に、アクセストークンとリフレッシュトークンの両方を発行し、Cookieに保存します。\n\n```ruby\n# app/controllers/api/v1/sessions_controller.rb\n\nclass Api::V1::SessionsController \u003C ApplicationController\n  def create\n    user = login(params[:email], params[:password])\n\n    if user\n      # 1. アクセストークンを発行\n      access_token = sorcery_login(user)\n      cookies.signed[:access_token] = {\n        value: access_token,\n        httponly: true,\n        secure: Rails.env.production?\n      }\n\n      # 2. リフレッシュトークンを生成し、DBとCookieに保存\n      refresh_token = user.refresh_tokens.create!(token: SecureRandom.uuid)\n      cookies.signed[:refresh_token] = {\n        value: refresh_token.token,\n        httponly: true,\n        secure: Rails.env.production?,\n        expires: 1.month.from_now # 1ヶ月後に期限切れ (例)\n      }\n      \n      render json: { message: 'Logged in successfully' }\n    else\n      render json: { error: 'Invalid email or password' }, status: :unauthorized\n    end\n  end\n\n  def destroy\n    sorcery_logout\n    # ログアウト時に両方のトークンを削除\n    cookies.delete(:access_token)\n    cookies.delete(:refresh_token)\n    render json: { message: 'Logged out successfully' }\n  end\nend\n```\n\nStep 5: リフレッシュエンドポイントの追加\nアクセストークンの期限が切れた場合に、新しいトークンを発行するためのエンドポイントを作成します。\n\n```ruby\n# app/controllers/api/v1/token_refreshes_controller.rb\n\nclass Api::V1::TokenRefreshesController \u003C ApplicationController\n  def create\n    refresh_token = cookies.signed[:refresh_token]\n    \n    # Cookieからリフレッシュトークンを取得し、有効性を検証\n    if refresh_token_record = RefreshToken.find_by(token: refresh_token)\n      user = refresh_token_record.user\n      \n      # 新しいアクセストークンを発行\n      access_token = sorcery_login(user)\n      cookies.signed[:access_token] = {\n        value: access_token,\n        httponly: true,\n        secure: Rails.env.production?\n      }\n\n      render json: { message: 'Access token refreshed successfully' }\n    else\n      render json: { error: 'Invalid refresh token' }, status: :unauthorized\n    end\n  end\nend\n```\n\nStep 6: ルーティングの追加\nconfig/routes.rbにリフレッシュトークン用のエンドポイントを追加します。\n\n```ruby\n# config/routes.rb\n\nRails.application.routes.draw do\n  namespace :api do\n    namespace :v1 do\n      resources :sessions, only: [:create] do\n        delete :destroy, on: :collection\n      end\n      resources :token_refreshes, only: [:create]\n    end\n  end\nend\n```\n\n2. Next.js (フロントエンド) のセットアップ\nStep 1: APIクライアントの設定\naxiosのインターセプターを使って、アクセストークンの期限切れを自動的に検知し、リフレッシュトークンを使って新しいアクセストークンを取得するロジックを実装します。\n\n```javascript\n// utils/api.js\n\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'http://localhost:3000/api/v1',\n  withCredentials: true,\n});\n\n// リクエストが送信される前に実行されるインターセプター\napi.interceptors.request.use((config) => {\n  // ここでは特に何もしない。Cookieはブラウザが自動で添付\n  return config;\n}, (error) => {\n  return Promise.reject(error);\n});\n\n// レスポンスが返された後に実行されるインターセプター\napi.interceptors.response.use((response) => {\n  return response;\n}, async (error) => {\n  const originalRequest = error.config;\n  \n  // アクセストークンの期限切れエラー（401）かつ、リトライがまだの場合\n  if (error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      // リフレッシュトークンを使って新しいアクセストークンをリクエスト\n      await axios.post('http://localhost:3000/api/v1/token_refreshes', null, { withCredentials: true });\n      // 新しいアクセストークンで元のリクエストを再試行\n      return api(originalRequest);\n    } catch (refreshError) {\n      // リフレッシュトークンも無効な場合、ログアウト処理を行う\n      console.error('Refresh token failed:', refreshError);\n      // ユーザーをログインページにリダイレクトするなど\n      window.location.href = '/login';\n      return Promise.reject(refreshError);\n    }\n  }\n\n  return Promise.reject(error);\n});\n\nexport default api;\n```\n\nStep 2: ログイン処理の実装\nログインフォームのコードは前回と同じです。ブラウザが自動的に2つのCookieを保存します。\n\nこの仕組みにより、ユーザーは長期間ログイン状態を維持でき、同時にセキュリティ上のリスクも軽減できます。","src/content/docs/railsガイド/04_上級・最適化/APIモード(認証認可).mdx","1f9edccbcf65de9c","railsガイド/04_上級最適化/n1問題",{"id":1389,"data":1391,"body":1396,"filePath":1397,"digest":1398,"deferredRender":16},{"title":1392,"editUrl":16,"head":1393,"template":18,"sidebar":1394,"pagefind":16,"draft":20},"N+1問題",[],{"hidden":20,"attrs":1395},{},"## N+1問題とは\nN+1問題とは、データベースからデータを取得する際に発生するパフォーマンスの問題です。特に、関連するデータを繰り返し取得するループ処理でよく見られます。この問題は、1つの親レコードを取得するクエリ（1クエリ）と、その親レコードに紐づくN個の子レコードをそれぞれ取得するクエリ（Nクエリ）が合計でN+1回のクエリを発行してしまうことから、その名がつけられました。\n\n### N+1問題の発生例\nRailsのActive RecordでN+1問題が発生する典型的な例を見てみましょう。\n\nUserモデルとPostモデルがあり、Userが複数のPostを持っているとします。\n\n```ruby\nclass User \u003C ApplicationRecord\n  has_many :posts\nend\n\nclass Post \u003C ApplicationRecord\n  belongs_to :user\nend\n```\n\nユーザーの一覧ページで、各ユーザーの最新の投稿タイトルを表示したい場合、以下のようなコードを書くかもしれません。\n\n```erb\n\u003C% @users.each do |user| %>\n  \u003Cp>ユーザー名: \u003C%= user.name %>\u003C/p>\n  \u003Cp>最新の投稿: \u003C%= user.posts.last.title %>\u003C/p>\n\u003C% end %>\n```\n\nこのコードでは、以下のクエリが実行されます。\n\n- 1クエリ: `@users`を取得するために1つのクエリが発行されます。\n  ```sql\n  SELECT * FROM users;\n  ```\n\n- Nクエリ: ループ内で`user.posts.last`が呼び出されるたびに、そのユーザーに紐づく投稿を取得するクエリが発行されます。ユーザーがN人いれば、N個のクエリが発行されます。\n  ```sql\n  SELECT * FROM posts WHERE user_id = 1;\n  SELECT * FROM posts WHERE user_id = 2;\n  ...\n  ```\n\n結果として、合計N+1回のクエリが発行され、データベースへの負荷が増加し、アプリケーションのパフォーマンスが低下します。\n\n## 解決策\nN+1問題を解決する最も一般的な方法は、**関連データを事前に読み込む（Eager Loading）**ことです。これにより、必要なデータを少ないクエリ数でまとめて取得できます。\n\n### includesメソッドの使用\n`includes`メソッドは、関連データを事前にロードするための最も一般的な方法です。\n\n```ruby\n# before\n@users = User.all\n\n# after\n@users = User.includes(:posts)\n```\n\nこの変更により、以下の2つのクエリのみが実行されます。\n\n```sql\nSELECT * FROM users;\nSELECT * FROM posts WHERE user_id IN (1, 2, 3, ...);\n```\n\n`includes`は、ユーザーに紐づくすべての投稿を一度に取得するため、ループ内の`user.posts`が呼ばれても新たなクエリは発行されません。これにより、クエリ数が劇的に減少し、パフォーマンスが大幅に向上します。\n\n## 開発時の注意点\n- **Bullet Gem**: 開発中に N+1 問題を自動的に検知し、警告を出してくれるBullet Gemは非常に便利です。\n- **ログの確認**: 開発中は、`log/development.log`を確認し、不必要なクエリが発行されていないかを常にチェックする習慣をつけましょう。\n\nこれらの対策を講じることで、データベースへの負荷を最小限に抑え、Railsアプリケーションのパフォーマンスを最適化できます。\n\n## N+1問題の解決によるパフォーマンスの向上\nN+1問題が解決されると、データベースへのクエリ数がN+1から2に減少します。これにより、以下のメリットが得られます。\n\n- **データベース負荷の軽減**: サーバーはデータベースと何度も通信する必要がなくなるため、データベースサーバーへの負荷が大幅に軽減されます。\n- **応答速度の向上**: クエリの数が減ることで、ページの読み込み時間が短縮されます。特に、Nの値（取得する関連データの数）が大きいほど、パフォーマンス改善の効果は顕著になります。\n\n### 例：ユーザーが100人いる場合\nユーザーが100人いるページで、各ユーザーの最新の投稿を取得するケースを考えます。\n\n- **N+1問題が発生している場合**:\n  - ユーザー取得クエリ: 1回\n  - 投稿取得クエリ: 100回\n  - 合計クエリ数: 101回\n\n- **includesを使って解決した場合**:\n  - ユーザー取得クエリ: 1回\n  - 投稿取得クエリ: 1回（すべての投稿をまとめて取得）\n  - 合計クエリ数: 2回\n\nこの場合、データベースへのアクセス回数は約50分の1に減少し、ページの表示速度は数倍から数十倍に向上する可能性があります。\n\nクエリ数が101回から2回になるというだけでも、パフォーマンス改善の効果がいかに大きいかが分かります。アプリケーションの規模が大きくなればなるほど、この差はさらに広がり、ユーザーエクスペリエンスに大きな影響を与えます。","src/content/docs/railsガイド/04_上級・最適化/N+1問題.mdx","06d5722cc3dad7c2","railsガイド/04_上級最適化/active_job",{"id":1399,"data":1401,"body":1406,"filePath":1407,"digest":1408,"deferredRender":16},{"title":1402,"editUrl":16,"head":1403,"template":18,"sidebar":1404,"pagefind":16,"draft":20},"active_job",[],{"hidden":20,"attrs":1405},{},"Active Job\nActive Jobは、Railsアプリケーションでジョブ（時間のかかる処理）をキューに入れて、非同期的に実行するためのフレームワークです。これにより、ユーザーのリクエストに対するレスポンスを素早く返し、ユーザーエクスペリエンスを向上させることができます。\n\nなぜActive Jobを使うのか？\nウェブアプリケーションには、ユーザーの応答を待たずにバックグラウンドで処理すべきタスクが数多くあります。例えば、以下のような処理です。\n\nメール送信: ユーザー登録後のウェルカムメール送信など。\n\n画像・動画の処理: アップロードされた画像のサムネイル生成など。\n\n外部APIへのリクエスト: 外部サービスとのデータ同期など。\n\nこれらの処理をリクエストと同時に実行すると、ユーザーは処理が完了するまで待つことになり、ページの読み込みが遅くなります。Active Jobは、これらのタスクを「ジョブ」として扱い、後で実行することで、ウェブサーバーの負荷を軽減し、ユーザーへのレスポンスタイムを短縮します。\n\nジョブの作成と実行\nジョブの生成:\n以下のコマンドでジョブを作成します。\n\nBash\n\nrails generate job GuestSignup\nこのコマンドはapp/jobs/guest_signup_job.rbというファイルを生成します。\n\nジョブの定義:\n生成されたファイルに、実行したい処理をperformメソッド内に記述します。\n\nRuby\n\n# app/jobs/guest_signup_job.rb\n\nclass GuestSignupJob \u003C ApplicationJob\n  queue_as :default\n\n  def perform(guest)\n    # ゲストユーザーにウェルカムメールを送信\n    GuestMailer.welcome_email(guest).deliver_now\n  end\nend\nジョブのキューへの追加:\nコントローラーやモデルからperform_laterメソッドを呼び出して、ジョブをキューに追加します。\n\nRuby\n\n# app/controllers/guests_controller.rb\n\ndef create\n  @guest = Guest.new(guest_params)\n  if @guest.save\n    # ジョブをキューに追加\n    GuestSignupJob.perform_later(@guest)\n    redirect_to @guest, notice: 'ユーザー登録が完了しました。'\n  else\n    render :new\n  end\nend\nジョブの実行環境とSidekiq\nActive Jobは、ジョブを実際に実行するためのバックエンド（ジョブアダプター）を切り替えることができます。\n\nasyncアダプター: デフォルトのアダプターで、開発環境で手軽に非同期処理を試すことができます。ただし、プロセスが終了するとキューがクリアされるため、本番環境での利用は推奨されません。\n\nSidekiq: 本番環境で最もよく使われるアダプターの一つです。Redisをバックエンドに使い、マルチスレッドで動作するため、高いスループットと低メモリ消費が特徴です。\n\nSidekiqの導入手順\nGemの追加:\nGemfileに以下の行を追加し、bundle installを実行します。\n\nRuby\n\n# Gemfile\ngem 'sidekiq'\nアダプターの設定:\nconfig/application.rbに、Active JobのアダプターとしてSidekiqを設定します。\n\nRuby\n\n# config/application.rb\nconfig.active_job.queue_adapter = :sidekiq\nSidekiqの起動:\nRedisをインストールし、ターミナルで以下のコマンドを実行してSidekiqプロセスを起動します。\n\nBash\n\nbundle exec sidekiq\nこのように、Active JobとSidekiqを組み合わせることで、アプリケーションの要件に合わせて、スケーラブルで堅牢な非同期処理を実装することが可能になります。","src/content/docs/railsガイド/04_上級・最適化/active_job.mdx","5e940431b8f69ffe","railsガイド/04_上級最適化/sidekiq",{"id":1409,"data":1411,"body":1416,"filePath":1417,"digest":1418,"deferredRender":16},{"title":1412,"editUrl":16,"head":1413,"template":18,"sidebar":1414,"pagefind":16,"draft":20},"sideKiq",[],{"hidden":20,"attrs":1415},{},"Sidekiqとは\nSidekiqは、Active Jobが利用できるジョブアダプターの一つで、Rubyで書かれた高性能なバックグラウンド処理システムです。特に、大規模なRailsアプリケーションで広く採用されています。\n\nSidekiqの特徴\nRedisをバックエンドとして使用: SidekiqはRedisというインメモリデータベースをジョブキューとして利用します。これにより、ジョブの追加や取得が高速に行われます。\n\nマルチスレッドアーキテクチャ: 従来のプロセスベースのワーカーと異なり、Sidekiqはマルチスレッドで動作します。これにより、1つのプロセス内で複数のジョブを同時に処理できるため、メモリ使用量を抑えつつ高いスループットを実現します。\n\n豊富な機能: Sidekiqには、ジョブの失敗時のリトライ機能、ジョブの実行状況を監視できるウェブUI、スケジューリング機能などが備わっています。\n\nSidekiqの導入手順\nGemの追加:\nGemfileに以下の行を追加し、bundle installを実行します。\n\nRuby\n\n# Gemfile\ngem 'sidekiq'\nアダプターの設定:\nconfig/application.rbに、Active JobのアダプターとしてSidekiqを設定します。\n\nRuby\n\n# config/application.rb\nconfig.active_job.queue_adapter = :sidekiq\nSidekiqの起動:\nRedisをインストールし、ターミナルで以下のコマンドを実行してSidekiqプロセスを起動します。\n\nBash\n\nbundle exec sidekiq\nこれにより、アプリケーションの要件に合わせて、スケーラブルで堅牢な非同期処理を実装することが可能になります。","src/content/docs/railsガイド/04_上級・最適化/sideKiq.mdx","f97dafb4866e3af6","railsガイド/04_上級最適化/セキュリティ",{"id":1419,"data":1421,"body":1426,"filePath":1427,"digest":1428,"deferredRender":16},{"title":1422,"editUrl":16,"head":1423,"template":18,"sidebar":1424,"pagefind":16,"draft":20},"セキュリティ",[],{"hidden":20,"attrs":1425},{},"## 🛡️ Rails セキュリティガイド\n\nRailsは、デフォルトで多くのセキュリティ対策が施されていますが、開発者が意識すべき重要なポイントを理解することが不可欠です。\n\n### 🚫 CSRF（クロスサイト・リクエスト・フォージェリ）対策\n\nCSRFは、悪意のあるサイトを経由して、ユーザーが意図しないリクエストを正規のサイトに送信させる攻撃です。\n\n**protect_from_forgery メソッドの仕組み**\n\nRailsのコントローラーで`protect_from_forgery with: :exception`が設定されていると、Railsは各フォームに真正性トークン（authenticity token）を埋め込みます。\n\n- ✅ **正常なリクエスト**: フォームからリクエストが送信されると、Railsは送られてきたトークンとサーバー側のセッションに保存されたトークンが一致するか検証します。一致すれば処理が続行されます。\n- 🚨 **悪意あるリクエスト**: 悪意のあるサイトからのリクエストには、このトークンが含まれていないか、無効なトークンが送られます。Railsはトークンが一致しないことを検知し、リクエストを拒否します。\n\nこれが`protect_from_forgery`の主要な役割であり、CSRF攻撃からアプリを守るための最も重要な防衛策です。\n\n### 🎨 XSS（クロスサイト・スクリプティング）対策\n\nXSSは、Webページに悪意のあるスクリプトを埋め込み、そのスクリプトを他のユーザーのブラウザで実行させる攻撃です。\n\n**エスケープ処理の自動化**\n\nRailsのERBテンプレートでは、`\u003C%= ... %>`を使用して変数を表示する際、HTMLエスケープが自動的に行われます。これにより、ユーザーが入力した悪意のあるスクリプトタグ（例: `\u003Cscript>alert('XSS!')\u003C/script>`)は、単なる文字列として扱われ、実行されることはありません。\n\n`\u003C%= @user.name %>` → `&lt;script&gt;alert('XSS!')&lt;/script&gt;`\n\n**rawとhtml_safeの使用注意**\n\n- ⚠️ **rawヘルパー**: 自動エスケープを無効にし、HTMLタグをそのまま出力します。信頼できるソースのHTML（例: Markdownから変換したテキスト）を表示する場合にのみ使用します。\n- ⚠️ **html_safeメソッド**: 文字列を「安全なHTML」としてマークし、エスケープを無効にします。これも信頼できる文字列にのみ使用すべきです。ユーザー入力に対して安易に使うと、XSSの脆弱性を生み出す原因となります。\n\n### 💻 SQLインジェクション対策\n\nSQLインジェクションは、ユーザー入力に悪意のあるSQL文を紛れ込ませて、データベースを不正に操作する攻撃です。\n\n**ActiveRecordの防御策**\n\nActiveRecordは、プレースホルダーを利用したクエリ生成をデフォルトで行うことで、SQLインジェクションを強力に防御します。\n\n- ❌ **悪い例（脆弱性あり）**: 文字列結合でSQLクエリを構築すると危険です。\n  ```ruby\n  User.where(\"name = '#{params[:name]}'\")\n  ```\n  `params[:name]`が `' or 1=1 --` の場合、全ユーザー情報が取得される可能性があります。\n\n- ✅ **良い例（安全な方法）**: プレースホルダーを使用します。\n  ```ruby\n  User.where(\"name = ?\", params[:name])\n  ```\n  Railsは、`?`の部分に`params[:name]`の値を安全に埋め込みます。`' or 1=1 --` のような文字列は、`name`の値そのものとして扱われ、SQL文として解釈されることはありません。\n\n常にプレースホルダーやハッシュ形式（`User.where(name: params[:name])`）を使ってクエリを記述することで、安全なアプリケーションを構築できます。","src/content/docs/railsガイド/04_上級・最適化/セキュリティ.mdx","689643db244877f0","railsガイド/04_上級最適化/パフォーマンスチューニング",{"id":1429,"data":1431,"body":1435,"filePath":1436,"digest":1437,"deferredRender":16},{"title":328,"editUrl":16,"head":1432,"template":18,"sidebar":1433,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1434},{},"## キャッシュの利用\n\nRailsには、パフォーマンスを向上させるための複数のキャッシュ機能が用意されています。\n\n- **ページキャッシュ**: コントローラーのアクション全体をHTMLファイルとしてキャッシュします。これは、動的な要素が少ない静的なページで特に有効です。\n\n- **フラグメントキャッシュ**: ビューの特定の部分（フラグメント）をキャッシュします。これにより、ページの大部分がキャッシュされ、動的な部分だけがレンダリングされるため、動的なコンテンツを含むページで有効です。\n\n```ruby\n# フラグメントキャッシュの例\n\u003C% cache 'products_list' do %>\n  \u003Cul>\n    \u003C% @products.each do |product| %>\n      \u003Cli>\u003C%= product.name %>\u003C/li>\n    \u003C% end %>\n  \u003C/ul>\n\u003C% end %>\n```\n\n- **オブジェクトキャッシュ**: ビューやコントローラーで頻繁にアクセスされるオブジェクトをキャッシュします。\n\n## データベースの最適化\n\nデータベースは、アプリケーションのパフォーマンスボトルネックになりがちな部分です。\n\n- **インデックス**: 検索や結合のパフォーマンスを向上させるために、頻繁にクエリされるカラムにインデックスを設定します。`db/migrate`ファイルで`add_index`を使ってインデックスを追加します。\n\n- **N+1問題の解決**: `includes`、`preload`、`eager_load`などを使用して、関連するデータをまとめて事前に読み込みます。これにより、データベースへのクエリ回数を削減し、パフォーマンスを大幅に向上させることができます。\n\n```ruby\n# N+1問題の例\n# Bad: ループ内でクエリが発生\nUser.all.each do |user|\n  puts user.posts.count\nend\n\n# Good: `includes`で関連データをまとめて読み込み\nUser.includes(:posts).each do |user|\n  puts user.posts.count\nend\n```\n\n## 非同期処理の導入\n\n時間のかかる処理（例: メール送信、画像処理、外部APIへのリクエスト）は、ユーザーリクエストとは別にバックグラウンドで実行することで、レスポンスタイムを改善できます。\n\n- **Active Job**: Railsの組み込み機能で、様々なジョブキュー（Sidekiq、Resqueなど）と連携できます。\n\n## ロギングとモニタリング\n\nパフォーマンス問題の特定には、アプリケーションの挙動を詳細に把握することが不可欠です。\n\n- **ログの分析**: Railsのログ（`log/development.log`や`log/production.log`）には、各リクエストにかかった時間やデータベースクエリの詳細が記録されています。これを分析することで、パフォーマンスのボトルネックを特定できます。\n\n- **外部ツール**: New RelicやScout APMなどのアプリケーションパフォーマンスモニタリング（APM）ツールを利用すると、ボトルネックの特定やパフォーマンスの可視化が容易になります。\n\n## その他の最適化\n\n- **アセットパイプライン**: JavaScriptやCSSを圧縮・結合することで、リクエスト数を減らし、ページの読み込み速度を向上させます。\n\n- **HTTP/2の利用**: 複数のリソースを同時にダウンロードできるため、アセットの読み込み速度が向上します。\n\n- **キャッシュ戦略の最適化**: キャッシュは効果的ですが、適切に設定しないと古くなった情報を提供してしまうことがあります。キャッシュキーを動的に設定することで、データの更新時にキャッシュが自動的に無効化されるようにします。\n\n- **依存関係に基づくキャッシュキー**: `cache`ヘルパーにモデルオブジェクトを渡すと、Railsは自動的にモデル名/id-updated_atのような形式のキャッシュキーを生成します。データが更新されると`updated_at`タイムスタンプが変わるため、キャッシュが自動的に無効化されます。\n\n```ruby\n\u003C% @products.each do |product| %>\n  \u003C% cache product do %>\n    \u003Cli>\u003C%= product.name %>\u003C/li>\n  \u003C% end %>\n\u003C% end %>\n```\n\n## データベースコネクションプールの調整\n\nアプリケーションがデータベースに接続する際のコネクション数もパフォーマンスに影響します。特に、多数の同時リクエストを処理する場合、コネクションプールを適切に設定することが重要です。\n\n`database.yml`ファイルで、`pool`の値をアプリケーションのニーズに合わせて調整します。デフォルトは5ですが、リクエスト数に応じて増やすことを検討してください。ただし、あまりに大きな値を設定すると、データベースサーバーに負荷がかかるため注意が必要です。\n\n```yaml\n# config/database.yml\ndefault: &default\n  adapter: postgresql\n  encoding: unicode\n  pool: \u003C%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %>\n```\n\n## メモリの最適化\n\nアプリケーションのメモリ使用量を削減することも、パフォーマンス向上に繋がります。\n\n- **オブジェクト生成の抑制**: 不要なオブジェクトの生成を避けます。例えば、`select`メソッドで必要なカラムのみを読み込むことで、メモリ使用量を削減できます。\n\n```ruby\n# すべてのカラムを読み込む\n@users = User.all\n\n# 必要なカラムのみを読み込む\n@users = User.select(:id, :name)\n```\n\n- **ガーベージコレクションのチューニング**: Rubyのガーベージコレクション（GC）は、デフォルトで最適な設定になっていますが、特定の条件下では手動で調整することも可能です。ただし、これは高度なテクニックであり、安易な変更はかえってパフォーマンスを悪化させる可能性があるため、慎重に行う必要があります。\n\n## フロントエンドの最適化\n\nRailsアプリケーションはバックエンドのパフォーマンスだけでなく、フロントエンドのパフォーマンスも重要です。\n\n- **画像の最適化**: 画像を圧縮したり、WebPなどの最新の画像フォーマットを使用したりすることで、ページの読み込み速度を大幅に改善できます。\n\n- **非同期読み込み**: JavaScriptやCSSファイルを`async`や`defer`属性を使って非同期で読み込むことで、ページのレンダリングをブロックしないようにします。","src/content/docs/railsガイド/04_上級・最適化/パフォーマンスチューニング.mdx","2ceadc38007b2cfe","fastapiガイド/05_学び記事/使い方/技術詳細",{"id":1438,"data":1440,"body":1445,"filePath":1446,"digest":1447,"deferredRender":16},{"title":1441,"editUrl":16,"head":1442,"template":18,"sidebar":1443,"pagefind":16,"draft":20},"技術詳細",[],{"hidden":20,"attrs":1444},{},"FastAPIの技術詳細を以下に示します。\n\n## エラーハンドリング\n\nFastAPIは、カスタムエラーハンドラーをサポートしています。これにより、特定のエラーに対してカスタムレスポンスを返すことができます。\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.exception_handler(HTTPException)\nasync def custom_http_exception_handler(request, exc):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": f\"Oops! {exc.detail}\"},\n    )\n```","src/content/docs/fastapiガイド/05_学び記事/使い方/技術詳細.mdx","5b1c5e2103d9ecaf","nodejsガイド/03_中級/test/07_testing_automation",{"id":1448,"data":1450,"body":1455,"filePath":1456,"digest":1457,"deferredRender":16},{"title":1451,"editUrl":16,"head":1452,"template":18,"sidebar":1453,"pagefind":16,"draft":20},"テストの自動化",[],{"hidden":20,"attrs":1454},{},"## Node.jsにおけるテスト自動化：Jestの活用\n\nNode.jsのプロジェクトでは、Jestがテスト自動化のための主要なツールとして広く採用されています。Jestは、アサーション、モック、テスト実行、カバレッジレポートといった機能をすべて内包した「オールインワン」のテストフレームワークです。\n\n### 1. Jestの基本的な使い方\n\nJestをプロジェクトに導入するのは非常に簡単です。\n\n- **インストール**: 開発依存としてJestをインストールします。\n\n```bash\nnpm install --save-dev jest\n```\n\n- **package.jsonの設定**: package.jsonの\"scripts\"にテストコマンドを追加します。\n\n```json\n\"scripts\": {\n  \"test\": \"jest\"\n}\n```\n\n- **テストファイルの作成**: テスト対象のコード（例: sum.js）に対して、sum.test.jsのようなテストファイルを作成し、test関数とexpectアサーションを使ってテストを書きます。\n\n```javascript\n// sum.test.js\nconst sum = require('./sum');\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n```\n\n- **テストの実行**: `npm test`コマンドを実行するだけで、テストが自動的に検出・実行されます。\n\n### 2. Viteなどのビルドツールとの関係性\n\nNode.jsのバックエンドアプリケーションのテストには、通常、ViteやWebpackのようなビルドツールは必要ありません。これは、Node.jsがサーバー上で直接JavaScriptを実行するからです。これらのツールは主に、ブラウザ環境向けのフロントエンドコードをバンドル、トランスパイル、および最適化するために使われます。\n\n### 3. 応用的なテスト手法\n\nJestは、基本的なテストだけでなく、より高度なテスト手法をサポートしています。\n\n- **モックとスパイ**: データベースアクセスや外部API呼び出しといった、テストが困難な依存関係を模擬するために使います。\n  - **モック**: `jest.mock()`や`jest.fn()`を使って、実際の関数を偽の関数に置き換えます。これにより、特定のロジックを分離してテストできます。\n  - **スパイ**: `jest.spyOn()`を使って、実際の関数を呼び出しつつ、その呼び出し状況（引数や回数など）を監視します。\n\n- **スナップショットテスト**: 複雑な出力（例: UIコンポーネントのDOM構造やAPIレスポンスのスキーマ）をテストする際に役立ちます。Jestが最初の実行時に出力をキャプチャし、以降の実行でその出力が意図せず変更されていないかを確認します。\n\n- **テストカバレッジ**: Jestは組み込みでテストカバレッジレポートを生成する機能を持っています。`jest --coverage`コマンドを実行すると、コードベースのどの部分がテストによってカバーされているかを視覚的に確認でき、品質向上のための指針となります。\n\n- **TypeScriptのサポート**: ほとんどのNode.jsプロジェクトで使われているTypeScriptを、Jestはネイティブでサポートしています。`ts-jest`のようなプリセットを使うことで、TypeScriptのコードを簡単にテストできます。\n\nこれらの機能を活用することで、Node.jsアプリケーションの品質と信頼性を大幅に高めることができます。","src/content/docs/node.jsガイド/03_中級/test/07_testing_automation.mdx","86e05dd05e3bd0ea","nodejsガイド/03_中級/test/mock",{"id":1458,"data":1460,"body":1465,"filePath":1466,"digest":1467,"deferredRender":16},{"title":1461,"editUrl":16,"head":1462,"template":18,"sidebar":1463,"pagefind":16,"draft":20},"mockについて",[],{"hidden":20,"attrs":1464},{},"## モック（mock）について\n\nテストにおける**モック（mock）**は、実際のオブジェクトの振る舞いを模倣（シミュレート）するために使われる、偽のオブジェクトです。モックを使うことで、依存関係を持つコンポーネントを隔離してテストできます。\n\n### モックの目的と使い方\n\nモックの主な目的は、テスト対象のコンポーネントが依存している外部サービスや関数を、テスト実行中に制御可能にすることです。これにより、以下のようなメリットが得られます。\n\n- **分離テスト**: データベースや外部APIなど、実際の環境に依存する処理を置き換えることで、ネットワークの遅延や外部サービスのダウンといった影響を受けずに、テスト対象のロジックを単体でテストできます。\n- **結果の制御**: 外部サービスが返すはずの「特定のデータ」や「エラー」といった結果を、テストのシナリオに合わせて自由に設定できます。これにより、正常系だけでなく、様々なエラーケースやエッジケースのテストも容易になります。\n- **高速化**: 実際のI/O処理（例：ファイルの読み書き）をスキップするため、テストの実行時間を大幅に短縮できます。\n\n### 例：Jestでのモックの使い方\n\nNode.jsのJestフレームワークでは、`jest.mock()`や`jest.fn()`を使ってモックを簡単に作成できます。\n\n```javascript\n// 実際の外部APIを呼び出す関数\nconst axios = require('axios');\nconst fetchUserData = async (userId) => {\n  const response = await axios.get(`https://api.example.com/users/${userId}`);\n  return response.data;\n};\n\n// テストファイル\ntest('ユーザーデータを正しく取得できること', async () => {\n  // 1. axiosモジュール全体をモック化\n  jest.mock('axios');\n\n  // 2. モックした関数の戻り値を設定\n  axios.get.mockResolvedValue({\n    data: { id: 1, name: 'John Doe' }\n  });\n\n  // 3. テスト対象の関数を実行\n  const userData = await fetchUserData(1);\n\n  // 4. 検証（モックされた戻り値が使われていることを確認）\n  expect(userData.name).toBe('John Doe');\n  expect(axios.get).toHaveBeenCalledWith('https://api.example.com/users/1');\n});\n```\n\nこの例では、axiosという外部依存をモックすることで、実際のネットワーク通信を行わずにテストを完結させています。`mockResolvedValue`で成功時の戻り値を、`mockRejectedValue`で失敗時の戻り値を設定できます。\n\n### モック、スタブ、スパイの違い\n\nテストにおける似た用語として、モック、スタブ（stub）、スパイ（spy）がありますが、それぞれ異なる役割を持っています。\n\n| 種類 | 目的 | 振る舞い |\n|------|------|----------|\n| スタブ | 関数呼び出しに対する決められた応答（決まった戻り値）を提供する。 | 元の関数を置き換え、テスト用の固定値を返す。 |\n| スパイ | 元の関数を実行させつつ、その呼び出し状況（引数、回数など）を記録・検証する。 | 元の関数の振る舞いを維持しながら、呼び出しを監視する。 |\n| モック | 偽のオブジェクト全体を作り、メソッド呼び出しとその検証の両方を行う。 | 元の関数を置き換え、テストの意図に合わせた戻り値を返すだけでなく、呼び出しの検証も担う。 |\n\n簡単に言えば、スタブは「この入力を受け取ったら、この出力を返す」というシンプルな役割を、スパイは「この関数が呼び出されたか」という事実を、そしてモックは「この関数がこの引数で呼び出され、この出力を返したか」という包括的な役割を果たします。多くのテストフレームワークでは、これらの機能を区別せず、mockという総称で扱っています。","src/content/docs/node.jsガイド/03_中級/test/mock.mdx","05eb32f3f1eed4e2","nodejsガイド/03_中級/test/spy",{"id":1468,"data":1470,"body":1475,"filePath":1476,"digest":1477,"deferredRender":16},{"title":1471,"editUrl":16,"head":1472,"template":18,"sidebar":1473,"pagefind":16,"draft":20},"spyについて",[],{"hidden":20,"attrs":1474},{},"## スパイ（Spy）とは\n\nスパイは、テスト対象の関数やメソッドの呼び出し状況を監視するためのツールです。スパイは、モック（Mock）やスタブ（Stub）とは異なり、元の関数の振る舞いを変更せずに、その呼び出しに関する情報を記録します。\n\n### スパイの主な機能\n\nスパイを使うと、以下の情報を検証できます。\n\n- **呼び出し回数**: 関数が何回呼び出されたか。\n- **呼び出し時の引数**: 関数がどの引数で呼び出されたか。\n- **呼び出し元**: 関数がどの場所から呼び出されたか。\n\nたとえば、ユーザー作成処理をテストする際に、実際にメールを送信する関数が正しく1回だけ呼び出されたかを確認したいとします。この場合、メール送信関数をスパイすることで、実際のメール送信は行わずに、呼び出しの事実だけを検証できます。\n\n### モック（Mock）との違い\n\nスパイと似た概念にモックがありますが、両者には明確な違いがあります。\n\n| スパイ (Spy) | モック (Mock) |\n|--------------|---------------|\n| **振る舞い** | 元の関数の振る舞いを維持する。 | 元の関数の振る舞いを置き換える。 |\n| **目的** | 呼び出し状況を検証する。 | 偽の振る舞いをシミュレートする。 |\n| **用途** | 外部との連携など、実際の処理は実行させたいが、その呼び出しを記録したい場合。 | 外部サービスやデータベースなど、テスト環境で実行したくない依存関係を置き換えたい場合。 |\n\n簡単に言うと、スパイは「本当に呼び出されたか？」を検証し、モックは「この依存関係がこの値を返したらどうなるか？」をシミュレートするものです。\n\n### Jestにおけるスパイの使い方\n\nJavaScriptのテストフレームワークJestは、`jest.spyOn()`メソッドを使ってスパイ機能を提供します。\n\n```javascript\n// 検証対象のモジュール\nconst MyService = {\n  logMessage: (message) => console.log(message),\n};\n\n// スパイの作成\nconst spy = jest.spyOn(MyService, 'logMessage');\n\n// スパイ対象の関数を呼び出す\nMyService.logMessage('テストメッセージ');\n\n// 呼び出し状況を検証する\nexpect(spy).toHaveBeenCalled(); // logMessageが呼び出されたか？\nexpect(spy).toHaveBeenCalledTimes(1); // 1回呼び出されたか？\nexpect(spy).toHaveBeenCalledWith('テストメッセージ'); // 指定の引数で呼び出されたか？\n\n// 後処理（重要）\nspy.mockRestore(); // スパイを解除し、元の関数に戻す\n```\n\nこのように、スパイはテストの正確性を高め、不要な副作用（例: 実際にデータベースに書き込むこと）を防ぎながら、ロジックの内部的な動作を詳細に検証するのに役立ちます。","src/content/docs/node.jsガイド/03_中級/test/spy.mdx","60a1fe5970e8781e","railsガイド/03_中級/testについて/capybara",{"id":1478,"data":1480,"body":1485,"filePath":1486,"digest":1487,"deferredRender":16},{"title":1481,"editUrl":16,"head":1482,"template":18,"sidebar":1483,"pagefind":16,"draft":20},"Capybara",[],{"hidden":20,"attrs":1484},{},"Capybara\nCapybaraは、ウェブアプリケーションの**受け入れテスト（E2Eテスト）**をRubyで書くためのツールです。ユーザーがブラウザで行う操作（ボタンのクリック、フォームへの入力など）をシミュレートし、その結果を検証できます。RSpecと組み合わせて使うのが一般的です。\n\nなぜCapybaraを使うのか？\nCapybaraは、実際のユーザー体験に近い形でアプリケーションが正しく機能するかを確認できます。自然言語に近いメソッドを使うため、テストコードが読みやすくなります。また、背後のドライバーを切り替えることで、テストコードを特定のブラウザに依存させない柔軟なテストが可能です。\n\nCapybaraの基本操作\nCapybaraのテストは、ユーザーの操作を模倣するメソッドで構成されます。\n\nvisit: 指定されたURLにアクセスします。\n\nfill_in: フォームのフィールドに値を入力します。\n\nclick_button: ボタンをクリックします。\n\nexpect(page).to have_content: ページに特定のテキストが存在するかを検証します。\n\nRuby\n\n# Capybaraの基本操作例\nvisit '/login'\nfill_in 'メールアドレス', with: 'test@example.com'\nfill_in 'パスワード', with: 'password'\nclick_button 'ログイン'\nexpect(page).to have_content 'ログインに成功しました。'\nRailsでのCapybara利用法\nGemのインストール:Gemfileの:testグループにcapybaraとselenium-webdriver（ブラウザ操作用）を追加し、bundle installを実行します。\n\nRSpecとの連携:spec/rails_helper.rbにrequire 'capybara/rspec'を追加することで、RSpecのテストファイル内でCapybara","src/content/docs/railsガイド/03_中級/testについて/capybara.mdx","3de319fe9097c9e3","railsガイド/03_中級/testについて/rspec",{"id":1488,"data":1490,"body":1495,"filePath":1496,"digest":1497,"deferredRender":16},{"title":1491,"editUrl":16,"head":1492,"template":18,"sidebar":1493,"pagefind":16,"draft":20},"rspec",[],{"hidden":20,"attrs":1494},{},"RSpec\nRSpecは、Rubyのテスティングフレームワークで、アプリケーションの振る舞いを記述・検証するために広く使われています。Railsでは、より読みやすく自然言語に近い形でテストコードを書けるため、多くの開発者に人気があります。\n\nなぜRSpecを使うのか？\nRSpecは、テストを「期待される振る舞い」として記述します。これにより、コードの意図が明確になり、テストコードがドキュメントとしても機能します。後からコードを読んだ人が、その機能の目的をすぐに理解できるようになります。\n\nRSpecの基本構造\nRSpecのテストコードは、以下の主要なブロックで構成されます。\n\ndescribe: テスト対象（クラスやメソッドなど）を記述します。\n\ncontext: 特定の状況や条件下での振る舞いを記述し、テストを細分化します。\n\nit: 1つの具体的なテストケース（「〜〜であること」）を記述します。\n\nこれらのブロックを組み合わせることで、人間が読んでも理解しやすいテストコードが書けます。\n\nRuby\n\n# テストコードの例\nRSpec.describe User do\n  # Userクラスの振る舞いを記述\n  context 'メールアドレスが有効な場合' do\n    # 特定の条件下での振る舞いを記述\n    it 'ユーザーは有効であること' do\n      # 1つの具体的なテストケース\n      user = User.new(email: 'test@example.com')\n      expect(user).to be_valid\n    end\n  end\nend\nRailsでのRSpec利用法\nRailsでは、rails generateコマンドでRSpecのテストファイルが自動生成されます。\n\nインストール:Gemfileにrspec-railsを追加し、bundle installを実行します。次に、rails generate rspec:installで初期設定を行います。\n\nテストファイルの生成:\nモデルやコントローラーを生成する際に--test-framework=rspecオプションを付けると、対応するRSpecファイルが自動で作成されます。\n\nRSpecの実行\n以下のコマンドでテストを実行できます。テスト結果は、成功すると緑色、失敗すると赤色で表示されます。\n\nBash\n\n# すべてのテストを実行\nbundle exec rspec\n# 特定のファイルを指定して実行\nbundle exec rspec spec/models/post_spec.rb","src/content/docs/railsガイド/03_中級/testについて/rspec.mdx","41ca1928fff4257a","railsガイド/03_中級/testについて/seederfactorybotについて",{"id":1498,"data":1500,"body":1505,"filePath":1506,"digest":1507,"deferredRender":16},{"title":1501,"editUrl":16,"head":1502,"template":18,"sidebar":1503,"pagefind":16,"draft":20},"Factory Bot",[],{"hidden":20,"attrs":1504},{},"## Factory Bot\nFactory Bot は、テストや開発で必要な**ダミーデータ（テストデータ）**を効率的に生成するための Gem です。\n\n### なぜ Factory Bot が必要か？\nテストを書く際、毎回手動で `User.new(...)` のようにオブジェクトを生成するのは非効率で、コードの重複も発生します。Factory Bot を使うと、テンプレートとなる「ファクトリ」を一度定義すれば、必要に応じて何度でも、ランダムな属性値を持つテストデータを生成できます。\n\n### 使い方\n\n#### ファクトリの定義\n`spec/factories/users.rb` のようなファイルに、モデルのファクトリを定義します。\n\n```ruby\nFactoryBot.define do\n  factory :user do\n    name { \"テストユーザー\" }\n    email { \"test-#{rand(100)}@example.com\" }\n    password { \"password\" }\n  end\nend\n```\n\n#### データの生成\nテストコード内で、定義したファクトリを使ってデータを生成します。\n\n```ruby\n# create メソッドでデータベースに保存\nuser = create(:user) \n\n# build メソッドで保存しないインスタンスを生成\nuser = build(:user)\n```\n\n### メリット\n- テストコードの可読性が向上し、テストデータの準備が簡単になります。\n- 関連付け（アソシエーション）を持つデータも簡単に生成できます。\n\n## Seeder（db/seeds.rb）\nSeeder は、アプリケーションの初期データやデモデータをデータベースに投入するための仕組みです。Rails の `db/seeds.rb` ファイルにデータ投入のロジックを記述し、`rails db:seed` コマンドで実行します。\n\n### なぜ Seeder が必要か？\n開発環境をセットアップする際や、デモ環境を構築する際に、アプリケーションが動作するために最低限必要なデータを手動で投入するのは手間がかかります。Seeder を使うと、これらのデータを自動化できます。\n\n### 使い方\n\n#### シードファイルの編集\n`db/seeds.rb` ファイルに、データ生成のコードを記述します。\n\n```ruby\n# シードデータが存在しない場合のみ作成\nunless User.find_by(email: \"admin@example.com\")\n  User.create!(\n    name: \"Admin User\",\n    email: \"admin@example.com\",\n    password: \"password\"\n  )\nend\n\n# 記事データを複数作成\n10.times do |i|\n  Post.create!(\n    title: \"テスト記事#{i+1}\",\n    content: \"これはテスト用の記事です。\",\n    user: User.first\n  )\nend\n```\n\n#### コマンドの実行\n以下のコマンドで、シードデータをデータベースに投入します。\n\n```bash\nrails db:seed\n```\n\n### メリット\n- 開発環境やデモ環境の構築が自動化されます。\n- チームメンバー間で一貫した初期データを持つことができます。\n\n## Factory Bot と Seeder の使い分け\n- **Factory Bot**: テスト用途に特化しています。各テストケースで独立した、予測可能なテストデータを生成するのに最適です。\n- **Seeder**: 開発環境やデモ環境の初期データを投入するのに使われます。一度だけ実行すればよい永続的なデータの作成に向いています。\n\nこれらのツールを適切に使い分けることで、Rails アプリケーションの開発サイクルをより効率的でスムーズにすることができます。","src/content/docs/railsガイド/03_中級/testについて/seeder・factorybotについて.mdx","1456edec9a880bfb","railsガイド/03_中級/testについて/実践編",{"id":1508,"data":1510,"filePath":1515,"digest":1516,"deferredRender":16},{"title":1511,"editUrl":16,"head":1512,"template":18,"sidebar":1513,"pagefind":16,"draft":20},"実践編",[],{"hidden":20,"attrs":1514},{},"src/content/docs/railsガイド/03_中級/testについて/実践編.mdx","4a3f05419d4bcd06","fastapiガイド/02_基本/mtvの書き方",{"id":1517,"data":1519,"body":1524,"filePath":1525,"digest":1526,"deferredRender":16},{"title":1520,"editUrl":16,"head":1521,"template":18,"sidebar":1522,"pagefind":16,"draft":20},"MTVについて",[],{"hidden":20,"attrs":1523},{},"## FastAPIにおけるMTVの考え方\n\nFastAPIは、WebアプリケーションのUIをサーバー側でレンダリングするのではなく、APIを提供することに特化しているため、MVC（Model-View-Controller）よりも**MTV（Model-Template-View）**の概念で役割を捉える方がより適切です。\n\n### MTVの各コンポーネント\n\n1. **Model（モデル）** 💾\n   - モデルはデータの構造とビジネスロジックを扱います。FastAPIでは、以下のものがモデルに相当します。\n   - **Pydanticモデル**: リクエストボディやレスポンスのデータの構造を定義し、自動的なデータ検証を行います。\n   - **ORM（SQLAlchemyなど）モデル**: データベースのテーブルとPythonオブジェクトをマッピングし、データベース操作を抽象化します。\n\n2. **Template（テンプレート）** 🖼️\n   - テンプレートは、HTMLやUIを指します。FastAPIは主にAPIサーバーとして機能するため、通常、テンプレートは使用しません。クライアント側（例：React、Vue.js）がUIを構築し、FastAPIのAPIからデータを取得します。このため、MTVの観点ではこのレイヤーは存在しないか、クライアントサイドの責務となります。\n\n3. **View（ビュー）** 🖥️\n   - ビューは、ユーザーからのリクエストを受け取り、モデルと連携して、最終的なレスポンスを返すロジックを担います。FastAPIにおいては、APIエンドポイント関数がこのビューに相当します。\n\n**主な役割:**\n\n- リクエストからパスパラメータやクエリパラメータを取得します。\n- データベースや外部サービスからデータを取得するロジックを呼び出します。\n- データの整合性を確認し、エラーを返します。\n- Pydanticモデルを使って、レスポンスの形式を定義・保証します。\n\n**例: Viewとしてのエンドポイント関数**\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom typing import List\n\n# 以下はモデルとサービスをインポートしていると仮定\nfrom .schemas import UserResponse\nfrom .services import get_user_from_db\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}\", response_model=UserResponse)\ndef get_user_view(user_id: int):\n    \"\"\"\n    ユーザー情報を取得するAPIエンドポイント。\n    この関数がViewの役割を担う。\n    \"\"\"\n    user = get_user_from_db(user_id) # モデルやサービスからデータを取得\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n```\n\n\nこの例では、`get_user_view`関数がユーザーIDを受け取り、サービスを介してデータを取得し、レスポンスを返す一連の処理を行っています。\n\n**例: FastAPI でテンプレートを読み込む例**\n```py\nfrom fastapi import FastAPI, Request\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi.responses import HTMLResponse\n\napp = FastAPI()\n\n# templatesディレクトリを指定\ntemplates = Jinja2Templates(directory=\"app/templates\")\n\n@app.get(\"/\", response_class=HTMLResponse)\ndef read_root(request: Request):\n    # index.html をレンダリング\n    return templates.TemplateResponse(\"index.html\", {\"request\": request, \"title\": \"Home\"})\n\n```\n## 📦 MTVに基づいたファイル構成\n\nMTVの考え方で整理すると、以下のようなディレクトリ構造になります。\n\n```\n.\n├── app/\n│   ├── __init__.py\n│   ├── main.py             # View (エンドポイント)\n│   ├── schemas/\n│   │   ├── __init__.py\n│   │   └── user.py         # Model (Pydanticモデル)\n│   └── services/\n│       ├── __init__.py\n│       └── db_service.py   # Model (データベース操作などのロジック)\n│       └── templates/      # Template(apiでは使用しない)\n│        ├── index.html\n│        └── user.html\n└── requirements.txt\n```\n\nこのように、Viewを担うエンドポイント関数、Modelを担うPydanticモデルやサービスロジックを明確に分けることで、アプリケーションの構造をよりシンプルに保つことができます。\n\n### 4. サービスレイヤーの導入 🛠️\n\nMTVモデルをさらに洗練させるために、ビジネスロジックをビュー（エンドポイント）から完全に分離するサービスレイヤーを導入することが推奨されます。これにより、コードの再利用性が高まり、テストが容易になります。\n\n**役割:** データベース操作、外部API呼び出し、複雑な計算など、エンドポイント関数が直接行うべきではない処理を担います。\n\n**メリット:**\n\n- **責務の分離**: ビュー関数はリクエストとレスポンスの処理に集中し、ビジネスロジックはサービスレイヤーに一任されます。\n- **再利用性**: 同じビジネスロジックを複数のエンドポイントやタスク（例：バックグラウンドジョブ）で共有できます。\n- **テストの容易性**: サービスレイヤーの関数は単独でテストできるため、単体テストの作成が簡単になります。\n\n**例: サービスレイヤーの導入**\n\n`app/services/user_service.py`\n\n```python\nfrom sqlalchemy.orm import Session\nfrom .. import models, schemas\n\ndef create_user_service(db: Session, user_data: schemas.UserCreate):\n    \"\"\"\n    ユーザー作成のビジネスロジック\n    \"\"\"\n    # ユーザーが既に存在するか確認\n    existing_user = db.query(models.User).filter_by(email=user_data.email).first()\n    if existing_user:\n        return None # ユーザーが既に存在する場合はNoneを返す\n    \n    # 新しいユーザーを作成し、データベースに保存\n    db_user = models.User(email=user_data.email, name=user_data.name)\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n```\n\nこの`create_user_service`関数は、データベースセッションを受け取り、ユーザー作成に関連するすべてのロジック（検証、保存など）を処理します。\n\n### 5. 依存性注入の活用（リファクタリング） 💉\n\nサービスレイヤーを導入する際、FastAPIの依存性注入を積極的に活用することで、ビューとサービスの連携が非常にスムーズになります。\n\n**役割:** ビュー関数がサービスインスタンスやデータベースセッションを直接作成するのではなく、依存性注入を通じてそれらを受け取るようにします。\n\n**メリット:**\n\n- **疎結合**: ビューは具体的なサービスの実装に依存せず、必要な機能だけを要求できます。\n- **テストのモック化**: テスト時に本物のデータベース接続ではなく、モックのサービスやセッションを簡単に注入できます。\n\n**例: サービスレイヤーと依存性注入の統合**\n\n`app/api/v1/endpoints/users.py`（ビューの再構築）\n\n```python\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom ...services import user_service\nfrom ...database import get_db\nfrom ...schemas import UserResponse, UserCreate\n\nrouter = APIRouter()\n\n@router.post(\"/users/\", response_model=UserResponse, status_code=201)\ndef create_new_user(user_data: UserCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    新しいユーザーを作成\n    \"\"\"\n    # 依存性注入を通じてサービス関数を呼び出す\n    created_user = user_service.create_user_service(db, user_data)\n    if created_user is None:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    return created_user\n```\n\nこのコードでは、`create_new_user`関数はデータベースセッションを`Depends`で受け取り、そのセッションを`user_service`に渡すだけです。これにより、エンドポイントは純粋なコントローラーとしての役割に集中できます。","src/content/docs/fastapiガイド/02_基本/MTVの書き方.mdx","641131b82b9d8ac9","nextjsガイド/02_基本/cookie",{"id":1527,"data":1529,"body":1533,"filePath":1534,"digest":1535,"deferredRender":16},{"title":671,"editUrl":16,"head":1530,"template":18,"sidebar":1531,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1532},{},"## 🍪 Next.jsにおけるCookie戦略\n\nNext.jsは、サーバーサイドとクライアントサイドの両方で動作するため、Cookieの扱い方も特別な考慮が必要です。Next.jsの最新のApp Routerでは、Web標準のAPIを利用してCookieを安全かつ効率的に扱えます。\n\n### 1. サーバーコンポーネントでのCookieの読み取り 🔐\n\nNext.jsのサーバーコンポーネントでは、`next/headers`から提供される`cookies()`関数を使って、リクエストヘッダーのCookieにアクセスできます。これはサーバーサイドで実行されるため、認証情報などの機密データを安全に扱えます。\n\n```typescript\n// app/dashboard/page.tsx\nimport { cookies } from 'next/headers';\n\nexport default function DashboardPage() {\n  const cookieStore = cookies();\n  const token = cookieStore.get('auth_token')?.value;\n\n  if (!token) {\n    // ユーザーをログインページにリダイレクト\n    return \u003Cdiv>ログインしていません。\u003C/div>;\n  }\n\n  // トークンを使ってサーバーサイドでデータを取得するロジック\n  // ...\n\n  return (\n    \u003Cdiv>\n      \u003Ch1>ダッシュボード\u003C/h1>\n      \u003Cp>ユーザー認証済み\u003C/p>\n    \u003C/div>\n  );\n}\n```\n\n- **注意**: `cookies()`関数は動的（dynamic）な関数であるため、これを使用するコンポーネントはビルド時に静的にレンダリングされず、リクエストごとにサーバーでレンダリングされます。\n\n### 2. Route Handler（APIルート）でのCookieの操作 🔧\n\nRoute Handler（`app/api/.../route.ts`）はサーバーサイドで動作するため、Cookieの読み書きに最適な場所です。リクエストからCookieを読み取り、レスポンスに新しいCookieを設定できます。\n\n#### Cookieの読み取り\n\n```typescript\n// app/api/user/route.ts\nimport { cookies } from 'next/headers';\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n  const cookieStore = cookies();\n  const token = cookieStore.get('auth_token');\n\n  if (!token) {\n    return NextResponse.json({ message: 'No token found' }, { status: 401 });\n  }\n\n  // トークンを使ってデータベースからユーザー情報を取得\n  // ...\n\n  return NextResponse.json({ user: '...' });\n}\n```\n\n#### Cookieの設定（Set-Cookieヘッダー）\n\n```typescript\n// app/api/login/route.ts\nimport { cookies } from 'next/headers';\nimport { NextResponse } from 'next/server';\n\nexport async function POST(req) {\n  // 認証ロジックを実行し、トークンを生成\n  const { username, password } = await req.json();\n  const token = 'generated_auth_token_123';\n\n  // Cookieを設定\n  cookies().set('auth_token', token, {\n    httpOnly: true, // JavaScriptからのアクセスを禁止\n    secure: process.env.NODE_ENV === 'production',\n    maxAge: 60 * 60 * 24 * 7, // 1週間\n    path: '/',\n    sameSite: 'strict',\n  });\n\n  return NextResponse.json({ message: 'Login successful' });\n}\n```\n\n- **httpOnly**: JavaScriptからのアクセスを防ぐため、XSS攻撃（クロスサイトスクリプティング）のリスクを軽減します。認証情報のような機密データには必須です。\n- **secure**: HTTPS接続でのみCookieを送信するように設定します。本番環境では必ず`true`に設定すべきです。\n\n### 3. クライアントコンポーネントでのCookieの読み書き 📖\n\nクライアントサイドでは、`js-cookie`や`universal-cookie`などのライブラリを使用してCookieを操作するのが一般的です。`document.cookie`を直接操作するのは煩雑でエラーを起こしやすいため推奨されません。\n\n- **注意**: クライアントコンポーネントからCookieを直接操作するのは、認証トークンのような機密情報には適していません。クライアントで読み取る必要がある設定情報やテーマ情報などに限定すべきです。\n\n### 4. まとめ：理想的な戦略 🗺️\n\nNext.jsでの理想的なCookie戦略は、サーバーとクライアントの役割を明確に分けることです。\n\n- **サーバーサイド（サーバーコンポーネント & Route Handler）**:\n  - 認証情報や機密データの読み書きはすべてサーバーサイドで行います。\n  - `cookies()`関数を使用して、安全かつ効率的にCookieを操作します。\n\n- **クライアントサイド（クライアントコンポーネント）**:\n  - 非機密データ（テーマ設定など）の読み書きに限定します。\n  - 状態管理ライブラリと組み合わせて、ユーザー体験を向上させます。\n  - 認証が必要な場合は、`fetch`を使ってAPIルートを呼び出し、Cookieの操作はサーバーに任せます。","src/content/docs/nextjsガイド/02_基本/cookie.mdx","35114e91fc380271","nextjsガイド/02_基本/csrssr",{"id":1536,"data":1538,"body":1542,"filePath":1543,"digest":1544,"deferredRender":16},{"title":827,"editUrl":16,"head":1539,"template":18,"sidebar":1540,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1541},{},"## 🔄 レンダリングの比較: CSR vs. SSR\n\nWebページのレンダリング方法には主に2つのアプローチがあります。Next.jsは、これら両方の利点を組み合わせることで、高速なパフォーマンスと優れた開発体験を提供します。\n\n### 1. クライアントサイドレンダリング (CSR) 🖥️\n\nCSRは、レンダリングをブラウザに任せる方式です。サーバーは最低限のHTMLとJavaScriptを送信し、データ取得やDOM構築はすべてクライアント（ブラウザ）で行われます。\n\n- **仕組み**: 最初に空のHTMLとJavaScriptの「シェル」が送られます。ブラウザはJavaScriptを実行し、APIからデータをフェッチして動的にコンテンツを生成します。\n\n- **利点**:\n  - 高速なページ遷移: 初回ロード後は、必要なデータだけをAPIで取得し、DOMを部分的に更新するため、ページ間の移動が非常に滑らかです。\n  - インタラクティブ: ユーザーの操作に応じて動的に変化するUI（例：フォーム入力、グラフ）の実装に適しています。\n\n- **欠点**:\n  - 初回表示までの遅延: JavaScriptとデータがすべてロードされるまで、ユーザーは何も表示されない「白い画面」を見ることになります。\n  - SEOへの影響: 検索エンジンのクローラーが初期に完全なコンテンツを取得できないため、SEOのパフォーマンスに影響する可能性があります。\n\n### 2. サーバーサイドレンダリング (SSR) 💻\n\nSSRは、レンダリングをサーバーで行う方式です。\n\n- **仕組み**: ユーザーからのリクエストに対して、サーバーがデータを取得し、完成したHTMLを生成してブラウザに送信します。ブラウザは受け取ったHTMLをすぐに表示し、その後、JavaScriptがロードされてインタラクティブな機能が追加されます（これをハイドレーションと呼びます）。\n\n- **利点**:\n  - 高速な初回表示: ユーザーはすぐにコンテンツを見ることができ、ユーザー体験が向上します。\n  - 優れたSEO: 検索エンジンのクローラーは完成したHTMLを受け取るため、コンテンツを正確にインデックスできます。\n\n- **欠点**:\n  - サーバー負荷: リクエストごとにサーバーがHTMLを生成するため、アクセス数が増えるとサーバーの負荷が高まります。\n  - ページ遷移: ページを移動するたびにサーバーが新しいHTMLを生成するため、CSRに比べると遷移が遅く感じることがあります。\n\n### 3. Next.jsにおけるハイブリッドレンダリング 🧩\n\nNext.jsの最新のApp Routerは、これらのレンダリング方法を組み合わせて利用するハイブリッドレンダリングを標準としています。\n\n- **サーバーコンポーネント (SSR)**: デフォルトでは、すべてのコンポーネントがサーバーでレンダリングされます。これにより、ページの大部分は高速に表示され、SEOに有利な状態が保たれます。\n\n- **クライアントコンポーネント (CSR)**: ユーザーインタラクションが必要なコンポーネントのみを'use client'ディレクティブでクライアントコンポーネントとしてマークします。これにより、フォーム、アニメーション、状態管理が必要な部分だけがCSRとして動作し、パフォーマンスとユーザー体験を両立させます。\n\nこのハイブリッドアプローチにより、開発者はページ全体をCSRにするかSSRにするかという二者択一から解放され、より効率的でパフォーマンスに優れたアプリケーションを構築できます。\n\n## 🔄 CSRとSSRのレンダリングフローを比較する図解\n\nクライアントサイドレンダリング（CSR）とサーバーサイドレンダリング（SSR）の主な違いは、誰がいつ、ページのコンテンツを生成するかです。この違いは、ページの表示速度、SEO、そしてサーバー負荷に影響します。Next.jsは、この両方のメリットを活かすハイブリッドレンダリングで、これらの問題を解決します。\n\n### 1. クライアントサイドレンダリング (CSR) 🖥️\n\nCSRでは、レンダリングの大部分をブラウザが担当します。サーバーは最小限のHTMLとJavaScriptの**「骨組み」**だけを送り、ブラウザがAPIからデータを取得してページを構築します。\n\n- **レンダリングフロー**:\n  1. ユーザーがリクエストを送る。\n  2. サーバーは空のHTMLとJavaScriptを送り返す。\n  3. ブラウザはHTMLを表示する。この時点ではまだコンテンツは表示されない。\n  4. ブラウザがJavaScriptをダウンロードし、実行を開始。\n  5. ブラウザはAPIからデータを取得する。\n  6. ブラウザが取得したデータを使ってDOMを構築し、ページにコンテンツが表示される。\n\n### 2. サーバーサイドレンダリング (SSR) 💻\n\nSSRでは、レンダリングをサーバーが担当します。サーバーがデータを取得し、完全にレンダリングされたHTMLをブラウザに送り返します。\n\n- **レンダリングフロー**:\n  1. ユーザーがリクエストを送る。\n  2. サーバーはページに必要なデータを取得し、完全にレンダリングされたHTMLを生成する。\n  3. サーバーはそのHTMLをブラウザに送り返す。\n  4. ブラウザはHTMLをすぐに表示する。この時点でコンテンツは見える状態になっている。\n  5. ブラウザがJavaScriptをダウンロードし、実行を開始（ハイドレーション）。これにより、ボタンのクリックなど、インタラクティブな機能が有効になる。\n\n### 3. Next.jsのハイブリッドレンダリング 🧩\n\nNext.jsは、CSRとSSRの長所を組み合わせることで、ハイブリッドレンダリングという最適なアプローチを提供します。\n\n- **サーバーコンポーネント (SSR)**: デフォルトでサーバーサイドレンダリングが行われます。これにより、初回ロードが速くなり、SEOに強くなります。\n\n- **クライアントコンポーネント (CSR)**: `use client`ディレクティブを使うことで、一部のコンポーネントだけをCSRとしてレンダリングできます。これにより、フォームやアニメーションなど、インタラクティブな要素を持つ部分だけをクライアントで動かし、不必要なサーバー負荷を軽減します。\n\nこのハイブリッドなアプローチによって、Next.jsはパフォーマンスとユーザー体験を高いレベルで両立させています。\n\n## 🔄 CSRとSSRの使い分け：具体的なシナリオ\n\nNext.jsのハイブリッドレンダリングは強力ですが、ページのどの部分をCSRにするか、SSRにするかを見極めることが重要です。一般的なアプリケーションの機能ごとに、最適なレンダリング方法を以下に示します。\n\n### 1. サーバーサイドレンダリング（SSR）が最適なシーン 💻\n\nSSRは、コンテンツが静的または頻繁に更新されるが、リアルタイム性は不要なページに最適です。\n\n- **ブログ記事やニュースサイト**:\n  - **理由**: 記事の内容は頻繁に変わりますが、すべてのユーザーに対して同じコンテンツを表示するため、リクエストごとにサーバーでレンダリングすることでSEOに強くなります。\n  - **実装**: `app/blog/[slug]/page.tsx` のようなサーバーコンポーネントで記事データをフェッチし、HTMLを生成します。\n\n- **ECサイトの商品詳細ページ**:\n  - **理由**: 商品情報（価格、在庫、説明）は常に最新である必要がありますが、SEOも重要です。クローラーが商品ページを正しくインデックスできるように、サーバーでレンダリングします。\n  - **実装**: `app/products/[id]/page.tsx`で商品IDを基にデータを取得し、ページをレンダリングします。\n\n- **プロフィールページやダッシュボードの初期表示**:\n  - **理由**: ユーザーがログインした後に最初に表示されるページは、認証情報に基づいてデータをサーバーで取得し、高速に表示させるのが良いでしょう。\n  - **実装**: ユーザーのトークンをCookieから読み取り、`app/dashboard/page.tsx`のようなサーバーコンポーネントでユーザー情報をフェッチします。\n\n### 2. クライアントサイドレンダリング（CSR）が最適なシーン 🖥️\n\nCSRは、ユーザーの操作に強く依存するインタラクティブなUIや、リアルタイム性が求められるコンポーネントに最適です。\n\n- **フォーム、モーダル、アニメーション**:\n  - **理由**: これらのUI要素は、ユーザーの入力やクリックに応じて動的に変化するため、JavaScriptによるクライアントサイドでの制御が必要です。\n  - **実装**: `app/form.tsx`のようなファイルで、'use client'ディレクティブを宣言し、`useState`や`useEffect`などのクライアントサイドのフックを使用します。\n\n- **検索フィルター、ソート機能**:\n  - **理由**: ユーザーが検索ボックスに文字を入力するたびに、サーバーにリクエストを送るのは非効率です。クライアントサイドで状態を管理し、APIリクエストを最適化する方が良いです。\n  - **実装**: `app/search.tsx`のようなクライアントコンポーネントで、検索クエリの状態を管理し、ユーザーの入力に応じてリアルタイムで結果を表示します。\n\n- **リアルタイムなデータ表示**:\n  - **理由**: 株価チャートやライブチャットなど、継続的にサーバーと通信してデータを更新する必要がある場合は、WebSocket通信やポーリングをクライアントコンポーネントで実装します。\n  - **実装**: 状態管理ライブラリ（Zustandなど）と組み合わせて、`use client`で宣言したコンポーネントでリアルタイムデータを扱います。\n\n### 3. ハイブリッドレンダリングの実践 🧩\n\nNext.jsでは、CSRとSSRを同じページで組み合わせることができます。\n\n- **ECサイトの商品詳細ページ**:\n  - **全体**: 商品情報（名前、価格、説明）は**サーバーコンポーネント（SSR）**でレンダリングし、高速な初回表示とSEOを確保します。\n  - **インタラクティブな部分**: 「カートに追加」ボタンや、ユーザーレビューの星評価コンポーネントは、'use client'を宣言した**クライアントコンポーネント（CSR）**として実装します。これにより、JavaScriptがロードされた後、これらの要素がインタラクティブになります。\n\nこのように、Next.jsは「初期表示とSEO」にはSSR、「ユーザーインタラクション」にはCSRを使い分けることで、最高のパフォーマンスと開発体験を実現します。\n\n## 🔄 CSRとSSRの使い分け：具体的な実装例\n\nNext.jsにおけるハイブリッドレンダリングの真価は、1つのページ内でサーバーコンポーネント（SSR）とクライアントコンポーネント（CSR）を組み合わせて使う点にあります。ここでは、その具体的なコード例として、ECサイトの商品詳細ページを題材に解説します。\n\n### 1. サーバーコンポーネント（SSR）: 商品情報の表示 💻\n\nこのコンポーネントはサーバーでレンダリングされ、SEOに有利な状態でユーザーに届きます。ここでは、データをフェッチし、静的なUIを生成する役割を担います。\n\n- **役割**: ユーザーリクエスト時に、URLのidから商品データを取得し、HTMLを生成する。\n- **使用例**: 商品名、価格、説明、画像など。\n\n```typescript\n// app/products/[id]/page.tsx\n// このファイルはデフォルトでサーバーコンポーネントです\n\nimport AddToCartButton from '@/components/AddToCartButton';\n\n// サーバーコンポーネント内で直接データを取得\nasync function getProduct(id: string) {\n  const res = await fetch(`https://api.example.com/products/${id}`);\n  return res.json();\n}\n\nexport default async function ProductPage({ params }: { params: { id: string } }) {\n  const product = await getProduct(params.id);\n\n  return (\n    \u003Cdiv className=\"container\">\n      {/* SEOに重要な部分をSSRでレンダリング */}\n      \u003Ch1 className=\"text-3xl font-bold\">{product.name}\u003C/h1>\n      \u003Cp className=\"text-2xl\">${product.price}\u003C/p>\n      \u003Cimg src={product.image_url} alt={product.name} />\n      \u003Cp>{product.description}\u003C/p>\n\n      {/* インタラクティブな部分はクライアントコンポーネントに任せる */}\n      \u003CAddToCartButton productId={product.id} />\n    \u003C/div>\n  );\n}\n```\n\nこのProductPageは、サーバーでレンダリングされるため、初回のロードが非常に速く、検索エンジンがコンテンツを正確に読み取ることができます。\n\n### 2. クライアントコンポーネント（CSR）: 「カートに追加」ボタン 🛒\n\nこのコンポーネントは'use client'ディレクティブを持つため、ブラウザでレンダリングされます。ユーザーの操作に応じた状態変更やAPI呼び出しを扱います。\n\n- **役割**: ユーザーのクリックイベントを処理し、カートの状態を更新する。\n- **使用例**: カウントアップ、カートへの商品追加、モーダル表示など。\n\n```typescript\n// components/AddToCartButton.tsx\n'use client';\n\nimport { useState } from 'react';\n\nexport default function AddToCartButton({ productId }: { productId: string }) {\n  const [isAdding, setIsAdding] = useState(false);\n\n  const handleAddToCart = async () => {\n    setIsAdding(true);\n    // APIルートを呼び出し、カートに商品を追加\n    await fetch('/api/cart', {\n      method: 'POST',\n      body: JSON.stringify({ productId }),\n    });\n    setIsAdding(false);\n  };\n\n  return (\n    \u003Cbutton\n      onClick={handleAddToCart}\n      disabled={isAdding}\n      className=\"bg-green-500 text-white p-2 rounded\"\n    >\n      {isAdding ? '追加中...' : 'カートに追加'}\n    \u003C/button>\n  );\n}\n```\n\nこのAddToCartButtonは、useStateフックを使用しているため、必ずクライアントで実行される必要があります。親のサーバーコンポーネントからpropsとしてproductIdを受け取り、その情報を使ってAPIを呼び出します。\n\n## まとめ：ハイブリッドレンダリングの利点\n\nこの実装例では、**ページのコアコンテンツ（SSR）とインタラクティブな機能（CSR）**が明確に分離されています。これにより、以下のメリットが生まれます。\n\n- **パフォーマンス**: 初期ロードが速くなり、ユーザーはすぐに商品情報を見ることができます。\n- **開発体験**: サーバーとクライアントのロジックが分離されるため、コードの見通しが良くなります。\n- **SEO**: サーバーで生成されたHTMLにより、検索エンジンがページを正しくインデックスできます。\n\nNext.jsは、このハイブリッドなアプローチによって、ウェブ開発のベストプラクティスを簡単に適用できるようにしています。\n\nNext.jsにおけるハイブリッドレンダリングは、**サーバーサイドレンダリング（SSR）とクライアントサイドレンダリング（CSR）**の長所を組み合わせることで、ウェブページのパフォーマンスとユーザー体験を最適化する強力なアプローチです。この戦略では、SEOに重要な静的コンテンツを高速に表示し、ユーザーインタラクションが必要な部分だけを動的にロードします。\n\n### 1. サーバーコンポーネント (SSR) の役割\n\nサーバーコンポーネントは、レンダリングをサーバー上で行うため、データの取得からHTMLの生成までを単一のリクエスト内で完結させます。これにより、ブラウザに渡されるのは完全にレンダリングされたHTMLとなり、ユーザーはすぐにコンテンツを見ることができます。これは、ブログ記事やECサイトの商品詳細ページのように、SEOが重要で、かつ初回表示が速いことが求められるページに最適です。\n\n- **提供されたコード例**では、`app/products/[id]/page.tsx`がサーバーコンポーネントとして機能しています。\n- `getProduct(id)`関数は、サーバーサイドで直接外部APIを呼び出し、商品データを取得します。\n- このデータは、`\u003Ch1>`や`\u003Cimg>`タグなどのHTML要素に直接埋め込まれてレンダリングされます。\n- このプロセスはクライアントサイドのJavaScriptに依存しないため、初回表示が非常に高速になり、検索エンジンのクローラーもコンテンツを正確に読み取ることができます。\n\n### 2. クライアントコンポーネント (CSR) の役割\n\nクライアントコンポーネントは、ブラウザでレンダリングされ、ユーザーの操作に応じて動的に動作する部分を担います。'use client'ディレクティブで明示的に宣言し、`useState`や`useEffect`といったReactのフックを利用できます。これにより、フォームの入力、ボタンのクリック、リアルタイムなデータの更新など、インタラクティブな機能を実現します。\n\n- **提供されたコード例**では、`components/AddToCartButton.tsx`がクライアントコンポーネントです。\n- `'use client'`ディレクティブが宣言されているため、このコンポーネントとその子孫コンポーネントはクライアントでレンダリングされます。\n- `useState`フックを使ってボタンの状態（例：isAdding）を管理し、ユーザーのクリックイベントに応じてUIを更新します。\n- `fetch` APIを使い、非同期でサーバーのAPIルート（`/api/cart`）を呼び出してカートに商品を追加するロジックが含まれています。\n\n### 3. ハイブリッドレンダリングの実践例 🧩\n\nECサイトの商品詳細ページは、ハイブリッドレンダリングの理想的な例です。\n\n- **SSR部分**: 商品名、価格、説明、画像といった静的かつSEOに重要な情報は、サーバーコンポーネントでレンダリングされます。\n- **CSR部分**: 「カートに追加」ボタンのように、ユーザーの操作に応じて状態が変化する部分は、クライアントコンポーネントとして分離されます。\n\nこの分離により、Next.jsはページの「表示」と「インタラクション」を明確に分け、それぞれの最適な環境で実行します。ユーザーはすぐにコンテンツを見ることができ、その後にJavaScriptがロードされてインタラクティブな機能が有効になるため、パフォーマンスとユーザビリティの両方が向上します。\n\nこのアプローチは、Next.jsが現代のウェブ開発における多くの課題（SEO、初回ロード速度、ユーザー体験）を解決するための核心的な戦略と言えます。\n\n## 📚 静的サイト生成 (SSG)\n\n静的サイト生成 (Static Site Generation, SSG) は、Next.jsが提供するもう一つのレンダリング手法です。これは、ビルド時にページを事前にレンダリングし、CDNにデプロイすることで、ユーザーからのリクエストに対して静的なHTMLファイルを直接提供するアプローチです。\n\n### 特徴\n\n- **極めて高速な表示**: ユーザーはサーバーにリクエストを送る必要がなく、CDNから直接HTMLを受け取ります。\n- **サーバー負荷なし**: ページはビルド時に一度だけ生成されるため、トラフィックの増加がサーバーに影響を与えません。\n- **優れたSEO**: SSRと同様に、クローラーは完全にレンダリングされたHTMLを受け取ります。\n\n### 実装方法\n\nSSGは、App Routerでは`fetch()`にキャッシュ設定（`revalidate: false`）を指定することで実現されます。しかし、Pages Routerの`getStaticProps`に相当する機能として、**generateStaticParams**関数をルートに追加することで、動的なパスを持つページをビルド時に静的に生成できます。\n\n```typescript\n// app/blog/[slug]/page.tsx\nimport { getPosts } from '@/lib/api'; // 全ての投稿を取得する関数\n\n// ビルド時に生成するパスを定義\nexport async function generateStaticParams() {\n  const posts = await getPosts();\n  return posts.map(post => ({\n    slug: post.slug,\n  }));\n}\n\n// 動的なルートでページをレンダリング\nexport default async function BlogPost({ params }) {\n  // `params.slug`に対応するデータをフェッチ\n  const post = await getPostBySlug(params.slug);\n  return (\n    \u003Carticle>\n      \u003Ch1>{post.title}\u003C/h1>\n      \u003Cp>{post.content}\u003C/p>\n    \u003C/article>\n  );\n}\n```\n\nこの例では、`generateStaticParams`がビルド時に全てのブログ記事のパスを生成し、それぞれの記事ページが静的なHTMLファイルとしてビルドされます。ユーザーが`blog/first-post`にアクセスすると、サーバーを経由せず、高速にページが表示されます。\n\n## 📈 Image Component (next/image)\n\nNext.jsの**Imageコンポーネント**は、単なる画像の表示にとどまらず、パフォーマンスを向上させるための様々な機能を備えています。これは、ウェブページの読み込み速度に大きく影響する画像を最適化するためのコア機能です。\n\n### 特徴\n\n- **自動最適化**: ビルド時に画像を最適化し、異なるデバイスサイズや画質に対応した複数のバージョンを生成します。\n- **Lazy Loading**: デフォルトで有効になっており、画面外の画像を自動的に遅延ロードします。\n- **LCP (Largest Contentful Paint) の改善**: `priority`プロパティを使うことで、ビューポート内にある重要な画像を優先的にロードさせ、パフォーマンス指標を改善します。\n- **レイアウトシフトの防止**: 画像のサイズ（`width`と`height`）を事前に指定することで、ページのロード中にレイアウトが崩れるのを防ぎます。\n\n```typescript\nimport Image from 'next/image';\n\nfunction MyComponent() {\n  return (\n    \u003CImage\n      src=\"/images/hero.jpg\"\n      alt=\"ヒーロー画像\"\n      width={1200}\n      height={800}\n      priority // LCPを改善するため、この画像を優先的にロード\n    />\n  );\n}\n```\n\nこのように、`next/image`コンポーネントは、開発者が意識しなくても、画像のパフォーマンス最適化を自動で行ってくれます。これは、Core Web Vitalsのような現代のウェブパフォーマンス指標に対応するために不可欠な機能です。","src/content/docs/nextjsガイド/02_基本/CSR・SSR.mdx","a43bc0a21674ba7c","nextjsガイド/02_基本/cache戦略",{"id":1545,"data":1547,"body":1552,"filePath":1553,"digest":1554,"deferredRender":16},{"title":1548,"editUrl":16,"head":1549,"template":18,"sidebar":1550,"pagefind":16,"draft":20},"Cache戦略",[],{"hidden":20,"attrs":1551},{},"## 🧠 Next.jsのキャッシュ戦略\n\nNext.jsは、ウェブアプリケーションのパフォーマンスを最大限に引き出すために、様々なキャッシュ戦略を組み合わせています。これらの戦略は、データの取得からレンダリング、そして配信に至るまで、アプリケーションの各レイヤーで機能します。\n\n### 1. データキャッシュ 💾\n\n`fetch` APIを使用することで、Next.jsはサーバーサイドで取得したデータを自動的にキャッシュします。これにより、同じリクエストが複数回発生した場合でも、ネットワークリクエストを再度行わずにキャッシュからデータを取得できるため、パフォーマンスが大幅に向上します。\n\n- **デフォルトのキャッシュ**: `fetch`を使用すると、リクエストは自動的にキャッシュされます。\n\n- **キャッシュの制御**:\n  - **再検証（Revalidation）**: 一定時間経過後にデータを再取得するよう設定できます。これは、頻繁に更新される情報（例：ニュース記事）に適しています。\n  - **force-cache**: データを強制的にキャッシュから取得します。\n  - **no-store**: データをキャッシュせず、常に新しいデータを取得します。\n\n```typescript\n// 5分ごとにデータを再検証する例\nconst res = await fetch('https://...', { next: { revalidate: 300 } });\nconst data = await res.json();\n```\n\n### 2. コンポーネントキャッシュ 🧩\n\nReactのサーバーコンポーネントは、サーバー上でレンダリングされた後、その結果がキャッシュされます。これにより、コンポーネントが再レンダリングされる際に、高価な計算やデータ取得を再度実行する必要がなくなります。\n\n- **自動キャッシュ**: `next dev`で開発サーバーを再起動するか、`next build`を実行すると、サーバーコンポーネントのキャッシュがクリアされます。\n\n- **キャッシュの無効化**:\n  - `'use client'`ディレクティブをコンポーネントに追加すると、そのコンポーネントはクライアントコンポーネントになり、このキャッシュ戦略の対象外となります。\n  - 動的関数（`headers`, `cookies`, `useSearchParams`など）を使用すると、そのコンポーネントは動的にレンダリングされ、キャッシュされなくなります。\n\n### 3. ルーターキャッシュ 🛣️\n\nNext.jsは、ルーターキャッシュという独自のキャッシュシステムを導入しています。これにより、ユーザーがすでに訪れたページを再度表示する際に、ページ全体を再フェッチすることなく、高速に遷移できます。\n\n- **動作**: ユーザーがリンクをクリックすると、Next.jsはバックグラウンドで新しいページのデータをプリフェッチし、キャッシュに保存します。ユーザーがそのページに遷移すると、キャッシュから瞬時に読み込まれるため、ナビゲーションが非常にスムーズになります。\n\n- **メリット**:\n  - **高速なナビゲーション**: 既に訪れたページへの戻る/進む操作が瞬時に完了します。\n  - **オフライン対応**: 一部のページはオフラインでも表示可能です。\n\n### 4. ブラウザキャッシュとCDNキャッシュ 🌐\n\nNext.jsは、ビルドプロセスで静的なアセット（画像、CSS、JavaScriptファイルなど）に一意のハッシュ値を付与します。\n\n- **ブラウザキャッシュ**: ブラウザはこれらのアセットをキャッシュし、次回アクセス時にサーバーへのリクエストを省略します。\n\n- **CDN（コンテンツ配信ネットワーク）**: Vercelなどのホスティングサービスを使用すると、静的アセットが世界中のCDNに自動的にキャッシュされ、ユーザーに地理的に最も近いサーバーから配信されます。\n\nこれらのキャッシュ戦略は、ユーザーに高速なウェブ体験を提供するために連携して機能します。開発者は、アプリケーションの要件に応じて、これらの戦略を適切に制御することが重要です。","src/content/docs/nextjsガイド/02_基本/cache戦略.mdx","d307b15b01c5bb11","nextjsガイド/02_基本/routehandler",{"id":1555,"data":1557,"body":1562,"filePath":1563,"digest":1564,"deferredRender":16},{"title":1558,"editUrl":16,"head":1559,"template":18,"sidebar":1560,"pagefind":16,"draft":20},"RouteHandlerについて",[],{"hidden":20,"attrs":1561},{},"## 🛣️ Route Handlerとは\n\nRoute Handlerは、Next.jsのApp RouterでAPIルートを作成するための新しい方法です。`pages/api`ディレクトリに依存する従来のAPIルートとは異なり、`app/api`ディレクトリ内の`route.ts`（または`.js`）ファイルとして定義されます。\n\nRoute Handlerは、RequestやResponseといったWeb標準のAPIに基づいているため、サーバーサイドのロジックをよりシンプルかつ柔軟に記述できます。\n\n## 📝 Route Handlerの作成方法\n\nRoute Handlerを作成するには、`app/`ディレクトリ内に`api`という名前のディレクトリを作成し、その中にHTTPメソッドに対応する関数をエクスポートする`route.ts`ファイルを追加します。\n\n### 基本的な例\n\n`app/api/hello/route.ts`\n\n```typescript\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n  return NextResponse.json({ message: 'Hello from Route Handler!' });\n}\n\nexport async function POST(request: Request) {\n  const data = await request.json();\n  return NextResponse.json({ message: 'POST request received', data });\n}\n```\n\n- `GET()`: GETリクエストを処理します。\n- `POST()`: POSTリクエストを処理します。\n- `NextResponse.json()`: Responseオブジェクトの便利なラッパーで、JSON形式のレスポンスを簡単に作成できます。\n\n## 💡 Route Handlerの主な特徴\n\n1. **Web標準APIへの準拠**\n   - Route Handlerは、Requestオブジェクト（リクエストボディ、ヘッダー、URLなどを含む）とResponseオブジェクト（レスポンスを構築）というWeb標準APIに準拠しています。これにより、Node.jsの知識だけでなく、Web開発の一般的な知識が活かせます。\n\n2. **HTTPメソッドごとの関数定義**\n   - 従来のAPIルートでは、1つのhandler関数内で`req.method`を使って分岐処理を行っていました。Route Handlerでは、GET, POST, PUT, DELETEなどのHTTPメソッドごとに個別の関数をエクスポートするだけで、ルーティングを自動的に処理してくれます。これにより、コードがより整理され、読みやすくなります。\n\n3. **キャッシュと再検証（Revalidation）**\n   - Route Handlerは、App Routerの高度なキャッシュ機能と統合されています。デフォルトで静的（static）なレスポンスがキャッシュされるため、パフォーマンスが向上します。必要に応じて、以下の方法で再検証を制御できます。\n     - `revalidate`オプション: `fetch`APIで`revalidate`オプションを指定することで、キャッシュを更新する頻度を制御できます。\n     - 動的関数: `headers()`, `cookies()`, `request()`のような動的な関数を使用すると、自動的にレスポンスが動的（dynamic）にレンダリングされます。\n\n## 🤝 従来のAPIルートとの違い\n\n| 特徴               | 従来のAPIルート (`pages/api`) | Route Handler (`app/api`) |\n|--------------------|-------------------------------|---------------------------|\n| ファイル名         | 任意のファイル名（例: `hello.js`） | `route.ts`                |\n| ディレクトリ       | `pages/api/`                  | `app/api/`                |\n| リクエスト処理     | `req.method`で分岐            | HTTPメソッドごとの関数（例: `GET()`, `POST()`） |\n| API                | Node.jsの`http.ServerResponse` | Web標準の`Request`と`Response` |\n| キャッシュ         | キャッシュなし（動的）         | デフォルトで静的、柔軟な再検証が可能 |\n\n新しいプロジェクトでは、これらの利点からRoute Handlerを使用することが推奨されます。Route Handlerは、単一のリポジトリ内で効率的なフルスタック開発を実現するNext.jsの基盤の一つです。","src/content/docs/nextjsガイド/02_基本/routeHandler.mdx","9824f12554fa35ea","nextjsガイド/02_基本/状態管理",{"id":1565,"data":1567,"body":1572,"filePath":1573,"digest":1574,"deferredRender":16},{"title":1568,"editUrl":16,"head":1569,"template":18,"sidebar":1570,"pagefind":16,"draft":20},"状態管理.mdx",[],{"hidden":20,"attrs":1571},{},"## ⚛️ 状態管理とは\n\n状態管理は、アプリケーションのデータを一元的に管理し、複数のコンポーネント間で共有・更新する仕組みです。これにより、コンポーネントツリーを深く辿ってデータを渡す**「Props Drilling」**の問題が解決され、アプリケーションのデータフローが予測可能になります。\n\n### 1. Zustand\n\nZustandは、シンプルでミニマリストな状態管理ライブラリです。フックAPIをベースにしており、ボイラープレートが非常に少ないのが特徴です。\n\n- **特徴**: 少ないコードでグローバルストアを作成でき、`useStore`フックで必要な状態だけを簡単に取得できます。\n\n### 2. Redux\n\nReduxは、大規模で複雑なアプリケーション向けの状態管理ライブラリです。**「単一方向データフロー」**に基づき、厳格なルールでデータの変更を管理します。\n\n- **特徴**: 状態の変更をアクションとリデューサーを通じて行うため、予測可能性が高く、デバッグが容易です。ただし、設定が複雑になりがちですが、Redux Toolkitで簡素化できます。\n\n### 3. Recoil\n\nRecoilは、Reactの思想に近い状態管理ライブラリで、状態を**「Atom」**という小さな単位に分割して管理します。\n\n- **特徴**: `useState`に似た感覚で使え、Atom（最小単位の状態）とSelector（Atomから派生した状態）を通じて、必要な状態だけを効率的に購読できます。\n\n### 4. Jotai\n\nJotai（ジョタイ）は、日本語の「状態」から名付けられたライブラリで、Recoilと同様にアトミックな状態管理を採用しています。\n\n- **特徴**: RecoilよりもさらにミニマリストなAPIを提供し、`useState`フックに非常に近い感覚でグローバル状態を扱えます。ボトムアップで小さなAtomを組み合わせて複雑な状態を構築するのに適しています。\n\n### どのライブラリを選ぶべきか？\n\n| 比較項目     | Zustand       | Redux         | Recoil        | Jotai         |\n|--------------|---------------|---------------|---------------|---------------|\n| 学習コスト   | 非常に低い    | 高い          | 低い          | 非常に低い    |\n| ボイラープレート | 非常に少ない  | 多い          | 少ない        | 少ない        |\n| 規模         | 小〜中規模    | 大規模        | 小〜大規模    | 小〜大規模    |\n| コンセプト   | フックベース  | 単一方向データフロー | Atom & Selector | Atom & ボトムアップ |\n\n- **シンプルさ**: ZustandとJotaiは、直感的に使い始めたい場合に最適です。\n\n- **大規模開発**: Reduxは、厳格なルールと予測可能性が求められる大規模なエンタープライズアプリケーションに向いています。\n\n- **Reactとの親和性**: RecoilとJotaiは、アトミックなアプローチにより、コンポーネントベースのReact開発と相性が良いです。特にJotaiは、よりミニマルなAPIを好む開発者におすすめです。","src/content/docs/nextjsガイド/02_基本/状態管理.mdx","b05d36f4984c870b","nextjsガイド/02_基本/フォルダ構成",{"id":1575,"data":1577,"body":1581,"filePath":1582,"digest":1583,"deferredRender":16},{"title":408,"editUrl":16,"head":1578,"template":18,"sidebar":1579,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1580},{},"## 📂 Next.jsのフォルダ構成：状態管理の統合\n\nNext.jsプロジェクトのフォルダ構成は、状態管理ライブラリを導入することでさらに複雑になります。クリーンアーキテクチャの原則と、機能ベースのBulletproof Reactの思想を組み合わせることで、状態管理コードを整理し、保守性とスケーラビリティを維持できます。\n\n### 1. 概念的なレイヤーの分離 🏛️\n\nクリーンアーキテクチャでは、コードを以下の3つのレイヤーに分離します。この階層構造により、外側のレイヤー（UI）は内側のレイヤー（データ）に依存しますが、その逆はありません。\n\n- **UI層（プレゼンテーション）** 🖥️\n  - ユーザーインターフェース（UI）の表示と入力処理を担当します。Next.jsでは、`app/`ディレクトリ内のコンポーネントやページがこれに該当します。\n\n- **アプリケーション層（ビジネスロジック）** 🛠️\n  - アプリケーション固有の機能やルールを定義します。ユーザー作成や注文処理といった、具体的なビジネスロジックがここに集約されます。\n\n- **データアクセス層（インフラストラクチャ）** 💾\n  - データベース、外部API、ファイルシステムなどのデータソースとのやり取りを扱います。この層は、データ永続化の詳細を抽象化します。\n\n### 2. フォルダ構成への適用 📁\n\nこれらのレイヤーを具体的なNext.jsのフォルダ構成に落とし込むには、機能ベースのBulletproof Reactの思想が役立ちます。\n\n#### コアディレクトリ\n\n- **`app/`**\n  - Next.jsのルーティングとUI層を担います。ここには、ページ (`page.tsx`) や共有レイアウト (`layout.tsx`) など、ユーザーに直接表示されるコードを配置します。ビジネスロジックはここには含めず、シンプルに保ちます。\n\n- **`src/`**\n  - プロジェクトの主要なコードを格納する推奨ディレクトリです。この中に、機能や共通コードを分離します。\n\n#### 分離されたレイヤー\n\n- **`src/features/`（アプリケーション層）**\n  - アプリケーションの主要な機能（例：auth、user、blog）をフォルダごとに整理します。各機能フォルダ内には、その機能に特化したコンポーネント、フック、API呼び出しなどが含まれます。\n\n```\n/src/features/auth/\n├── components/\n├── hooks/\n└── api/\n```\n\n- **`src/lib/`（データアクセス層）**\n  - データベース接続、外部APIクライアント、認証ライブラリなど、アプリケーション全体で再利用されるインフラストラクチャ関連のコードを配置します。\n\n```\n/src/lib/\n├── db.ts             // データベース接続\n├── auth.ts           // 認証ヘルパー\n└── utils.ts          // 汎用ユーティリティ\n```\n\n- **`src/components/`（UI層の共有コンポーネント）**\n  - アプリケーションの複数の場所で再利用される、汎用的なUIコンポーネント（例：`Button.tsx`、`Modal.tsx`）を配置します。\n\n- **`src/styles/`**\n  - グローバルなスタイルやテーマを定義します。\n\n### 3. 状態管理の統合 💾\n\n状態管理コードを導入する際は、そのコードをUIから分離し、アプリケーション層に配置するのがベストプラクティスです。\n\n#### 機能ごとの状態管理\n\n特定の機能に関連する状態は、その機能のディレクトリ内に配置します。\n\n例: `features/cart/` ディレクトリ\n\n```\n/src/features/cart/\n├── components/\n│   └── CartDisplay.tsx\n├── store/          // 状態管理コードを配置\n│   ├── cartSlice.ts\n│   └── cartSelector.ts\n└── hooks/\n    └── useCart.ts\n```\n\n#### グローバルな状態管理\n\nアプリケーション全体で共有される、どの機能にも属さない状態（例：テーマ設定、言語設定）は、`src/store`のようなルートレベルのディレクトリに配置します。\n\n例: `src/store/` ディレクトリ\n\n```\n/src/store/\n├── theme/\n│   └── themeSlice.ts\n├── user/\n│   └── userSlice.ts\n└── index.ts\n```\n\n### 4. まとめ：なぜこの構成が優れているのか？ 💡\n\nこのアプローチは、以下の点でアプリケーションの品質を向上させます。\n\n- **責務の分離**: UI、ビジネスロジック、状態管理、データアクセスが明確に分離されます。これにより、開発者は関心のあるレイヤーに集中できます。\n\n- **再利用性**: 状態管理のロジックはUIから独立しているため、異なるUIコンポーネントから同じ状態管理ロジックを再利用できます。\n\n- **テストの容易性**: 各レイヤーが独立しているため、UIやデータ層に依存することなく、状態管理ロジックを単独でテストできます。\n\n- **スケーラビリティ**: 新しい機能を追加する際、既存の機能に影響を与えることなく、新しい`features`ディレクトリと関連する状態管理コードを追加できます。\n\nこのようなフォルダ構成は、初期のセットアップに少し時間がかかりますが、長期的に見ると、チーム開発や大規模なプロジェクトにおいて、コードの管理と保守を大幅に簡素化します。","src/content/docs/nextjsガイド/02_基本/フォルダ構成.mdx","b1a4085f9c0dc633","nextjsガイド/01_はじめに/01_setup",{"id":1584,"data":1586,"body":685,"filePath":1590,"digest":687,"deferredRender":16},{"title":681,"editUrl":16,"head":1587,"template":18,"sidebar":1588,"pagefind":16,"draft":20},[],{"hidden":20,"attrs":1589},{},"src/content/docs/nextjsガイド/01_はじめに/01_setup.mdx","nextjsガイド/01_はじめに/mvvmについて",{"id":1591,"data":1593,"body":1598,"filePath":1599,"digest":1600,"deferredRender":16},{"title":1594,"editUrl":16,"head":1595,"template":18,"sidebar":1596,"pagefind":16,"draft":20},"MVVMについて",[],{"hidden":20,"attrs":1597},{},"MVVMをレストランに例える 🍽️\nMVVMは、まるでレストランのキッチンのようなものです。このレストランでは、役割が明確に分担されています。\n\nView (ビュー) - レストランのホール 👨‍🍳\n\n役割: お客様（ユーザー）と直接やり取りし、料理（データ）を美しく提供する役割です。\n\n仕事: メニューを見せたり、注文を受けたり、料理をテーブルに運んだりします。\n\nMVVMでは: Viewは単に表示するだけの役割です。ロジック（どうやって料理を作るか）は知りません。\n\nModel (モデル) - 食材の倉庫 📦\n\n役割: 料理の元となる食材（データ）を管理し、下ごしらえする場所です。\n\n仕事: 食材を新鮮に保ち、必要な時に提供できるように準備します。\n\nMVVMでは: Modelはアプリケーションのデータとビジネスロジックそのものです。UIとは完全に切り離されており、データの保存や計算を行います。\n\nViewModel (ビューモデル) - 料理長 🧑‍🍳\n\n役割: ホール（View）と倉庫（Model）の中間役です。\n\n仕事: ホールから受けた注文（ユーザーの操作）を元に、倉庫（Model）から食材を調達し、レシピ通りに料理（表示用のデータ）を調理します。料理ができたら、自動的にホールに「料理ができたよ！」と知らせます。\n\nMVVMでは: ViewModelは、Viewに表示するデータを扱いやすい形に整形し、Viewからの指示でModelを操作します。ViewModel内のデータが変更されると、データバインディングという魔法の糸🪄で結ばれたViewの表示が自動的に更新されます。\n\nなぜこの分担が重要なのか？\nこのレストランの例で考えると、MVVMのメリットがより明確になります。\n\n分業がしやすい 🤝\n\nホールの担当者（View）は、料理の作り方（ViewModel）や食材の管理（Model）について知る必要がありません。\n\n料理長（ViewModel）も、料理をどうテーブルに並べるか（View）をいちいち気にする必要はありません。\n\nこれにより、チームの各メンバーが自分の専門分野に集中できます。\n\nテストが簡単 🧪\n\n料理長（ViewModel）は、実際にテーブル（View）がなくても、レシピ（ロジック）通りに料理（データ）が作れるかテストできます。\n\n「チーズケーキのレシピをテストして」と言われれば、実際にケーキを焼く代わりに、冷蔵庫にある材料と手順だけで、論理的に正しいかを確認できます。\n\n変更に強い 💪\n\nメニュー（View）を変えたい場合でも、料理長（ViewModel）は同じレシピ（ロジック）を使い続けられます。例えば、ホールでメニュー表が紙からタブレットに変わっても、料理長はいつも通りの仕事をするだけです。\n\nこれは、ViewとViewModelが疎結合（お互いについて最低限しか知らない関係）であるためです。\n\nMVVMにおける「データバインディング」の魔法 🪄\nMVVMの最も重要な概念がデータバインディングです。これは、ViewModelのデータとViewの表示を自動的に同期させる仕組みです。\n\nViewがViewModelを監視 👀\n\nViewはViewModelに対して、「あなたのデータが変わったら教えてね」と伝えておきます。\n\nViewModelがデータを更新すると、Viewは自動でその変更を検知し、画面を再描画します。\n\n双方向バインディング\n\nユーザーがView（例えば、テキストボックス）に何かを入力すると、そのデータは自動的にViewModelに反映されます。\n\nこの双方向のやり取りが、コードをよりシンプルに、そして柔軟にします。\n\nMVVMとデータバインディングのイメージ\n\nMVVMがよく使われる技術スタック 💻\nMVVMは、以下の特徴を持つフレームワークと特に相性が良いです。\n\nReact: ステート管理（useState, Reduxなど）がViewModelの役割を担います。\n\nVue.js: dataプロパティやcomputedプロパティがViewModelの機能を果たし、双方向データバインディングが組み込まれています。\n\nSwiftUI (iOS): ObservableObjectやStateといった仕組みがMVVMの概念を強力にサポートしています。\n\nJetpack Compose (Android): Stateオブジェクトを利用して、ViewとViewModelの連携をスムーズにします。\n\nMVVMは、UIを持つアプリケーションの複雑さを管理するための強力な設計パターンです。役割分担を明確にすることで、開発者はより効率的に、そしてより高品質なコードを書くことができます。","src/content/docs/nextjsガイド/01_はじめに/MVVMについて.mdx","1728a853d42c6b46","nextjsガイド/01_はじめに/頻出",{"id":1601,"data":1603,"body":1608,"filePath":1609,"digest":1610,"deferredRender":16},{"title":1604,"editUrl":16,"head":1605,"template":18,"sidebar":1606,"pagefind":16,"draft":20},"頻出",[],{"hidden":20,"attrs":1607},{},"## Next.js 環境構築の基本と拡張\n\nNext.jsプロジェクトの構築は、`create-next-app`コマンドから始まります。しかし、より堅牢で効率的な開発を目指すには、初期設定に加えて以下の要素を考慮することが重要です。\n\n### 開発ツールの導入\n\n- **ESLint**: コード品質の維持\n- **Prettier**: コードフォーマットの統一\n- **Husky**: コミットやプッシュ前に自動でチェックを実行\n\n### バージョン管理\n\n- **Git**: プロジェクトの変更履歴を管理し、共同開発をスムーズに行います。\n\n### プロジェクト設定\n\n- **パスエイリアス**: `jsconfig.json`または`tsconfig.json`で設定し、相対パスから解放され、コードの可読性が向上します。\n- **環境変数**: `.env.local`ファイルで管理し、APIキーなどの機密情報を安全に扱えます。\n\n### パッケージ管理\n\n- **npm**: 標準のパッケージ管理ツール\n- **Yarn**や**pnpm**: 代替ツールとして検討し、プロジェクトの要件に最適なものを選びましょう。\n\n## 頻出ライブラリの概要\n\nNext.js開発でよく使われるライブラリは、特定の目的を達成するためにプロジェクトに導入されます。\n\n### UI / スタイリング 🎨\n\n- **Tailwind CSS**: ユーティリティクラスで高速にUIを構築できます。\n- **MUI (Material-UI)** と **Chakra UI**: 事前に用意された高品質なコンポーネントで、デザインの一貫性を保ちます。\n- **Headless UI** と **Radix UI**: スタイルを持たないコンポーネントで、ロジックとアクセシビリティを提供し、デザインの自由度を高めます。\n\n### データ取得 / 状態管理 🔄\n\n- **SWR** と **React Query**: サーバーからのデータ取得と状態管理を効率化し、パフォーマンスを向上させます。\n- **Zustand** と **Redux Toolkit**: クライアントサイドの状態管理をシンプルに行います。\n\n### フォームとバリデーション 📝\n\n- **Zod**: データの型とバリデーションスキーマを定義します。\n- **React Hook Form**: パフォーマンスに優れたフォーム管理を実現し、Zodと組み合わせるのが一般的です。\n\n### テスト ✅\n\n- **Jest** と **Vitest**: アプリケーションの動作を自動でテストし、バグの混入を防ぎます。Vitestは特に高速なテスト実行が強みです。\n\n### インフラ / 運用 ⚙️\n\n- **Sentry**: 本番環境のエラーをリアルタイムで監視し、詳細なレポートを提供します。\n- **Prisma** と **Drizzle ORM**: データベース操作を型安全に行い、開発効率と安全性を高めます。\n- **Vercel Analytics** と **Speed Insights**: アプリケーションのパフォーマンスを分析し、ユーザー体験の改善に役立ちます。\n\n### その他ユーティリティ 🛠️\n\n- **next/image**: Next.jsのビルトイン機能で、画像の最適化を自動化します。\n- **NextAuth.js**: 認証機能を簡単に実装できます。\n- **Framer Motion**: コンポーネントに滑らかなアニメーションを付け加えます。\n- **next-i18n-router**: 多言語対応をシンプルに行います。\n- **date-fns** と **Day.js**: 日付と時間の操作を簡単にします。\n\nこれらのツールやライブラリを適切に組み合わせることで、Next.jsを最大限に活用し、高品質なウェブアプリケーションを効率的に開発できます。プロジェクトの規模や要件に応じて、必要なものを選択し、開発を始めましょう。","src/content/docs/nextjsガイド/01_はじめに/頻出.mdx","4fe1db188d4ed252","fastapiガイド/02_基本/開発ステップ",{"id":1611,"data":1613,"body":1618,"filePath":1619,"digest":1620,"deferredRender":16},{"title":1614,"editUrl":16,"head":1615,"template":18,"sidebar":1616,"pagefind":16,"draft":20},"開発ステップ",[],{"hidden":20,"attrs":1617},{},"## 開発ステップ\n\n### 1. 開発環境の準備とプロジェクトの初期設定 🛠️\n\nまず、プロジェクトに必要なライブラリを管理するため、`requirements.txt` ファイルを作成し、以下の内容を記述します。\n\n```plaintext\nfastapi\nuvicorn\npydantic\n```\n\n次に、以下のコマンドでこれらのライブラリをインストールします。\n\n```bash\npip install -r requirements.txt\n```\n\n### 2. Pydanticモデルの定義 (Model) 📝\n\n`app/schemas/user.py` に、リクエストやレスポンスのデータの型定義を行うPydanticモデルを作成します。これにより、データのバリデーションとシリアライゼーションが自動的に行われます。\n\n```python\n# app/schemas/user.py\n\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n```\n\n### 3. データベース操作などのロジックの定義 (Model) 💾\n\n`app/services/db_service.py` に、データベース操作やビジネスロジックを記述します。ここでは、簡単な例として、ユーザーデータのリストを保持するダミーのロジックを実装します。\n\n```python\n# app/services/db_service.py\n\nfrom typing import List\nfrom app.schemas.user import User, UserCreate\n\n# ダミーのデータベース\nusers_db: List[User] = [\n    User(id=1, name=\"Alice\", email=\"alice@example.com\"),\n    User(id=2, name=\"Bob\", email=\"bob@example.com\"),\n]\n\ndef get_users() -> List[User]:\n    \"\"\"すべてのユーザーを取得する\"\"\"\n    return users_db\n\ndef create_user(user_data: UserCreate) -> User:\n    \"\"\"新しいユーザーを作成する\"\"\"\n    new_id = max([user.id for user in users_db]) + 1 if users_db else 1\n    new_user = User(id=new_id, **user_data.model_dump())\n    users_db.append(new_user)\n    return new_user\n```\n\n### 4. エンドポイントの分割とルーティング 🗺️\n\nAPIエンドポイントをモジュールごとに分割し、`APIRouter` を使って整理します。これにより、`main.py`をシンプルに保ち、メンテナンス性を向上させます。\n\n#### フォルダ構成の変更\n\n```plaintext\n.\n├── app/\n│   ├── __init__.py\n│   ├── main.py\n│   ├── api/\n│   │   ├── __init__.py\n│   │   └── endpoints/\n│   │       ├── __init__.py\n│   │       └── user.py\n│   └── schemas/\n│       └── user.py\n│   └── services/\n│       └── db_service.py\n└── requirements.txt\n```\n\n#### エンドポイントの定義 (user.py)\n\n`app/api/endpoints/user.py` に、ユーザー関連のエンドポイントを定義します。\n\n```python\n# app/api/endpoints/user.py\n\nfrom fastapi import APIRouter\nfrom typing import List\n\nfrom app.schemas.user import User, UserCreate\nfrom app.services.db_service import get_users, create_user\n\nrouter = APIRouter()\n\n@router.get(\"/\", response_model=List[User])\ndef read_users():\n    \"\"\"全ユーザーのリストを取得するエンドポイント\"\"\"\n    return get_users()\n\n@router.post(\"/\", response_model=User, status_code=201)\ndef create_new_user(user_data: UserCreate):\n    \"\"\"新しいユーザーを作成するエンドポイント\"\"\"\n    return create_user(user_data)\n```\n\n### 5. CORS設定とルーターのインポート (main.py) 🚀\n\n`app/main.py` に、FastAPIアプリケーションのインスタンスを作成し、CORS設定と、先ほど作成したルーターを`app.include_router()`で読み込みます。\n\n```python\n# app/main.py\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.api.endpoints import user\n\napp = FastAPI()\n\n# CORS設定\norigins = [\n    \"http://localhost\",\n    \"http://localhost:8000\",\n    \"http://localhost:3000\", # 例: フロントエンドのポート\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# ルーターをインクルード\n# prefix=\"/users\" で、このルーター内の全エンドポイントに /users が付加される\napp.include_router(user.router, prefix=\"/users\", tags=[\"users\"])\n```\n\n`prefix=\"/users\"` を指定することで、`user.py` 内のパスに `/users` が付加され、`http://127.0.0.1:8000/users/` としてアクセスできるようになります。`tags=[\"users\"]` は、Swagger UIのドキュメントを自動的にグループ化するのに役立ちます。\n\n### 6. サーバーの実行 💻\n\nプロジェクトのルートディレクトリで以下のコマンドを実行し、Uvicornを使って開発サーバーを起動します。\n\n```bash\nuvicorn app.main:app --reload\n```\n\n`--reload` オプションにより、コード変更時にサーバーが自動的に再起動します。サーバー起動後、ブラウザで `http://127.0.0.1:8000/docs` にアクセスして、APIが正しく動作しているか確認できます。","src/content/docs/fastapiガイド/02_基本/開発ステップ.mdx","388a91f7cad904e3","fastapiガイド/03_中級/test方法",{"id":1621,"data":1623,"body":1628,"filePath":1629,"digest":1630,"deferredRender":16},{"title":1624,"editUrl":16,"head":1625,"template":18,"sidebar":1626,"pagefind":16,"draft":20},"test方法",[],{"hidden":20,"attrs":1627},{},"## FastAPIのテスト方法ガイド 🧪\n\nFastAPIでは、`TestClient` を使用してAPIエンドポイントを直接テストするのが最も一般的です。`TestClient`は、実際のネットワーク通信をせずに仮想的なリクエストをアプリケーションに送信するため、高速かつ信頼性の高いテストが可能です。\n\n### 1. 必要なライブラリのインストール ⚙️\n\nまず、テストに必要な`pytest`と`httpx`をインストールします。\n\n```bash\npip install \"pytest\" \"httpx[standard]\"\n```\n\n### 2. 基本的なテストコードの作成 (結合テスト) 🤝\n\n`TestClient`を使って、アプリケーション全体が正しく連携して動くかをテストします。\n\n#### フォルダ構成:\n\n```plaintext\n.\n├── app/\n│   └── main.py\n└── tests/\n    └── test_main.py\n```\n\n#### `tests/test_main.py`のコード例:\n\n```python\nfrom fastapi.testclient import TestClient\nfrom app.main import app\n\nclient = TestClient(app)\n\ndef test_read_users():\n    \"\"\"GET /users/ のエンドポイントをテスト\"\"\"\n    response = client.get(\"/users/\")\n    assert response.status_code == 200\n    assert response.json() == [\n        {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n        {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\"},\n    ]\n\ndef test_create_user():\n    \"\"\"POST /users/ のエンドポイントをテスト\"\"\"\n    new_user_data = {\"name\": \"Charlie\", \"email\": \"charlie@example.com\"}\n    response = client.post(\"/users/\", json=new_user_data)\n    assert response.status_code == 201\n    assert response.json() == {\"id\": 3, \"name\": \"Charlie\", \"email\": \"charlie@example.com\"}\n```\n\n`TestClient`は、実際のHTTPリクエストと同様に`.get()`や`.post()`などのメソッドを使えるため、直感的にテストが記述できます。\n\n### 3. より実践的なテスト手法 🚀\n\n#### a. データベースを使用する場合のテスト (フィクスチャ)\n\nデータベースに依存するテストでは、各テストが独立して実行されるように、テストの前後にデータベースを初期化・クリーンアップする処理が不可欠です。`pytest`のフィクスチャを使うと、この処理を自動化できます。\n\n#### `conftest.py`のコード例:\n\n```python\n# conftest.py (テストのルートディレクトリに配置)\n\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom app.database import Base\nfrom app.main import app\n\n@pytest.fixture(scope=\"function\")\ndef client():\n    # 依存性を上書きし、テスト用DBに接続\n    def override_get_db():\n        # ... テスト用DBのセッションを返すロジック ...\n        pass\n    \n    app.dependency_overrides[get_db] = override_get_db\n    with TestClient(app) as client:\n        yield client\n    app.dependency_overrides.clear() # 依存性のオーバーライドを解除\n```\n\nこのフィクスチャを配置することで、テストごとにクリーンな状態のテストデータベースが利用できるようになります。\n\n#### b. モック（Mocking）を使ったテスト (単体テスト) 🎯\n\nモックとは、外部サービス（データベース、外部APIなど）を**偽物（モックオブジェクト）**に置き換える手法です。これにより、外部に依存しない高速な単体テストが書けます。\n\n`pytest`では、`monkeypatch`フィクスチャを使って簡単にモックを実現できます。\n\n#### `tests/test_main_mock.py`のコード例:\n\n```python\n# tests/test_main_mock.py\n\nfrom fastapi.testclient import TestClient\nfrom app.main import app\nfrom app.schemas.user import User\nfrom app.services import db_service\n\nclient = TestClient(app)\n\ndef test_read_users_mocked(monkeypatch):\n    \"\"\"get_users関数をモックしてテスト\"\"\"\n    mock_users = [User(id=1, name=\"MockUser\", email=\"mock@example.com\")]\n    \n    def mock_get_users():\n        return mock_users\n\n    monkeypatch.setattr(db_service, \"get_users\", mock_get_users)\n\n    response = client.get(\"/users/\")\n    assert response.status_code == 200\n    assert response.json() == [{\"id\": 1, \"name\": \"MockUser\", \"email\": \"mock@example.com\"}]\n```\n\nこのテストでは、`db_service.py`が実際のデータベースに接続するかどうかに関わらず、エンドポイントの振る舞いだけを検証できます。\n\n### 4. テストの実行 🚀\n\nプロジェクトのルートディレクトリで以下のコマンドを実行するだけで、`pytest`がテストを自動で実行してくれます。\n\n```bash\npytest\n```\n\nこれにより、アプリケーションの品質と信頼性を確保し、安心して開発を進めることができます。\n\n### テストカバレッジの測定 📊\n\nテストコードがアプリケーションのどの部分をどれだけカバーしているかを把握することは、品質を確保する上で非常に重要です。テストカバレッジを測定することで、テストが不足している箇所（カバレッジホール）を特定し、効率的にテストを追加できます。\n\n`coverage.py` を使用すると、この測定を簡単に行えます。\n\n#### インストール\n\n`coverage.py`をインストールします。\n\n```bash\npip install coverage\n```\n\n#### カバレッジ付きでテストを実行\n\n`pytest`を直接実行する代わりに、`coverage`コマンドを介して実行します。\n\n```bash\ncoverage run -m pytest\n```\n\n#### レポートの生成\n\nカバレッジ情報を読みやすいレポート形式で表示します。\n\n```bash\ncoverage report\n```\n\nこのコマンドは、各ファイルのカバレッジ率（行数ベース）を一覧で表示します。\n\nより詳細なレポートが必要な場合は、HTML形式で生成することも可能です。\n\n```bash\ncoverage html\n```\n\nこれにより、`htmlcov/`ディレクトリに詳細なレポートが生成されます。ファイルを開くと、コードの各行がテストされたかどうかを色分けで確認できます。\n\n### その他のテストに関するヒント 💡\n\n- **命名規則の統一**: テスト関数の名前は`test_`で始め、何のためにテストしているのかを明確に記述しましょう（例: `test_create_user_success`）。\n- **テストの分離**: 各テストは完全に独立しているべきです。テスト間で状態が共有されないように、可能な限りフィクスチャを活用しましょう。\n- **継続的インテグレーション（CI）**: GitHub ActionsなどのCIツールと連携し、コードがプッシュされるたびに自動でテストが実行されるように設定することで、品質管理を自動化できます。\n\n### 責務別のテストの考え方 🧪\n\n#### Model (ロジック) のテスト: 単体テスト 🎯\n\nModel層は、アプリケーションのビジネスロジックやデータ操作を担う部分です。この層は、外部サービス（データベースなど）や他の層（View）から独立してテストすべきです。これを**単体テスト（Unit Test）**と呼びます。\n\n- **目的**: Modelの関数やクラスが、与えられた入力に対して常に期待通りの出力を返すか検証する。\n- **テスト対象**: データベースの操作ロジック、データ変換、バリデーションなど。\n- **利点**:\n  - 高速: 外部サービスに接続しないため、テストが非常に高速です。\n  - 再現性: 外部の状態に依存しないため、テストの失敗・成功が常に同じになります。\n  - 問題の特定: どこでバグが発生したかをピンポイントで特定できます。\n- **実装方法**: `pytest`の**モック（Mocking）**機能を使って、データベース接続や外部APIコールを偽物に置き換えます。\n\n#### View (エンドポイント) のテスト: 結合テスト 🤝\n\nView層は、ユーザーからのリクエストを受け付け、適切なModel層のロジックを呼び出し、レスポンスを返す役割を担います。この層のテストは、**結合テスト（Integration Test）**として扱います。\n\n- **目的**: エンドポイントがHTTPリクエストに対して正しく応答するか（例: 正しいステータスコード、正しいJSONレスポンス）、そしてModel層と適切に連携しているか検証する。\n- **テスト対象**:\n  - HTTPメソッド（GET, POST, PUT, DELETE）\n  - URLパスとクエリパラメータ\n  - リクエストボディのバリデーション\n  - レスポンスの形式と内容\n- **利点**:\n  - システム全体の検証: アプリケーションの各コンポーネントが正しく連携していることを確認できます。\n  - エンドツーエンドの確認: ユーザーの視点からAPIが期待通りに動くことを保証できます。\n- **実装方法**: FastAPIの**TestClient**を使って、アプリケーション全体に仮想的なリクエストを送信します。\n\n### なぜテストを切り分けるべきか？\n\nテストを切り分けることで、以下のようなメリットがあります。\n\n- **効率的なデバッグ**: 結合テストが失敗した場合でも、単体テストが通っていれば、問題はModel層ではなくView層やその間の連携にあると絞り込めます。\n- **高速なフィードバック**: 単体テストは非常に高速なため、開発中に頻繁に実行し、早期にバグを発見できます。結合テストは単体テストよりも時間がかかるため、CI/CDパイプラインなどで実行します。\n- **メンテナンス性**: Modelのロジックを変更しても、Viewのテストは壊れにくく、Viewのパスを変更してもModelのテストには影響しません。これにより、コードの変更に強いテストスイートが構築できます。\n\n結論として、Model層はモックを使った単体テストでロジックの正確性を保証し、View層はTestClientを使った結合テストでシステム全体の振る舞いを検証する、というアプローチが理想的です。","src/content/docs/fastapiガイド/03_中級/test方法.mdx","a156e62d1cc3c0fc","goガイド/01_はじめに/環境構築",{"id":1631,"data":1633,"body":1638,"filePath":1639,"digest":1640,"deferredRender":16},{"title":1634,"editUrl":16,"head":1635,"template":18,"sidebar":1636,"pagefind":16,"draft":20},"Goの環境構築",[],{"hidden":20,"attrs":1637},{},"## Goの環境構築 🛠️\n\nGo言語の環境構築は比較的シンプルです。ここでは、公式サイトからGoをインストールし、基本的なプロジェクト設定を行う手順を解説します。\n\n### 1. Goのインストール 📥\n\n公式サイトからお使いのOSに合ったインストーラーをダウンロードします。\n\n- **Go公式ウェブサイト** にアクセスします。\n- お使いのオペレーティングシステム（macOS, Windows, Linux）に応じたインストーラーをダウンロードします。\n- インストーラーを起動し、指示に従ってインストールを完了させます。\n\n#### Windowsの場合:\n- インストーラーがPATH環境変数を自動的に設定します。\n\n#### macOSの場合:\n- PKGファイルをダブルクリックしてインストールすると、`/usr/local/go`にGoが配置され、`/etc/paths.d`を通じてPATHが自動的に設定されます。\n\n#### Linuxの場合:\n- tarballをダウンロードし、`/usr/local`に展開します。その後、`~/.profile`または`~/.bash_profile`にGoのバイナリへのパスを追加する必要があります。\n\n```bash\n# tarballを展開\nsudo tar -C /usr/local -xzf go\u003Cversion>.\u003Cos>-\u003Carch>.tar.gz\n\n# .profileにパスを追加\nexport PATH=$PATH:/usr/local/go/bin\n```\n\n変更を反映させるため、ターミナルを再起動するか、`source ~/.profile`を実行してください。\n\n### 2. インストールの確認 ✅\n\nターミナルを開き、以下のコマンドを実行してGoが正しくインストールされているか確認します。バージョン情報が表示されれば成功です。\n\n```bash\ngo version\n```\n\n### 3. プロジェクトの初期設定 📂\n\nGoでは、`go mod`（Go Modules）を使って依存関係を管理するのが一般的です。以下の手順で新しいプロジェクトを初期化します。\n\n- プロジェクト用のディレクトリを作成し、その中に移動します。\n\n```bash\nmkdir my-go-app\ncd my-go-app\n```\n\n- `go mod init`コマンドを実行して、プロジェクトを初期化します。これにより、`go.mod`ファイルが作成され、依存関係が記録されるようになります。\n\n```bash\ngo mod init my-go-app\n```\n\n`my-go-app`は、プロジェクトのモジュールパスです。通常はGitHubリポジトリ名など、一意な名前を付けます。\n\n### 4. 最初のGoプログラムの作成 ✍️\n\nプロジェクトのルートディレクトリに、`main.go`ファイルを作成します。\n\n```go\n// main.go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, Go!\")\n}\n```\n\n`package main`は実行可能なプログラムであることを示し、`main`関数はプログラムのエントリーポイントです。\n\n### 5. プログラムの実行 🚀\n\n以下のコマンドを実行して、作成したプログラムを実行します。\n\n```bash\ngo run main.go\n```\n\nターミナルに「Hello, Go!」と表示されれば、環境構築は完了です。","src/content/docs/Goガイド/01_はじめに/環境構築.mdx","7a7152e107e8d81b","goガイド/01_はじめに/なぜgoなのか",{"id":1641,"data":1643,"body":1648,"filePath":1649,"digest":1650,"deferredRender":16},{"title":1644,"editUrl":16,"head":1645,"template":18,"sidebar":1646,"pagefind":16,"draft":20},"なぜGoなのか",[],{"hidden":20,"attrs":1647},{},"## なぜGoを使用するのか？ Goの主なメリット\n\nGo言語（Golang）は、Googleが開発したオープンソースのプログラミング言語です。シンプルな文法と高いパフォーマンスを両立しているため、特にサーバーサイドやCLIツール開発で広く採用されています。主なメリットは以下の通りです。\n\n### 1. 高いパフォーマンスと軽量さ 🚀\n\n- **コンパイル言語**: C++やRustに匹敵する高速な実行速度を誇ります。\n- **軽量なデプロイ**: 実行時に必要なライブラリを一つのバイナリファイルにまとめることができ、デプロイが非常に簡単で軽量です。Dockerコンテナなどの環境に特に適しています。\n\n### 2. 並行処理（Concurrency）の強力なサポート 🧵\n\n- **Goroutine**: OSスレッドよりもはるかに軽量な「ゴルーチン」と呼ばれる仕組みを提供します。数千、数万ものゴルーチンを簡単に生成でき、非同期処理をシンプルに記述できます。\n- **Channel**: 複数のゴルーチン間で安全にデータをやり取りするための「チャネル」という仕組みがあります。これにより、共有メモリを介した複雑な同期処理を避け、バグの少ないコードを書くことができます。\n\n### 3. シンプルな文法と学習コストの低さ 🧠\n\n- **シンプルな文法**: 覚えるべきことが少なく、クラス継承のような複雑なオブジェクト指向の概念を排除しています。\n- **高い可読性とメンテナンス性**: 開発チーム内でのコードのばらつきが少なくなり、可読性とメンテナンス性が高まります。\n\n### 4. 豊富な標準ライブラリ 📚\n\n- **Web開発に必要な機能**: HTTPサーバー、JSON処理、ファイルI/Oなどが標準ライブラリとして提供されています。\n- **外部ライブラリへの依存が少ない**: すぐに開発を始められます。\n\n### 5. 堅牢なエコシステムとツール 🛠️\n\n- **静的型付け**: コンパイル時に多くのエラーを発見できます。\n- **充実したツール群**:\n  - `go fmt`: コードを自動でフォーマットし、チーム全体で統一されたスタイルを強制します。\n  - `go test`: テストを簡単に実行でき、カバレッジレポートも生成できます。\n  - `go mod`: 依存関係管理ツールで、バージョン管理やビルドプロセスをシンプルにします。\n\nこれらのメリットから、Goは高性能なAPIサーバー、マイクロサービス、クラウドインフラツールなどを開発するのに最適な言語の一つとされています。\n\n## Goが特に力を発揮するユースケース 💼\n\nGoは、その特性から特定の分野で特に好んで使われています。\n\n- **APIサーバー・マイクロサービス**: 軽量で並行処理に強いため、多数のリクエストを効率的に処理するWeb APIやマイクロサービスの構築に最適です。DockerやKubernetesといったクラウド技術との相性も抜群で、コンテナ化された環境で真価を発揮します。\n\n- **CLI（コマンドラインインターフェース）ツール**: 単一のバイナリファイルとしてコンパイルできるため、依存関係を気にすることなく簡単に配布・実行できます。kubectlやDocker CLI、Terraformなど、多くの有名なCLIツールがGoで開発されています。\n\n- **クラウド・ネットワークインフラ**: 並行処理とネットワーク機能の扱いやすさから、クラウドの基盤となるツールやネットワークプログラミングの分野で広く使われています。\n\n- **DevOpsツール**: コードのシンプルさ、単一バイナリによるデプロイの容易さから、開発者が使うツールや自動化スクリプトの開発にも適しています。\n\n## Goのデメリット・考慮すべき点 🤔\n\nGoは多くのメリットを持つ一方で、いくつかの注意点も存在します。\n\n- **ジェネリクス（Generics）の歴史**: Go 1.18でジェネリクスが導入されるまで、汎用的なデータ型を扱うには冗長なコードを書く必要がありました。現在ではこの問題は解消されつつありますが、まだ新しい機能であり、古いコードベースでは非効率なパターンが見られることがあります。\n\n- **例外処理の不在**: Goにはtry-catchのような例外処理の仕組みがありません。代わりに、関数の戻り値としてerrorを返し、呼び出し元でその都度`if err != nil`という形でエラーをチェックする必要があります。これは、エラーの取りこぼしを防ぐ一方で、コードが冗長になりやすいという側面もあります。\n\n- **GUIやデスクトップアプリケーション開発への不向き**: Goの標準ライブラリはサーバーサイドやネットワークに特化しているため、GUIアプリケーション開発のための豊富なライブラリやエコシステムはまだ発展途上です。デスクトップアプリケーションを開発する場合は、Go以外の言語が適していることが多いでしょう。","src/content/docs/Goガイド/01_はじめに/なぜGOなのか.mdx","ea0db6763cf0c16b","goガイド/02_基本/goの基本構文",{"id":1651,"data":1653,"body":1658,"filePath":1659,"digest":1660,"deferredRender":16},{"title":1654,"editUrl":16,"head":1655,"template":18,"sidebar":1656,"pagefind":16,"draft":20},"Goの基本構文",[],{"hidden":20,"attrs":1657},{},"## Goの基本構文 🧩\n\nGoはシンプルで、読み書きしやすい構文を持つことが特徴です。以下にその主要な要素をまとめます。\n\n### 1. パッケージとインポート 📦\n\nGoのプログラムはすべてパッケージに属します。実行可能なプログラムの起点となるのは特別なパッケージ**main**です。\n\n- `package main`: プログラムが実行可能であることを示します。\n- `import`: 他のパッケージの機能を利用するために使います。\n\n```go\npackage main\n\nimport (\n    \"fmt\"  // I/Oフォーマットを提供\n    \"math\" // 数学関数を提供\n)\n```\n\n### 2. 関数 ⚙️\n\n関数は`func`キーワードで定義し、引数と戻り値の型を明示します。\n\n- `func main()`: プログラムのエントリーポイントです。\n- 複数の戻り値: Goの関数は複数の値を返すことができ、エラーハンドリングに広く使われます。\n\n```go\n// 戻り値がない関数\nfunc sayHello() {\n    fmt.Println(\"Hello!\")\n}\n\n// 複数の戻り値がある関数\nfunc swap(x, y string) (string, string) {\n    return y, x\n}\n```\n\n### 3. 変数と定数 ✍️\n\n- `var`: 変数を宣言します。型を明示するか、コンパイラに推論させることができます。\n- `:=`: 関数内でのみ使える簡潔な変数宣言と初期化の方法です。\n- `const`: コンパイル時に値が確定する定数を宣言します。\n\n```go\nvar name string = \"Alice\"\nage := 30\nconst PI = 3.14\n```\n\n### 4. 複合データ型 📝\n\nGoのデータ型は静的で、コンパイル時にチェックされます。\n\n- 配列 (Array): 固定長のデータ型です。サイズは型の一部となります。\n- スライス (Slice): 可変長のデータ型で、内部的には配列を参照します。メモリ効率が良く、ほとんどのGoプログラムで使われます。\n- マップ (Map): キーと値のペアを格納するデータ型です。\n- 構造体 (Struct): 異なる型のデータをまとめて一つの単位として扱うための複合型です。他の言語のクラスに似ています。\n\n```go\n// 配列の例 (固定長)\nvar a [2]string\na[0] = \"Hello\"\na[1] = \"World\"\nfmt.Println(a[0], a[1]) // Hello World\n\n// スライスの例 (可変長)\ns := []int{1, 2, 3}\ns = append(s, 4, 5) // 要素の追加\nfmt.Println(s) // [1 2 3 4 5]\n\n// マップの例\nm := make(map[string]int)\nm[\"Apple\"] = 100\nm[\"Banana\"] = 200\nfmt.Println(m[\"Apple\"]) // 100\n\n// 構造体の例\ntype Person struct {\n    Name string\n    Age  int\n}\np := Person{Name: \"Bob\", Age: 25}\nfmt.Println(p.Name) // Bob\n```\n\n### 5. 制御構造 🔁\n\nGoの制御構造は非常にシンプルです。\n\n- `if`: 条件分岐に使います。括弧`()`は不要ですが、中括弧`{}`は必須です。\n- `for`: Goにはwhile文がなく、すべてのループはfor文で記述します。\n- `switch`: 複数の条件を簡潔に記述でき、明示的な`break`は不要です。\n\n```go\n// if/elseの例\nif 7%2 == 0 {\n    fmt.Println(\"7 is even\")\n} else {\n    fmt.Println(\"7 is odd\") // 実行される\n}\n\n// forループの例\nsum := 0\nfor i := 1; i \u003C= 10; i++ {\n    sum += i\n}\nfmt.Println(sum) // 55\n\n// switchの例\ni := 2\nswitch i {\ncase 1:\n    fmt.Println(\"one\")\ncase 2:\n    fmt.Println(\"two\") // 実行される\ncase 3:\n    fmt.Println(\"three\")\n}\n```\n\n### 6. ポインタ 📍\n\nGoはポインタをサポートしますが、C言語とは異なり、算術演算はできません。\n\n- `&`: 変数のメモリアドレスを取得します。\n- `*`: ポインタが指す先の値にアクセスします。\n\n```go\n// ポインタの例\ni := 10\np := &i       // iのメモリアドレスをポインタpに代入\nfmt.Println(*p) // pが指す値（10）を出力\n*p = 20       // pが指すiの値を20に変更\nfmt.Println(i)  // 20\n```\n\n### 7. 並行処理の基本 🧵\n\nGoの並行処理は言語レベルで組み込まれています。\n\n- Goroutine: 軽量なスレッドで、`go`キーワードを使って関数を非同期で実行します。\n- Channel: 複数のGoroutine間で安全にデータをやり取りするためのパイプです。Goの設計思想である「通信によってメモリを共有する」を実現します。\n\n```go\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n// Goroutineの例\nfunc say(s string) {\n    for i := 0; i \u003C 2; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say(\"world\") // バックグラウンドで実行\n    say(\"hello\")     // メインのゴルーチンで実行\n\n    // Channelの例\n    messages := make(chan string)\n    go func() { messages \u003C- \"ping\" }() // 別ゴルーチンでチャネルに値を送信\n    msg := \u003C-messages // メインゴルーチンでチャネルから値を受信\n    fmt.Println(msg)  // ping\n}\n```","src/content/docs/Goガイド/02_基本/Goの基本構文.mdx","51d2f7360f1fe069","goガイド/02_基本/goのフォルダ構成",{"id":1661,"data":1663,"body":1668,"filePath":1669,"digest":1670,"deferredRender":16},{"title":1664,"editUrl":16,"head":1665,"template":18,"sidebar":1666,"pagefind":16,"draft":20},"Goのフォルダ構成",[],{"hidden":20,"attrs":1667},{},"## Goの標準的なフォルダ構成ガイド 📂\n\nGoには厳格なルールはありませんが、プロジェクトのスケーラビリティとメンテナンス性を高めるためのベストプラクティスがコミュニティで共有されています。\n\n### 1. 主要なディレクトリの役割\n\n大規模なプロジェクトでは、以下のディレクトリ構成が一般的です。\n\n- `cmd/`: サーバーやCLIツールなど、実行可能なアプリケーションのエントリーポイントを置きます。各サブディレクトリが独立した実行可能ファイルに対応します。\n- `internal/`: プロジェクトの内部ロジックを格納します。Goのツールは、このディレクトリ内のコードが外部プロジェクトからインポートされるのを防ぐため、アプリケーションのコアな部分を保護できます。\n- `pkg/`: 汎用的なヘルパー関数や共通ライブラリなど、他のプロジェクトからも再利用可能な公開コードを置きます。\n- `configs/`: 環境変数やデータベース接続情報など、アプリケーションの設定ファイルを一元管理します。\n- `docs/`: API仕様書や設計ドキュメントなど、プロジェクトのドキュメントを格納します。\n\n### 2. 大規模プロジェクトの構成例\n\nプロジェクトの目的（APIか、バッチ処理かなど）に応じて、`internal`内の構造をさらに細かく分けます。\n\n#### APIサーバーの構成例 🏢\n\nAPIを主体とするプロジェクトでは、**関心事の分離（Separation of Concerns）**を徹底します。\n\n```\n/my-api-project\n├── cmd/\n│   └── api/\n│       └── main.go           # サーバー起動コード\n├── internal/\n│   ├── app/                    # アプリケーションのコアロジック\n│   │   ├── handler/            # HTTPリクエストのハンドラ\n│   │   ├── service/            # ビジネスロジック\n│   │   └── repository/         # データベース操作\n│   └── middleware/             # 認証やロギングなどの共通処理\n├── api/\n│   ├── openapi/\n│   │   └── openapi.yaml        # OpenAPI定義\n│   └── proto/                  # gRPCの定義ファイル\n└── go.mod\n```\n\n#### バッチ/CLIツールの構成例 💻\n\n複数の実行ファイルがある場合、各プログラムの役割を明確にします。\n\n```\n/my-batch-project\n├── cmd/\n│   ├── process-data/\n│   │   └── main.go           # データ処理バッチ\n│   └── worker-cli/\n│       └── main.go           # CLIツール\n├── internal/\n│   └── core/\n│       └── logic.go          # 複数のcmdで共有されるロジック\n├── pkg/\n│   └── job/\n│       └── job.go            # 再利用可能なジョブ処理ライブラリ\n└── go.mod\n```\n\n### 3. サンプルコード: ミドルウェアの追加 (CORS)\n\n`internal/middleware/cors.go`にCORS設定を実装し、`cmd/api/main.go`でミドルウェアとして利用する例です。\n\n#### internal/middleware/cors.go:\n\n```go\npackage middleware\n\nimport (\n    \"net/http\"\n)\n\n// CORSミドルウェア\nfunc CORS(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // すべてのオリジンからのリクエストを許可\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        // 許可するHTTPメソッド\n        w.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n        // 許可するヘッダー\n        w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n        // OPTIONSリクエスト（プリフライトリクエスト）の場合、200を返して終了\n        if r.Method == \"OPTIONS\" {\n            w.WriteHeader(http.StatusOK)\n            return\n        }\n\n        // 次のハンドラにリクエストを渡す\n        next.ServeHTTP(w, r)\n    })\n}\n```\n\n#### cmd/api/main.go:\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"my-api-project/internal/app/handler\"\n    \"my-api-project/internal/middleware\"\n)\n\nfunc main() {\n    // ユーザーハンドラの初期化\n    userHandler := handler.NewUserHandler()\n\n    // ルーターとミドルウェアの設定\n    router := http.NewServeMux()\n    router.HandleFunc(\"/users\", userHandler.GetUsers)\n\n    // CORSミドルウェアを適用\n    wrappedRouter := middleware.CORS(router)\n\n    log.Println(\"Server is running on :8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", wrappedRouter))\n}\n```\n\nこのように、Goのフォルダ構成は、関心事を分離し、コードをモジュール化することで、大規模なシステム開発を効率的に進めるための鍵となります。","src/content/docs/Goガイド/02_基本/Goのフォルダ構成.mdx","221856675612d350","goガイド/02_基本/goの汎用モジュール",{"id":1671,"data":1673,"body":1678,"filePath":1679,"digest":1680,"deferredRender":16},{"title":1674,"editUrl":16,"head":1675,"template":18,"sidebar":1676,"pagefind":16,"draft":20},"Goの汎用モジュール",[],{"hidden":20,"attrs":1677},{},"## Goの汎用的なモジュールについて 📦\n\nGoの「モジュール（modules）」は、依存関係の管理とバージョン管理を担う単位です。Go 1.11以降、Go Modulesが公式な標準となり、プロジェクトをシンプルに管理できるようになりました。\n\nここでは、Goで開発する際によく使われる汎用的な外部モジュールをいくつか紹介します。これらのモジュールは、Goの標準ライブラリだけではカバーしきれない、より高度な機能を提供します。\n\n### Web開発\n\n#### Echo\n\n軽量で高速なWebフレームワークです。シンプルなAPIサーバーから大規模なアプリケーションまで、幅広い用途に対応しています。ミドルウェアのサポートが豊富で、ルーティングやJSONの扱いが非常に簡単です。\n\n```go\npackage main\n\nimport (\n    \"net/http\"\n    \"github.com/labstack/echo/v4\"\n)\n\nfunc main() {\n    e := echo.New()\n    e.GET(\"/\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"Hello, World!\")\n    })\n    e.Logger.Fatal(e.Start(\":1323\"))\n}\n```\n\n#### Gin\n\nEchoと同様に、非常に高速なWebフレームワークです。パフォーマンスを重視しており、API構築に特化しています。シンプルなAPIから複雑なマイクロサービスまで、スケーラブルな開発に適しています。\n\n#### go-chi\n\nミニマリストなWebルーターです。シンプルさを追求しており、ミドルウェアを簡単に組み合わせて柔軟なAPIを構築できます。複雑なフレームワークを避けたい場合に適しています。\n\n### データベース\n\n#### GORM\n\nGoのORM (Object-Relational Mapping) ライブラリです。構造体を使ってデータベースのテーブルを定義し、Goのコードでデータベース操作を直感的に行えます。SQLクエリを直接書く必要がほとんどなく、開発効率が向上します。\n\n```go\npackage main\n\nimport (\n    \"gorm.io/gorm\"\n    \"gorm.io/driver/sqlite\"\n)\n\ntype Product struct {\n    gorm.Model\n    Code  string\n    Price uint\n}\n\nfunc main() {\n    db, _ := gorm.Open(sqlite.Open(\"test.db\"), &gorm.Config{})\n    db.AutoMigrate(&Product{})\n\n    db.Create(&Product{Code: \"D42\", Price: 100})\n}\n```\n\n#### sqlx\n\nGoの標準データベース/SQLパッケージ`database/sql`の拡張版です。`database/sql`よりも使いやすく、Goの構造体とデータベースの行を簡単にマッピングできます。ORMのような抽象化は避けつつ、より効率的にSQLを扱いたい場合に便利です。\n\n### 環境設定と設定ファイル\n\n#### Viper\n\n12 Factor Appを意識した、設定管理ライブラリです。JSON, YAML, TOMLなど様々な形式の設定ファイルを扱え、環境変数やコマンドライン引数からの値も簡単に読み込めます。\n\n#### godotenv\n\n.envファイルから環境変数を読み込むためのシンプルで軽量なライブラリです。開発環境と本番環境で設定を切り替えたい場合に非常に便利です。\n\n### その他の汎用ツール\n\n#### Testify\n\nGoの標準テストパッケージ`testing`を拡張するライブラリです。豊富なアサーション（`assert.Equal`, `assert.Nil`など）を提供し、テストコードをより読みやすく、書きやすくします。\n\n#### go-uuid\n\nUUID（Universally Unique Identifier）を生成するためのライブラリです。一意なIDが必要な場合に利用します。\n\nこれらのモジュールは、Goのエコシステムを支える重要なコンポーネントであり、多くのプロジェクトで採用されています。プロジェクトの要件に合わせて適切なモジュールを選ぶことで、開発をより効率的に進めることができるでしょう。\n\n### その他の汎用的なモジュール 📦\n\n#### エラーハンドリングとロギング\n\nGoの標準ライブラリは強力ですが、より詳細なエラー情報や構造化ロギングが必要になることがあります。\n\n- `pkg/errors`: Goの標準エラーパッケージを補完するもので、エラーにスタックトレース（呼び出し履歴）を付加できます。これにより、エラーがどこで発生し、どのように伝播したかを追跡しやすくなります。\n- `zerolog`: 非常に高速で、メモリ使用量が少ない構造化ロギングライブラリです。ログデータをJSON形式で出力するため、ELK Stack（Elasticsearch, Logstash, Kibana）などのログ分析ツールとの相性が抜群です。\n\n```go\npackage main\n\nimport (\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    log.Info().\n        Str(\"name\", \"John\").\n        Int(\"age\", 30).\n        Msg(\"User logged in\")\n    // 出力例: {\"level\":\"info\",\"name\":\"John\",\"age\":30,\"message\":\"User logged in\"}\n}\n```\n\n### 設定管理\n\nアプリケーションの設定を柔軟に管理することは、開発とデプロイの効率を大きく左右します。\n\n- `Viper`: 多くの設定ソース（ファイル、環境変数、リモート設定サービスなど）をサポートする強力な設定管理ライブラリです。YAMLやJSONなど、さまざまな形式に対応しています。\n- `godotenv`: ローカル開発でよく使われる.envファイルから環境変数を簡単に読み込むためのシンプルなモジュールです。\n\n### 外部APIとの通信\n\n外部サービスと通信する際に役立つHTTPクライアントライブラリです。\n\n- `resty`: Goの標準`net/http`パッケージをラップしたHTTPクライアントです。メソッドチェーンを使ってリクエストを簡単に構築でき、JSON/XMLの処理やエラーハンドリングが簡潔に書けます。\n\n```go\npackage main\n\nimport (\n    \"github.com/go-resty/resty/v2\"\n    \"log\"\n)\n\nfunc main() {\n    client := resty.New()\n    resp, err := client.R().\n        SetHeader(\"Accept\", \"application/json\").\n        Get(\"https://api.github.com/users/google\")\n\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Println(\"Status Code:\", resp.StatusCode())\n    log.Println(\"Body:\", resp)\n}\n```\n\nこれらのモジュールは、Goの標準ライブラリの機能を補完し、開発をより迅速かつ効率的にするためのものです。プロジェクトの要件に応じて、適切なものを選択することが重要です。","src/content/docs/Goガイド/02_基本/Goの汎用モジュール.mdx","f6f0ee3790c2a7ca","goガイド/02_基本/メソッドとインターフェース",{"id":1681,"data":1683,"body":1688,"filePath":1689,"digest":1690,"deferredRender":16},{"title":1684,"editUrl":16,"head":1685,"template":18,"sidebar":1686,"pagefind":16,"draft":20},"Goのメソッドとインターフェース",[],{"hidden":20,"attrs":1687},{},"## メソッドとインターフェース\n\nGoはクラスを持たないため、メソッドは構造体や他のユーザー定義型に紐づけられます。また、インターフェースは特定の振る舞いを定義する契約のようなもので、型がその振る舞いを暗黙的に実装することで満たされます。\n\n### メソッド ✍️\n\nメソッドは、レシーバー引数を持つ特殊な関数です。このレシーバー引数により、メソッドは特定の型に関連付けられます。メソッドは、その型が持つデータを操作したり、その型の振る舞いを定義したりするために使われます。\n\n```go\n// Userという構造体を定義\ntype User struct {\n    Name  string\n    Age   int\n}\n\n// User構造体にSayHelloメソッドを定義\n// (u User) がレシーバー引数\nfunc (u User) SayHello() {\n    fmt.Printf(\"Hello, my name is %s and I'm %d years old.\\n\", u.Name, u.Age)\n}\n```\n\nこのSayHelloメソッドは、User型のインスタンスに対してのみ呼び出すことができます。\n\n```go\n// メソッドの呼び出し\nuser := User{Name: \"Alice\", Age: 30}\nuser.SayHello()\n```\n\n### インターフェース 🤝\n\nインターフェースは、メソッドのシグネチャ（名前、引数、戻り値）の集合を定義する型です。Goのインターフェースは暗黙的に実装される点が特徴です。つまり、ある型がインターフェースに定義されたすべてのメソッドを実装していれば、その型は自動的にそのインターフェースを満たすと見なされます。implementsのような明示的なキーワードは不要です。\n\n```go\n// Greeterインターフェースを定義\ntype Greeter interface {\n    SayHello()\n}\n\n// User構造体は既にSayHello()メソッドを実装しているため、Greeterインターフェースを満たす\nfunc Greet(g Greeter) {\n    g.SayHello()\n}\n\nfunc main() {\n    user := User{Name: \"Alice\", Age: 30}\n    \n    // Greet関数はGreeterインターフェースを受け取る\n    // UserはGreeterを暗黙的に実装しているため、引数として渡せる\n    Greet(user)\n}\n```\n\nこの「暗黙的な実装」の仕組みは、Goが疎結合なコードを構築する上で非常に重要です。関数やメソッドは具体的な型ではなくインターフェースに依存することで、異なる実装を持つ型を柔軟に扱うことができるようになります。\n\nこれらの概念を理解することで、Goの型システムが単なるデータ構造の定義にとどまらず、振る舞いを基にした柔軟な設計を可能にしていることがわかります。\n\n### ポインタレシーバーと値レシーバー\n\nGoのメソッドには、ポインタレシーバーと値レシーバーという重要な違いがあります。これは、メソッド内でレシーバーの値を変更するかどうかを決定する上で非常に重要です。\n\n#### ポインタレシーバー (u *User)\n\nポインタレシーバーを使用すると、メソッド内でレシーバーの元の値を変更できます。これは、メソッドがレシーバーのメモリ上のアドレスを参照するためです。\n\n```go\ntype User struct {\n    Name string\n    Age  int\n}\n\n// Ageを1増やすメソッド\nfunc (u *User) IncrementAge() {\n    u.Age++ // レシーバーの元のAgeを直接変更する\n}\n\nfunc main() {\n    user := User{Name: \"Alice\", Age: 30}\n    user.IncrementAge()\n    fmt.Println(user.Age) // 出力: 31\n}\n```\n\nこの場合、IncrementAgeメソッドはuser変数のAgeを直接変更します。\n\n#### 値レシーバー (u User)\n\n値レシーバーを使用すると、メソッドはレシーバーの値のコピーを受け取ります。このため、メソッド内でレシーバーの値を変更しても、元の変数には影響がありません。\n\n```go\ntype User struct {\n    Name string\n    Age  int\n}\n\n// Ageを1増やすメソッド\nfunc (u User) IncrementAge() {\n    u.Age++ // レシーバーのコピーを変更する\n}\n\nfunc main() {\n    user := User{Name: \"Alice\", Age: 30}\n    user.IncrementAge()\n    fmt.Println(user.Age) // 出力: 30\n}\n```\n\nこの場合、IncrementAgeはuserのコピーを操作するため、元のuserのAgeは変わりません。\n\n### どちらを使うべきか？\n\n一般的に、以下のガイドラインに従うと良いでしょう。\n\n- **ポインタレシーバー**:\n  - メソッド内でレシーバーのフィールドを変更する必要がある場合。\n  - 構造体が大きい場合（値のコピーを避けるため、パフォーマンスが向上します）。\n  - スライスやマップ、チャネルなど、参照型のフィールドを持つ構造体の場合。\n\n- **値レシーバー**:\n  - メソッドがレシーバーの値を変更しない場合。\n  - メソッド内でレシーバーのコピーを操作したい場合（元の値を保護するため）。","src/content/docs/Goガイド/02_基本/メソッドとインターフェース.mdx","5f37b0df7e5251a6","goガイド/02_基本/型定義/ジェネリクスとany型",{"id":1691,"data":1693,"body":1698,"filePath":1699,"digest":1700,"deferredRender":16},{"title":1694,"editUrl":16,"head":1695,"template":18,"sidebar":1696,"pagefind":16,"draft":20},"GoのGenerics（ジェネリクス）とany型",[],{"hidden":20,"attrs":1697},{},"Generics（ジェネリクス） ✨\nGo 1.18で導入されたジェネリクスは、特定の型に依存しない関数やデータ型を記述することを可能にします。これにより、同じロジックを異なる型で再利用できるため、コードの重複を減らし、より安全なプログラムを構築できます。\n\nジェネリクスを使用しない場合:\n\n異なる型のスライスに対して同じSum関数を実装するには、それぞれの型ごとにコードを書く必要がありました。\n\nGo\n\nfunc SumInts(m map[string]int64) int64 {\n    var s int64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\nfunc SumFloats(m map[string]float64) float64 {\n    var s float64\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\nジェネリクスを使用する場合:\n\ncomparable や any といった型引数（type parameters） と 型制約（type constraints） を使うことで、1つの関数で複数の型を扱えます。\n\nGo\n\n// Numbersインターフェースで型をint64とfloat64に制約\ntype Numbers interface {\n    int64 | float64\n}\n\n// ジェネリックなSum関数\nfunc Sum[T comparable, V Numbers](m map[T]V) V {\n    var s V\n    for _, v := range m {\n        s += v\n    }\n    return s\n}\n\nfunc main() {\n    ints := map[string]int64{\"a\": 1, \"b\": 2}\n    floats := map[string]float64{\"c\": 3.0, \"d\": 4.0}\n\n    fmt.Println(Sum(ints))   // int64型で呼び出し\n    fmt.Println(Sum(floats)) // float64型で呼び出し\n}\nこの例では、Sum関数はint64とfloat64のどちらのスライスでも動作し、コンパイル時に型安全性が保証されます。\n\nany 型の導入（interface{}の別名）\nGo 1.18から、interface{} の別名として**any**が導入されました。これは機能的に全く同じですが、よりシンプルで読みやすいです。\n\ninterface{} を使用する場合:\n\nGo\n\nfunc printValue(v interface{}) {\n    fmt.Printf(\"Value: %v, Type: %T\\n\", v, v)\n}\nany を使用する場合:\n\nGo\n\nfunc printValue(v any) {\n    fmt.Printf(\"Value: %v, Type: %T\\n\", v, v)\n}\nanyは、interface{}と同じく、どんな型の値でも受け取ることができます。この変更は、interface{}が持つ「どんな型でも受け入れる」という性質をより明確に表現することを目的としています。\n\nこれらの新しい概念は、Goの型システムをより強力かつ柔軟なものにしました。ジェネリクスとany型を理解することで、より現代的で再利用性の高いGoコードを書くことができます。\n\n\n\n\n\n\n\n\n\n\n\n\nDeep Research\n\n画像\n\nCanvas\n\nガイド付き学習","src/content/docs/Goガイド/02_基本/型定義/ジェネリクスとany型.mdx","8e34f199fc0d6658","goガイド/02_基本/型定義/型アサーション",{"id":1701,"data":1703,"body":1708,"filePath":1709,"digest":1710,"deferredRender":16},{"title":1704,"editUrl":16,"head":1705,"template":18,"sidebar":1706,"pagefind":16,"draft":20},"Goの空のインターフェースと型アサーション",[],{"hidden":20,"attrs":1707},{},"空のインターフェースと型アサーション 💡\nGoのインターフェースは、メソッドを全く定義しない空の状態にすることができます。これを空のインターフェース (interface{})と呼びます。空のインターフェースは、Goのすべての型を満たすため、どんな型の値でも格納できます。\n\nGo\n\nvar i interface{}\ni = \"Hello\" // iはstring型を保持\ni = 42      // iはint型を保持\ni = true    // iはbool型を保持\nこれは非常に柔軟ですが、そのままでは格納された値の具体的な型やメソッドを知ることができません。そこで、型アサーションを使って、空のインターフェースに格納された値を本来の型に戻す必要があります。\n\n型アサーション\n型アサーションは、インターフェースの値が特定の具象型を保持していることを確認し、その値を抽出する操作です。value.(Type)という構文を使用します。\n\nGo\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{} = \"Hello, World\"\n\n    // 型アサーション\n    s, ok := i.(string) // iはstring型か？\n    if ok {\n        fmt.Println(\"iは文字列です:\", s)\n    } else {\n        fmt.Println(\"iは文字列ではありません\")\n    }\n\n    // 存在しない型をアサートするとパニックを起こす\n    // f := i.(float64) // この行を実行するとエラー\n}\nこの例のok変数は、アサーションが成功したかどうかを示す真偽値です。この二値返却の構文を使うことで、安全に型アサーションを行うことができます。\n\nswitchによる型チェック\nswitch文を使うことで、より簡潔に複数の型をチェックできます。\n\nGo\n\nfunc printType(i interface{}) {\n    switch v := i.(type) {\n    case string:\n        fmt.Printf(\"文字列です: %s\\n\", v)\n    case int:\n        fmt.Printf(\"整数です: %d\\n\", v)\n    case bool:\n        fmt.Printf(\"ブール値です: %t\\n\", v)\n    default:\n        fmt.Printf(\"未知の型です: %T\\n\", v)\n    }\n}\n\nfunc main() {\n    printType(\"go\")\n    printType(10)\n    printType(true)\n    printType(1.23)\n}\nこのswitch構文は、空のインターフェースを扱う際の一般的なパターンです。これにより、意図しない型が渡された場合でも、安全に処理を分岐させることができます。\n\nこれらの概念は、JSONデコードや、異なるデータ型を扱う汎用的な関数を書く際に非常に役立ちます。\n\n型の埋め込み (Embedding) 🧬\nGoの**埋め込み（embedding）**は、他の言語における「継承」のような概念をシンプルに実現する仕組みです。ある構造体に別の構造体やインターフェースを無名で埋め込むことで、埋め込まれた型のフィールドやメソッドを直接利用できるようになります。\n\nGo\n\npackage main\n\nimport \"fmt\"\n\n// Engineという型を定義\ntype Engine struct {\n    Horsepower int\n}\n\nfunc (e Engine) Start() {\n    fmt.Println(\"Engine starting...\")\n}\n\n// Car型にEngineを埋め込み\ntype Car struct {\n    Engine // Engine型を無名で埋め込み\n    Model  string\n}\n\nfunc main() {\n    // Carのインスタンスを作成\n    c := Car{\n        Engine: Engine{Horsepower: 200},\n        Model:  \"Sedan\",\n    }\n\n    // CarのインスタンスからEngineのメソッドとフィールドに直接アクセス\n    c.Start()\n    fmt.Println(\"Horsepower:\", c.Horsepower)\n}\nこの例では、Car型がEngine型のフィールドとメソッドを継承しているかのように振る舞います。これにより、コードの再利用性を高めつつ、複雑な継承階層を避けることができます。\n\nインターフェースのnil値 ⚖️\nGoのインターフェースは、**値（value）と具象型（concrete type）**の2つの要素で構成されます。この特性により、インターフェース変数がnilであるかどうかの判断が直感的ではない場合があります。\n\nGo\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{}\n    var p *int\n\n    // iに具象型pを代入。pはnilだが、iはnilではない\n    i = p\n\n    // pはnil\n    fmt.Println(\"p is nil:\", p == nil)\n\n    // iはnilではない！\n    fmt.Println(\"i is nil:\", i == nil)\n\n    // iの中身は、具象型(*int)と値(nil)\n    fmt.Println(\"i's value is nil:\", i) \n}\nこの出力はp is nil: trueとi is nil: falseとなります。これは、インターフェースが具象型を保持している限り、たとえその具象型の値がnilであっても、インターフェース変数自体はnilと見なされないためです。インターフェースが本当にnilと判定されるのは、具象型と値の両方がnilの場合だけです。この挙動は、Goのインターフェースを扱う上で注意すべき点です。\n\n---\ntitle: \"Goの空のインターフェースと型アサーション\"\nlabel: \"Goの空のインターフェースと型アサーション\"\n---\n\n空のインターフェースと型アサーション 💡\nGoのインターフェースは、メソッドを全く定義しない空の状態にすることができます。これを空のインターフェース (interface{})と呼びます。空のインターフェースは、Goのすべての型を満たすため、どんな型の値でも格納できます。\n\nGo\n\nvar i interface{}\ni = \"Hello\" // iはstring型を保持\ni = 42      // iはint型を保持\ni = true    // iはbool型を保持\nこれは非常に柔軟ですが、そのままでは格納された値の具体的な型やメソッドを知ることができません。そこで、型アサーションを使って、空のインターフェースに格納された値を本来の型に戻す必要があります。\n\n型アサーション\n型アサーションは、インターフェースの値が特定の具象型を保持していることを確認し、その値を抽出する操作です。value.(Type)という構文を使用します。\n\nGo\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{} = \"Hello, World\"\n\n    // 型アサーション\n    s, ok := i.(string) // iはstring型か？\n    if ok {\n        fmt.Println(\"iは文字列です:\", s)\n    } else {\n        fmt.Println(\"iは文字列ではありません\")\n    }\n\n    // 存在しない型をアサートするとパニックを起こす\n    // f := i.(float64) // この行を実行するとエラー\n}\nこの例のok変数は、アサーションが成功したかどうかを示す真偽値です。この二値返却の構文を使うことで、安全に型アサーションを行うことができます。\n\nswitchによる型チェック\nswitch文を使うことで、より簡潔に複数の型をチェックできます。\n\nGo\n\nfunc printType(i interface{}) {\n    switch v := i.(type) {\n    case string:\n        fmt.Printf(\"文字列です: %s\\n\", v)\n    case int:\n        fmt.Printf(\"整数です: %d\\n\", v)\n    case bool:\n        fmt.Printf(\"ブール値です: %t\\n\", v)\n    default:\n        fmt.Printf(\"未知の型です: %T\\n\", v)\n    }\n}\n\nfunc main() {\n    printType(\"go\")\n    printType(10)\n    printType(true)\n    printType(1.23)\n}\nこのswitch構文は、空のインターフェースを扱う際の一般的なパターンです。これにより、意図しない型が渡された場合でも、安全に処理を分岐させることができます。\n\nこれらの概念は、JSONデコードや、異なるデータ型を扱う汎用的な関数を書く際に非常に役立ちます。\n\n型の埋め込み (Embedding) 🧬\nGoの**埋め込み（embedding）**は、他の言語における「継承」のような概念をシンプルに実現する仕組みです。ある構造体に別の構造体やインターフェースを無名で埋め込むことで、埋め込まれた型のフィールドやメソッドを直接利用できるようになります。\n\nGo\n\npackage main\n\nimport \"fmt\"\n\n// Engineという型を定義\ntype Engine struct {\n    Horsepower int\n}\n\nfunc (e Engine) Start() {\n    fmt.Println(\"Engine starting...\")\n}\n\n// Car型にEngineを埋め込み\ntype Car struct {\n    Engine // Engine型を無名で埋め込み\n    Model  string\n}\n\nfunc main() {\n    // Carのインスタンスを作成\n    c := Car{\n        Engine: Engine{Horsepower: 200},\n        Model:  \"Sedan\",\n    }\n\n    // CarのインスタンスからEngineのメソッドとフィールドに直接アクセス\n    c.Start()\n    fmt.Println(\"Horsepower:\", c.Horsepower)\n}\nこの例では、Car型がEngine型のフィールドとメソッドを継承しているかのように振る舞います。これにより、コードの再利用性を高めつつ、複雑な継承階層を避けることができます。\n\nインターフェースのnil値 ⚖️\nGoのインターフェースは、**値（value）と具象型（concrete type）**の2つの要素で構成されます。この特性により、インターフェース変数がnilであるかどうかの判断が直感的ではない場合があります。\n\nGo\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{}\n    var p *int\n\n    // iに具象型pを代入。pはnilだが、iはnilではない\n    i = p\n\n    // pはnil\n    fmt.Println(\"p is nil:\", p == nil)\n\n    // iはnilではない！\n    fmt.Println(\"i is nil:\", i == nil)\n\n    // iの中身は、具象型(*int)と値(nil)\n    fmt.Println(\"i's value is nil:\", i) \n}\nこの出力はp is nil: trueとi is nil: falseとなります。これは、インターフェースが具象型を保持している限り、たとえその具象型の値がnilであっても、インターフェース変数自体はnilと見なされないためです。インターフェースが本当にnilと判定されるのは、具象型と値の両方がnilの場合だけです。この挙動は、Goのインターフェースを扱う上で注意すべき点です。\n\n型アサーションの安全な使用方法 🛡️\n提供されたコード例では、s, ok := i.(string)という二値返却の構文を使って安全な型アサーションを行っています。これは、アサーションが成功したかどうかをok変数で確認できるため、Goで推奨される方法です。\n\nもし、このok変数を無視して単一の値でアサーションを実行すると、アサーションが失敗した場合にランタイムパニックが発生します。\n\nGo\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{} = 42\n\n    // アサーション失敗により、ランタイムパニックが発生\n    s := i.(string) \n    fmt.Println(s)\n}\nこのコードを実行すると、「interface conversion: interface {} is int, not string」というエラーメッセージとともにプログラムが異常終了します。\n\nそのため、安全に型を扱うには、常に二値返却のs, ok := i.(string)を使用するか、型スイッチを利用することが不可欠です。\n\n型スイッチの高度な使い方 💡\n型スイッチは、単に型を判別するだけでなく、インターフェースに格納された値そのものを効率的に操作するために使われます。switch v := i.(type)構文を使用すると、v変数は各caseブロック内で、そのcaseに対応する具象型に自動的に変換されます。\n\nGo\n\npackage main\n\nimport \"fmt\"\n\ntype Speaker interface {\n    Speak()\n}\n\ntype Cat struct{}\nfunc (c Cat) Speak() { fmt.Println(\"Meow\") }\n\ntype Dog struct{}\nfunc (d Dog) Speak() { fmt.Println(\"Woof\") }\n\nfunc main() {\n    animals := []interface{}{Cat{}, Dog{}, \"Hello\"}\n\n    for _, a := range animals {\n        // 型スイッチで型を判定し、Speakメソッドを呼び出す\n        switch s := a.(type) {\n        case Speaker: // インターフェースを満たすかどうかの判定\n            s.Speak() // 自動的に具象型に変換され、メソッドが実行される\n        case string:\n            fmt.Printf(\"これは文字列です: %s\\n\", s)\n        default:\n            fmt.Println(\"不明な型です\")\n        }\n    }\n}\nこの例では、case Speaker:というブロックが、CatとDogのどちらの型も受け入れることができます。s変数はSpeakerインターフェース型に変換されるため、s.Speak()を安全に呼び出せます。これは、Goのポリモーフィズム（多態性）をエレガントに実現する強力なパターンです。","src/content/docs/Goガイド/02_基本/型定義/型アサーション.mdx","5182a3e6d350ce38","goガイド/02_基本/型定義/型定義",{"id":1711,"data":1713,"body":1718,"filePath":1719,"digest":1720,"deferredRender":16},{"title":1714,"editUrl":16,"head":1715,"template":18,"sidebar":1716,"pagefind":16,"draft":20},"Goの型定義",[],{"hidden":20,"attrs":1717},{},"## Goの型定義について 📝\n\nGoは静的型付け言語であり、変数の型を明確に定義することが求められます。これにより、コンパイル時にエラーを検出しやすくなり、堅牢なプログラムを作成できます。Goの型は、大別してプリミティブ型と複合型に分けられます。\n\n### 1. プリミティブ型（基本型）\n\nGoに最初から組み込まれている基本的なデータ型です。\n\n- **数値型**: 整数（`int`, `int8`, `int16`, `int32`, `int64`）と浮動小数点数（`float32`, `float64`）があります。\n- **文字列型**: `string`型で、UTF-8エンコードされた文字列を扱います。\n- **真偽値型**: `bool`型で、`true`または`false`の値を持ちます。\n\n### 2. 複合型（ユーザー定義型）\n\nGoは、プリミティブ型を組み合わせて独自の型を定義する機能を提供します。\n\n#### 構造体（Struct） 🧩\n\n構造体は、異なる型のフィールドをまとめて一つの新しい型として定義するものです。これは、他の言語のクラスやオブジェクトに似ていますが、メソッドやインターフェースの概念と組み合わせて使われます。\n\n```go\ntype User struct {\n    Name  string\n    Age   int\n    Email string\n}\n```\n\n構造体は、データを関連付けて管理するのに非常に役立ちます。\n\n#### 配列（Array）とスライス（Slice） 📚\n\n- **配列（Array）**: 固定長のデータ型で、宣言時にサイズが確定します。\n\n```go\nvar a [3]int // int型の要素を3つ持つ配列\n```\n\n- **スライス（Slice）**: 可変長のデータ型です。内部的には配列を参照しており、より柔軟なデータ操作を可能にします。Goでリストを扱う際は、ほとんどの場合スライスが使われます。\n\n```go\ns := []int{1, 2, 3} // 要素を動的に追加可能\ns = append(s, 4)\n```\n\n#### マップ（Map） 🗺️\n\nキーと値のペアを管理するデータ型です。他の言語のハッシュマップやディクショナリに相当します。\n\n```go\nm := make(map[string]int)\nm[\"apple\"] = 1\nm[\"banana\"] = 2\n```\n\n### 3. 型の定義と型エイリアス\n\nGoでは、`type`キーワードを使って新しい型を定義したり、既存の型に別名をつけたりすることができます。\n\n#### 新しい型の定義\n\n既存の型（例: `int`）をベースに、新しい独自の型を定義することで、型安全性を高めることができます。\n\n```go\ntype UserID int\n\nfunc main() {\n    var id1 UserID = 123\n    var id2 int = 456\n\n    // コンパイルエラー: UserID型とint型は別物として扱われる\n    // id1 = id2\n}\n```\n\nこの例では、`UserID`と`int`は互換性がないため、誤った代入を防げます。\n\n#### 型エイリアス（Type Alias）\n\n既存の型に単に別名をつける機能です。元の型と完全に互換性があります。\n\n```go\ntype UserName = string\n\nfunc main() {\n    var name1 UserName = \"Alice\"\n    var name2 string = \"Bob\"\n\n    // 代入が可能：両者は同じ型として扱われる\n    name1 = name2\n}\n```\n\n### まとめ\n\nGoの型システムはシンプルでありながら強力です。プリミティブ型と複合型を適切に使い分け、必要に応じて`type`キーワードで独自の型を定義することで、読みやすく保守しやすいコードを書くことができます。","src/content/docs/Goガイド/02_基本/型定義/型定義.mdx","42935387fd858f0f","goガイド/03_中級/goのtest",{"id":1721,"data":1723,"body":1728,"filePath":1729,"digest":1730,"deferredRender":16},{"title":1724,"editUrl":16,"head":1725,"template":18,"sidebar":1726,"pagefind":16,"draft":20},"Goのtest",[],{"hidden":20,"attrs":1727},{},"## Goのテスト 🧪\n\nGoは、標準ライブラリに組み込まれた**testingパッケージ**により、シンプルかつ強力なテスト機能を提供します。外部ライブラリをほとんど使わずに、テスト、ベンチマーク、例示テストを行うことができます。\n\n### 1. テストの基本\n\nGoのテストは、特定の命名規則に従って書くことが決まっています。\n\n- **ファイル名**: テストコードは、テスト対象のファイル名に**_test.go**を付け加えたファイルに記述します（例: main.goに対するmain_test.go）。\n- **関数名**: テスト関数は**Test**で始まり、その後に続く名前（例: TestSum）は、大文字で始まらなければなりません。引数には*testing.Tを必ず指定します。\n\n#### 基本的なテストコード例\n\nテスト対象のコード (calculator.go)\n\n```go\npackage calculator\n\nfunc Add(a, b int) int {\n    return a + b\n}\n```\n\nテストコード (calculator_test.go)\n\n```go\npackage calculator\n\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n    result := Add(1, 2)\n    expected := 3\n    if result != expected {\n        t.Errorf(\"Add(1, 2) = %d; expected %d\", result, expected)\n    }\n}\n```\n\nこの例では、Add関数の結果が期待値と異なる場合に`t.Errorf`を呼び出し、テスト失敗をレポートします。\n\n### 2. テストの実行と結果\n\nターミナルで`go test`コマンドを実行すると、現在のディレクトリにあるすべての_test.goファイルが自動的に実行されます。\n\n- `go test`: テストを実行します。\n- `go test -v`: 詳細なテスト結果（各テスト関数の実行状況）を表示します。\n- `go test ./...`: サブディレクトリを含めてすべてのテストを実行します。\n\n実行結果は、テストの成功/失敗、実行時間などが簡潔に表示されます。\n\n### 3. テーブル駆動テスト 📊\n\nGoのテストで推奨されるパターンの一つがテーブル駆動テストです。これは、複数のテストケースを構造体スライス（テーブル）で定義し、ループでテストを実行する手法です。これにより、コードの重複を避け、新しいテストケースの追加を簡単にします。\n\n```go\npackage calculator\n\nimport \"testing\"\n\nfunc TestAddTableDriven(t *testing.T) {\n    tests := []struct {\n        name     string\n        a, b     int\n        expected int\n    }{\n        {\"positive numbers\", 1, 2, 3},\n        {\"negative numbers\", -1, -2, -3},\n        {\"zero\", 0, 0, 0},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := Add(tt.a, tt.b)\n            if result != tt.expected {\n                t.Errorf(\"Add(%d, %d) = %d; expected %d\", tt.a, tt.b, result, tt.expected)\n            }\n        })\n    }\n}\n```\n\n`t.Run`を使うことで、サブテストとして各ケースを実行できます。これにより、個々のテストケースが独立して表示され、どのケースが失敗したかを明確に把握できます。\n\n### 4. その他のテスト機能\n\n- **ベンチマークテスト**: 処理のパフォーマンスを測定するテストです。関数名を`BenchmarkXxx`とし、`go test -bench=. `で実行します。\n- **カバレッジ**: テストがどれくらいのコードをカバーしているかを測定します。`go test -cover`で実行でき、`go tool cover -html=cover.out`でHTML形式のレポートを作成できます。\n\nGoのテストは、シンプルながらも強力なツールであり、開発プロセスに組み込むことで、コードの品質と信頼性を大きく向上させます。\n\n### 5. モックとスタブ 🎭\n\nテスト対象の関数がデータベースや外部APIなど、外部の依存関係にアクセスする場合、テストの実行が遅くなったり、結果が不安定になったりします。これを解決するために、モック（Mock）やスタブ（Stub）といったテスト用のダミーオブジェクトを使用します。\n\n- **モック**: 外部サービスを模倣し、テスト中にそのサービスがどのように呼び出されたかを検証します。\n- **スタブ**: 外部サービスからの応答を事前に定義しておき、特定の値を返すようにします。\n\nGoでは、インターフェースを使用することで、モックやスタブを簡単に実装できます。テスト対象のコードが、具体的な構造体ではなくインターフェースに依存するように設計することが重要です。\n\n#### インターフェースを使ったテストの例\n\nテスト対象のサービスコード (service.go)\n\n```go\npackage service\n\ntype DataStore interface {\n    GetData() string\n}\n\ntype MyService struct {\n    store DataStore\n}\n\nfunc (s *MyService) ProcessData() string {\n    data := s.store.GetData()\n    return \"Processed: \" + data\n}\n```\n\nモックを使ったテストコード (service_test.go)\n\n```go\npackage service\n\nimport \"testing\"\n\n// DataStoreインターフェースのモック\ntype MockDataStore struct{}\n\nfunc (m *MockDataStore) GetData() string {\n    return \"mocked data\"\n}\n\nfunc TestProcessDataWithMock(t *testing.T) {\n    mockStore := &MockDataStore{}\n    myService := &MyService{store: mockStore}\n    \n    result := myService.ProcessData()\n    expected := \"Processed: mocked data\"\n    \n    if result != expected {\n        t.Errorf(\"got %s, want %s\", result, expected)\n    }\n}\n```\n\nこの例では、MyServiceがDataStoreインターフェースに依存しているため、テスト時に本物のデータベース接続ではなく、MockDataStoreを注入してテストできます。これにより、テストを高速かつ安定して実行できます。\n\n### 6. 例示テスト（Example Tests）📚\n\nGoのtestingパッケージには、ドキュメントとして機能する特別なテストExampleがあります。これらは`go test`で実行され、出力がコメントと一致するか検証されます。\n\n- **特徴**:\n  - `func ExampleXxx()`という形式で記述します。\n  - テスト結果が、関数の説明や使用例としてドキュメントに表示されます。\n  - `go test`実行時に、コメント内の出力と実際の出力が一致するか確認されます。\n\n#### 例示テストのコード例\n\nテスト対象のコード (greeter.go)\n\n```go\npackage greeter\n\nfunc Greet(name string) string {\n    return \"Hello, \" + name\n}\n```\n\n例示テスト (greeter_test.go)\n\n```go\npackage greeter\n\nimport \"fmt\"\n\nfunc ExampleGreet() {\n    fmt.Println(Greet(\"World\"))\n    // Output: Hello, World\n}\n```\n\nこの例示テストは、`go test`で実行されるだけでなく、`go doc`や`pkg.go.dev`といったドキュメントツールで表示されます。これにより、コードのドキュメントとテストを同時に管理できるという利点があります。\n\n### 7. エラー処理のテスト 🐞\n\nGoでは、関数がエラーを返すことが多いため、エラーが発生した場合のテストケースを適切に書くことが重要です。期待されるエラーが返されるか、あるいはエラーが返されない場合に成功するかを検証します。\n\nテスト対象のコード (divider.go)\n\n```go\npackage divider\n\nimport \"errors\"\n\nfunc Divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New(\"cannot divide by zero\")\n    }\n    return a / b, nil\n}\n```\n\nエラー処理をテストするコード (divider_test.go)\n\n```go\npackage divider\n\nimport (\n    \"errors\"\n    \"testing\"\n)\n\nfunc TestDivide(t *testing.T) {\n    // 成功ケースのテスト\n    t.Run(\"successful division\", func(t *testing.T) {\n        result, err := Divide(10, 2)\n        if err != nil {\n            t.Fatalf(\"Divide(10, 2) returned an error: %v\", err)\n        }\n        if result != 5 {\n            t.Errorf(\"Divide(10, 2) = %d, expected 5\", result)\n        }\n    })\n\n    // エラーケースのテスト\n    t.Run(\"division by zero returns error\", func(t *testing.T) {\n        _, err := Divide(10, 0)\n        if err == nil {\n            t.Fatal(\"Divide(10, 0) did not return an error, but it should have\")\n        }\n        if !errors.Is(err, errors.New(\"cannot divide by zero\")) {\n            t.Errorf(\"unexpected error type: %v\", err)\n        }\n    })\n}\n```\n\nこの例では、`errors.Is`関数を使って、返されたエラーが期待されるエラーと一致するかを厳密に検証しています。\n\n### 8. テストのヘルパー関数 🛠️\n\nテストコードが複雑になり、多くのテスト関数で同じ処理（例えば、テスト環境のセットアップやティアダウン）を繰り返す場合、テストのヘルパー関数を作成すると便利です。ヘルパー関数は通常、`*testing.T`を引数に取り、テストの補助的な役割を担います。\n\n- **特徴**:\n  - `t.Helper()`を呼び出して、テストの呼び出しスタックからヘルパー関数を隠します。これにより、テストが失敗したときにエラーが発生した元のテスト行を正確に特定できます。\n\n#### ヘルパー関数のコード例\n\n```go\npackage myapp\n\nimport \"testing\"\n\n// CheckEqualsは、期待値と結果が一致するかを検証するヘルパー関数\nfunc CheckEquals[T comparable](t *testing.T, got, want T) {\n    t.Helper() // この関数をヘルパーとしてマーク\n    if got != want {\n        t.Errorf(\"got %v, want %v\", got, want)\n    }\n}\n\nfunc TestMyFunction(t *testing.T) {\n    // ヘルパー関数を使ってテストを簡潔に記述\n    CheckEquals(t, \"hello\", \"hello\")\n    CheckEquals(t, 10, 10)\n    \n    // 失敗するケース\n    CheckEquals(t, \"world\", \"gopher\") // この行でエラーが報告される\n}\n```\n\n`t.Helper()`を呼び出すことで、テスト失敗時に`CheckEquals`関数ではなく、`TestMyFunction`の呼び出し元（`CheckEquals`を呼び出した行）がエラーログに表示され、デバッグが容易になります。\n\n### 9. テストでの一時ファイル・ディレクトリの利用 📁\n\nファイルシステムを扱う関数のテストでは、テストの実行ごとにクリーンな環境を確保することが重要です。Goのtestingパッケージは、一時的なファイルやディレクトリを安全に作成・削除するための機能を提供します。これにより、テストがファイルシステムに影響を与えないようにできます。\n\n- **t.TempDir()**:\n  - このメソッドを呼び出すと、テスト実行中のみ有効な一時ディレクトリが作成されます。\n  - テストが終了すると、Goは自動的にそのディレクトリとその中身をすべて削除します。\n\n- **os.CreateTemp**:\n  - `testing`パッケージの外部で一時ファイルを作成する場合に便利です。\n  - `os.CreateTemp`を使って作成したファイルは、テスト終了後に手動で削除する必要があります。\n\n#### 一時ディレクトリを使ったテストの例\n\n```go\npackage myapp\n\nimport (\n    \"os\"\n    \"path/filepath\"\n    \"testing\"\n)\n\n// ファイルに書き込み、内容を読み取る関数（テスト対象）\nfunc WriteAndRead(dir, filename, content string) (string, error) {\n    filePath := filepath.Join(dir, filename)\n    if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {\n        return \"\", err\n    }\n    data, err := os.ReadFile(filePath)\n    if err != nil {\n        return \"\", err\n    }\n    return string(data), nil\n}\n\n// WriteAndRead関数のテスト\nfunc TestWriteAndRead(t *testing.T) {\n    // t.TempDir() を使って一時ディレクトリを作成\n    tempDir := t.TempDir()\n\n    // 作成された一時ディレクトリ内でテストを実行\n    result, err := WriteAndRead(tempDir, \"test.txt\", \"hello world\")\n    if err != nil {\n        t.Fatalf(\"unexpected error: %v\", err)\n    }\n\n    expected := \"hello world\"\n    if result != expected {\n        t.Errorf(\"got %q, want %q\", result, expected)\n    }\n}\n```\n\nこのテストでは、`t.TempDir()`が一時ディレクトリを自動で管理してくれるため、テスト後に手動でクリーンアップする必要がなく、テストコードを簡潔かつ安全に保つことができます。","src/content/docs/Goガイド/03_中級/Goのtest.mdx","97fdc27252482bc0","goガイド/02_基本/goの並行処理と並列処理",{"id":1731,"data":1733,"body":1738,"filePath":1739,"digest":1740,"deferredRender":16},{"title":1734,"editUrl":16,"head":1735,"template":18,"sidebar":1736,"pagefind":16,"draft":20},"Goの並行処理と並列処理",[],{"hidden":20,"attrs":1737},{},"## Goの並行処理と並列処理 🚀\n\nGoは、**ゴルーチン（goroutines）とチャネル（channels）**という独自の機能を通じて、並行処理を簡単に扱えるよう設計されています。これにより、複雑なマルチスレッドプログラミングの課題を回避し、シンプルかつ効率的なプログラムを書くことができます。\n\n### 1. 並行処理（Concurrency）と並列処理（Parallelism）\n\nこの2つの概念は混同されがちですが、Goでは明確に区別されます。\n\n- **並行処理**: 複数のタスクを同時に進行させること。タスクは交互に実行され、見かけ上同時に動いているように見えます。これは、シングルコアCPUでも実現可能です。\n- **並列処理**: 複数のタスクを同時に実行すること。これは、マルチコアCPUでのみ可能です。Goは、Goランタイムが自動的にゴルーチンを複数の論理プロセッサに割り当てることで並列処理を実現します。\n\nGoの哲学は、「並行処理は並列処理とは異なる。並行処理は多くのことを同時に扱うことであり、並列処理は多くのことを同時に実行することである。」というものです。\n\n### 2. ゴルーチン（Goroutines）\n\nゴルーチンは、Goにおける並行処理の基本単位です。OSのスレッドよりもはるかに軽量で、数千、数万のゴルーチンを簡単に生成できます。\n\n- **生成**: `go`キーワードを関数の前に置くだけで、その関数は新しいゴルーチンとして実行されます。\n- **通信の哲学**: Goの並行処理は、**「共有メモリによる通信」ではなく、「通信によるメモリ共有」**という設計思想に基づいています。これにより、従来のマルチスレッドプログラミングで問題になりがちな競合状態（race conditions）を回避できます。\n\n#### コード例: ゴルーチンの簡単な利用\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc say(s string) {\n    for i := 0; i \u003C 3; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say(\"hello\") // ゴルーチンとして実行\n    say(\"world\")    // 通常の関数として実行\n}\n```\n\nこのコードを実行すると、`hello`と`world`が交互に出力されることがわかります。これは、2つのタスクが並行して実行されていることを示しています。\n\n### 3. チャネル（Channels）\n\nチャネルは、ゴルーチン間で安全にデータを送受信するためのパイプです。これにより、ゴルーチン間の同期と通信をシンプルに行えます。\n\n- **作成**: `make(chan Type)`でチャネルを作成します。\n- **送受信**:\n  - `ch \u003C- value`でチャネルに値を送信します。\n  - `\u003C-ch`でチャネルから値を受信します。\n\n#### コード例: ゴルーチンとチャネルの連携\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c \u003C- sum // 結果をチャネルに送信\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n    c := make(chan int)\n\n    // スライスの半分をそれぞれ別のゴルーチンで計算\n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n\n    x, y := \u003C-c, \u003C-c // 2つのチャネルから結果を受信\n    \n    fmt.Println(x, y, x+y) // 実行ごとにxとyの順番が変わる可能性がある\n}\n```\n\nこの例では、2つのゴルーチンがそれぞれ計算した結果をチャネルに送信し、`main`関数がそれらを受信して合計を求めています。\n\n### 4. select文とその他のツール\n\n- **select**: 複数のチャネルの操作を待機し、準備ができた最初の操作を実行します。非同期処理でタイムアウトを設定したり、複数のリソースからデータを処理したりする際に非常に便利です。\n- **syncパッケージ**: チャネルが適さない場合、`sync`パッケージ（`sync.Mutex`, `sync.WaitGroup`など）を使って従来の共有メモリ同期を実装できます。\n\nGoの並行処理は、これらのシンプルで強力なツールによって、複雑なマルチタスク処理を安全かつ効率的に記述することを可能にしています。","src/content/docs/Goガイド/02_基本/Goの並行処理と並列処理.mdx","d5674e78e5681a5d","goガイド/02_基本/レイヤー構成",{"id":1741,"data":1743,"body":1748,"filePath":1749,"digest":1750,"deferredRender":16},{"title":1744,"editUrl":16,"head":1745,"template":18,"sidebar":1746,"pagefind":16,"draft":20},"Goのレイヤー構成",[],{"hidden":20,"attrs":1747},{},"Goにおけるレイヤードアーキテクチャ 🧱\nGoでは、特定のアーキテクチャパターンは強制されませんが、役割ごとにコードを分けるレイヤードアーキテクチャが広く採用されています。これはMVCに似た考え方ですが、Goの設計哲学に沿ったよりシンプルで疎結合な構成です。\n\n図解：Goのレイヤードアーキテクチャの概要\nコード スニペット\n\ngraph TD\n    subgraph \"プレゼンテーション層\"\n        A[リクエスト] --> B(ハンドラ/コントローラ)\n    end\n    \n    subgraph \"ビジネスロジック層\"\n        B --> C{サービス/ユースケース}\n    end\n\n    subgraph \"データ永続化層\"\n        C --> D[リポジトリ/データストア]\n    end\n\n    D --> E[(データベース/外部API)]\n各レイヤーの役割\nハンドラ/コントローラ (プレゼンテーション層)\n\n役割: HTTPリクエストを受け付け、応答を返すインターフェースです。\n\n機能: リクエストの検証、データのパース（JSONなど）、サービスへの処理依頼、レスポンスの生成を行います。\n\nGoでの実装: net/httpパッケージやWebフレームワーク（Echo, Ginなど）のHandler関数やメソッドとして実装されます。\n\nMVCとの比較: MVCの「コントローラ」に相当します。\n\nサービス/ユースケース (ビジネスロジック層)\n\n役割: アプリケーションのコアとなるビジネスロジックを実行します。\n\n機能: データの計算、複数のリポジトリの呼び出し、複雑なビジネスルールの適用など、アプリケーションの「中核」となる処理を担います。\n\nGoでの実装: サービスの構造体とそのメソッドとして実装されます。インターフェースを使って、依存するリポジトリなどを抽象化するのが一般的です。\n\nMVCとの比較: MVCの「モデル」の一部（ビジネスロジック）に相当します。\n\nリポジトリ/データストア (データ永続化層)\n\n役割: データの永続化（データベースへの保存）を抽象化します。\n\n機能: データベースへの接続、SQLクエリの実行、データの読み書きなど、具体的なデータ操作をカプセル化します。\n\nGoでの実装: データベース操作を定義するインターフェースと、それを実装する構造体として実装されます。\n\nMVCとの比較: MVCの「モデル」の別の部分（データアクセス）に相当します。\n\nこの構成では、各レイヤーが独立しているため、例えばデータベースを変更する際も、リポジトリレイヤーの実装を差し替えるだけで、サービスやハンドラレイヤーに影響を与えないように設計できます。これにより、保守性とテスト容易性が大幅に向上します。","src/content/docs/Goガイド/02_基本/レイヤー構成.mdx","4f3a2dcdcaa1bd6f","goガイド/02_基本/型定義/依存注入",{"id":1751,"data":1753,"body":1758,"filePath":1759,"digest":1760,"deferredRender":16},{"title":1754,"editUrl":16,"head":1755,"template":18,"sidebar":1756,"pagefind":16,"draft":20},"Goの依存注入",[],{"hidden":20,"attrs":1757},{},"依存性注入 (Dependency Injection: DI) 💉\n依存性注入は、あるオブジェクトが依存している別のオブジェクト（依存オブジェクト）を外部から提供するデザインパターンです。これにより、各レイヤー間の結合度を下げ、テストや保守を容易にします。\n\nGoでは、DIライブラリを使う方法もありますが、関数の引数や構造体のフィールドとして依存オブジェクトを渡すことで、シンプルにDIを実現できます。この手法は、Goの哲学である「シンプルさ」と「明示性」に非常に合っています。\n\n依存性注入のコード例\nここでは、サービスがリポジトリに依存する構成を例に見てみましょう。\n\n1. リポジトリのインターフェースを定義\n\nGo\n\npackage repository\n\n// UserRepositoryはユーザーデータへのアクセスを抽象化する\ntype UserRepository interface {\n    GetUserByID(id int) (*User, error)\n}\n2. サービスがインターフェースに依存\n\nGo\n\npackage service\n\nimport \"your_project/repository\"\n\n// UserServiceはUserRepositoryインターフェースに依存\ntype UserService struct {\n    repo repository.UserRepository\n}\n\n// NewUserServiceはDIを使って依存オブジェクトを注入するコンストラクタ\nfunc NewUserService(repo repository.UserRepository) *UserService {\n    return &UserService{repo: repo}\n}\n3. main関数で具象化された依存オブジェクトを注入\n\nGo\n\npackage main\n\nimport (\n    \"your_project/repository\"\n    \"your_project/service\"\n)\n\nfunc main() {\n    // 具象的なDBリポジトリを作成\n    dbRepo := &repository.DBRepository{}\n    \n    // NewUserService()にDBリポジトリを注入\n    userService := service.NewUserService(dbRepo)\n\n    // ... アプリケーションの実行 ...\n}\nこの方法により、UserServiceは具体的なDBRepositoryの存在を知る必要がなくなり、代わりにUserRepositoryというインターフェースにのみ依存します。これにより、テスト時にはDBRepositoryの代わりに**モック（mock）**を注入して、データベースに接続せずにサービスレイヤーのロジックをテストできるようになります。\n\nご提示いただいたレイヤードアーキテクチャの解説に、この依存性注入の概念を加えることで、そのアーキテクチャがなぜ優れているのか、そしてどのように実装すべきかがより明確になります。","src/content/docs/Goガイド/02_基本/型定義/依存注入.mdx","888192c422ca76fc","goガイド/04_上級最適化/パフォーマンス改善",{"id":1761,"data":1763,"body":1768,"filePath":1769,"digest":1770,"deferredRender":16},{"title":1764,"editUrl":16,"head":1765,"template":18,"sidebar":1766,"pagefind":16,"draft":20},"Goのパフォーマンス改善",[],{"hidden":20,"attrs":1767},{},"## Goのパフォーマンス改善 🚀\n\nGoは、高速で効率的な言語として知られていますが、パフォーマンスのボトルネックを特定し、最適化するにはいくつかの手法とツールを理解する必要があります。\n\n### 1. プロファイリングツールの利用 📊\n\nパフォーマンス改善の最も重要な第一歩は、ボトルネックを推測するのではなく、測定することです。Goには、標準で`pprof`という強力なプロファイリングツールが備わっています。\n\n- **CPUプロファイリング**: `go test`コマンドで`-cpuprofile`フラグを使用すると、テスト実行中のCPU使用状況を記録できます。\n\n```bash\ngo test -cpuprofile=cpu.prof\ngo tool pprof cpu.prof\n```\n\n- **メモリプロファイリング**: `-memprofile`フラグでメモリ割り当て状況を記録し、GCの負担を分析します。\n\n```bash\ngo test -memprofile=mem.prof\ngo tool pprof mem.prof\n```\n\n### 2. ガベージコレクション（GC）の最適化 ♻️\n\nGoのGCは自動でメモリを管理しますが、頻繁なオブジェクトの生成と破棄はGCの負担を増やし、パフォーマンスを低下させます。GCの頻度を減らすことで、プログラムの実行が一時的に停止する「Stop The World」の影響を最小限に抑えられます。\n\n- **スライスやマップの事前確保**: `make`関数で初期容量を指定し、実行時の再割り当てを減らします。\n\n```go\n// 事前確保なし（非効率）\nvar numbers []int\nfor i := 0; i \u003C 1000; i++ {\n    numbers = append(numbers, i)\n}\n\n// 事前確保あり（効率的）\nnumbers := make([]int, 0, 1000)\nfor i := 0; i \u003C 1000; i++ {\n    numbers = append(numbers, i)\n}\n```\n\n- **sync.Pool**: 頻繁に再利用されるオブジェクトをプールし、GCに回収されるのを防ぎます。\n\n```go\nimport \"sync\"\n\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 1024)\n    },\n}\n\nfunc process() {\n    buf := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buf)\n    // bufを使って処理を行う\n}\n```\n\n### 3. 効率的なデータ構造とアルゴリズム\n\n- **文字列操作**: Goで文字列を`+`演算子で頻繁に連結すると、新しいメモリが繰り返し割り当てられます。`strings.Builder`を使うことで、このコストを大幅に削減できます。\n\n```go\nimport \"strings\"\n\nfunc buildString() string {\n    var sb strings.Builder\n    sb.Grow(100) // 事前に容量を確保\n    for i := 0; i \u003C 10; i++ {\n        sb.WriteString(\"hello\")\n    }\n    return sb.String()\n}\n```\n\n- **システムコール**: ファイルI/Oやネットワーク通信といったシステムコールはコストが高いため、できるだけまとめて実行します。\n\n### 4. 並行処理の活用\n\nGoのゴルーチンを適切に利用することで、複数のタスクを並列に実行し、マルチコアCPUの性能を最大限に引き出せます。\n\n- **sync.WaitGroup**: 複数のゴルーチンの完了を待機するために使います。これにより、すべての処理が終わったことを確実に確認できます。\n\n```go\nimport \"sync\"\n\nfunc main() {\n    var wg sync.WaitGroup\n    tasks := []string{\"task1\", \"task2\", \"task3\"}\n\n    for _, task := range tasks {\n        wg.Add(1)\n        go func(t string) {\n            defer wg.Done()\n            // 並行して実行したい処理\n        }(task)\n    }\n    wg.Wait()\n}\n```\n\n- **バッファ付きチャネル**: ゴルーチン間のデータ送受信で、送信側が受信側を待つことを防ぎ、非同期的な処理を可能にします。\n\n```go\nmessages := make(chan string, 10) // バッファサイズ10\nmessages \u003C- \"message\"            // ブロックせずに送信\n```\n\n### 5. ベンチマークテスト\n\n変更がパフォーマンスにどのような影響を与えたかを数値で確認することは不可欠です。Goの標準テストパッケージは、ベンチマークテストの機能を提供しています。\n\n```go\n// my_app_test.go\npackage my_app\n\nimport \"testing\"\n\nfunc BenchmarkMyFunction(b *testing.B) {\n    for i := 0; i \u003C b.N; i++ {\n        // ベンチマークしたい関数を呼び出す\n    }\n}\n```\n\nこれらの手法を組み合わせることで、Goアプリケーションのパフォーマンスを効率的に改善できます。\n\n### 6. エスケープ解析 (Escape Analysis) の理解\n\nエスケープ解析は、コンパイラが変数をスタックに置くかヒープに置くかを判断するプロセスです。スタックへの割り当ては高速ですが、関数から戻り値としてポインタを返す場合など、スコープ外で参照される可能性があるとコンパイラはヒープに割り当てます。\n\n- **コンパイル時の確認**: `go build -gcflags=\"-m\"`フラグを使って、変数がエスケープしているか確認できます。\n\n```go\n// main.go\npackage main\n\nimport \"fmt\"\n\ntype MyStruct struct {\n    Name string\n}\n\n// この関数はヒープに割り当てられるMyStructのポインタを返す\nfunc newMyStruct() *MyStruct {\n    s := &MyStruct{Name: \"Go\"} // sはヒープにエスケープする\n    return s\n}\n\nfunc main() {\n    _ = newMyStruct()\n    fmt.Println(\"Hello\")\n}\n```\n\n- **コンパイルコマンドと出力例**:\n\n```bash\n$ go build -gcflags=\"-m\" main.go\n# command-line-arguments\n./main.go:10:6: newMyStruct: s escapes to heap\n```\n\n### 7. CPUキャッシュの効率的な利用\n\nCPUキャッシュを最大限に活用するには、メモリのデータの局所性（Data Locality）を意識してコードを書きます。連続したメモリにデータを置くスライスは、ランダムアクセスよりもシーケンシャルアクセスが高速です。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"sort\"\n    \"testing\"\n)\n\n// スライスをランダムアクセスする場合のベンチマーク\nfunc BenchmarkRandomAccess(b *testing.B) {\n    s := make([]int, 1000)\n    for i := range s {\n        s[i] = rand.Intn(1000)\n    }\n    indices := make([]int, b.N)\n    for i := range indices {\n        indices[i] = rand.Intn(1000)\n    }\n    b.ResetTimer()\n    for i := 0; i \u003C b.N; i++ {\n        _ = s[indices[i]]\n    }\n}\n\n// スライスをシーケンシャルアクセスする場合のベンチマーク\nfunc BenchmarkSequentialAccess(b *testing.B) {\n    s := make([]int, 1000)\n    for i := range s {\n        s[i] = rand.Intn(1000)\n    }\n    sort.Ints(s) // シーケンシャルアクセスを効率的にするためにソート\n    b.ResetTimer()\n    for i := 0; i \u003C b.N; i++ {\n        _ = s[i%1000] // 連続したアクセス\n    }\n}\n```\n\nこれらのベンチマークを実行すると、通常はシーケンシャルアクセスのほうがはるかに高速であることが分かります。\n\n### 8. コンカレンシーのボトルネック特定\n\n`pprof`には、並行処理の問題を特定するためのプロファイル機能があります。\n\n#### pprofの利用:\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    _ \"net/http/pprof\" // プロファイリング用エンドポイントを登録\n    \"time\"\n)\n\nfunc blockHandler(w http.ResponseWriter, r *http.Request) {\n    time.Sleep(100 * time.Millisecond) // 意図的にブロック\n    w.Write([]byte(\"ok\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/block\", blockHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\nサーバーを実行し、`http://localhost:8080/debug/pprof/`にアクセスすると各種プロファイルを確認できます。特に`http://localhost:8080/debug/pprof/block`は、ゴルーチンのブロック状況を分析する際に有用です。\n\n### 9. I/O処理の最適化\n\n- **コネクションプーリング**: `database/sql`パッケージでは、DBオブジェクトが自動でコネクションプールを管理します。`DB.SetMaxOpenConns`と`DB.SetMaxIdleConns`を使ってコネクション数を調整します。\n\n```go\npackage main\n\nimport (\n    \"database/sql\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"time\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n    if err != nil {\n        panic(err)\n    }\n    defer db.Close()\n\n    // コネクションプールの設定\n    db.SetMaxOpenConns(20)              // 同時に開く最大コネクション数\n    db.SetMaxIdleConns(10)              // アイドル状態を保つ最大コネクション数\n    db.SetConnMaxLifetime(time.Hour)    // コネクションの最大生存時間\n}\n```\n\n- **バッチ処理**: データベースへのバルクインサートは、個別の`INSERT`文を多数実行するよりもはるかに効率的です。\n\n```go\n// 例: 複数のレコードを一度に挿入\nfunc bulkInsert(db *sql.DB, data []MyData) error {\n    // SQL文を構築して、一度のトランザクションでまとめて実行\n    // ...\n    return nil\n}\n```\n\n### 10. HTTPサーバーのパフォーマンス最適化 🌐\n\nGoは`net/http`パッケージで強力なWebサーバーを構築できますが、本番環境でのパフォーマンスを最大限に引き出すためには、いくつかのベストプラクティスがあります。\n\n- **HTTP/2の活用**: Goの`net/http`サーバーは、デフォルトでHTTP/2をサポートしています。HTTP/2は、単一のTCP接続で複数のリクエストを並行して送受信できるため、特に多くのリソース（画像、CSS、JavaScriptなど）を扱う場合に、HTTP/1.1よりも高速です。特別な設定は不要ですが、TLS（HTTPS）が必須となります。\n\n- **リクエストのタイムアウト設定**: 予期せぬネットワーク遅延やDoS攻撃などにより、サーバーのリソースが枯渇するのを防ぐために、リクエストのタイムアウトを適切に設定することが重要です。\n\n```go\npackage main\n\nimport (\n    \"net/http\"\n    \"time\"\n)\n\nfunc main() {\n    server := &http.Server{\n        Addr:         \":8080\",\n        ReadTimeout:  5 * time.Second,\n        WriteTimeout: 10 * time.Second,\n    }\n    server.ListenAndServe()\n}\n```\n\n- **ミドルウェアの最適化**: ミドルウェアは便利ですが、チェーンが長くなるとパフォーマンスに影響を与える可能性があります。\n  - 不要なミドルウェアを避ける: ログ記録や認証など、本当に必要なミドルウェアのみを使用します。\n  - ミドルウェアの処理を軽量化: ミドルウェア内での重い処理（例：データベースアクセス）は避け、可能な限りハンドラー関数内で実行するようにします。\n\n- **バッファリングとGzip圧縮**:\n  - **Gzip圧縮**: Goの`compress/gzip`パッケージを使い、レスポンスを圧縮することで、転送データ量を削減し、クライアント側の読み込み速度を向上させます。\n  - **バッファリング**: `bufio`パッケージを使ってI/Oをバッファリングすることで、システムコールの回数を減らし、パフォーマンスを向上させます。\n\nこれらのテクニックは、Goアプリケーションのパフォーマンスをさらに向上させるための実践的なステップとなります。","src/content/docs/Goガイド/04_上級・最適化/パフォーマンス改善.mdx","03af560fac51e59e","goガイド/03_中級/スタイルガイド",{"id":1771,"data":1773,"body":1778,"filePath":1779,"digest":1780,"deferredRender":16},{"title":1774,"editUrl":16,"head":1775,"template":18,"sidebar":1776,"pagefind":16,"draft":20},"Goのスタイルガイド",[],{"hidden":20,"attrs":1777},{},"## Goの書き方: スタイルガイドとベストプラクティス 📝\n\nGoは、コーディングスタイルや命名規則に関して、明確な慣習（コンベンション）を持っています。これらのルールに従うことで、コードの可読性が高まり、チームでの共同開発がスムーズになります。\n\n### 1. シンプルさと明示性\n\nGoの哲学は「シンプルisベスト」です。コードはできるだけ簡潔に、そして意図が明確に伝わるように書くことが推奨されます。\n\n- **冗長なコメントを避ける**: コード自体が意図を説明するように記述します。\n\n```go\n// 悪い例: 冗長なコメント\n// sum is the sum of a and b.\nfunc sum(a, b int) int {\n    return a + b\n}\n\n// 良い例: コードが意図を説明\nfunc Add(a, b int) int {\n    return a + b\n}\n```\n\n- **不必要な抽象化を避ける**: インターフェースやデザインパターンは、本当に必要な場合にのみ使用します。\n\n### 2. 命名規則 🏷️\n\nGoの命名規則は非常にシンプルで一貫しています。\n\n- **パッケージ名**: 小文字で、単一の単語にします（例: `fmt`, `http`）。\n- **変数名**: 短く、意味が明確になるようにします。\n\n```go\n// 良い例: 慣習的な短い変数名\nfor i, v := range items {\n    // ...\n}\n```\n\n- **関数名・メソッド名**:\n  - 公開（Public）: 頭文字を大文字にします（例: `CreateUser`）。\n  - 非公開（Private）: 頭文字を小文字にします（例: `createUser`）。\n- **構造体名**: `User`や`Product`のように、名詞を使います。\n\n### 3. エラーハンドリング 🐞\n\nGoでは、関数はエラーを戻り値として明示的に返します。このエラーを無視することは、予期せぬバグの原因となるため、避けるべきです。\n\n- **エラーの確認**: 常にエラーをチェックし、適切に処理します。\n\n```go\nresult, err := someFunction()\nif err != nil {\n    log.Printf(\"error calling someFunction: %v\", err)\n    return err\n}\n```\n\n- **エラーのラップ**: エラーにコンテキスト情報を付加して返すことで、デバッグを容易にします。\n\n```go\nimport \"fmt\"\n\nfunc readFile(path string) error {\n    // ... ファイル読み込み処理\n    err := someFileIOError\n    return fmt.Errorf(\"could not read file %s: %w\", path, err)\n}\n```\n\n### 4. フォーマット 💅\n\nGoのコードは、公式ツール`gofmt`によって自動的にフォーマットされます。\n\n- **gofmt**: ソースコードを標準的なスタイルに整形します。\n\n```bash\ngofmt -w your_file.go\n```\n\n- **goimports**: `gofmt`の機能に加え、不要なimportを削除したり、必要なimportを追加したりします。\n\n```bash\ngoimports -w your_file.go\n```\n\nこれらのツールは、多くのエディタやIDEに統合されており、ファイルを保存するたびに自動で実行できます。\n\n### 5. インターフェースの活用 🤝\n\nGoでは、大規模なアプリケーションを構築する上で、インターフェースが極めて重要な役割を果たします。インターフェースは、コードを疎結合にし、テストを容易にするための鍵となります。\n\n- **小さく、シンプルに**: Goのインターフェースは小さく、単一の責務を持つべきです。たった一つのメソッドを持つインターフェースも一般的です（例: `io.Reader`, `io.Writer`）。\n- **インターフェースを実装するのではなく、受け入れる**: 関数は具体的な型ではなく、インターフェースを引数として受け入れるべきです。これにより、引数に様々な型（モックを含む）を渡せるようになり、柔軟性が向上します。\n\n```go\nimport \"io\"\nimport \"os\"\n\n// 良い例: インターフェースに依存\nfunc ProcessData(r io.Reader) error {\n    data, err := io.ReadAll(r)\n    // ...\n    return err\n}\n\nfunc main() {\n    file, _ := os.Open(\"file.txt\")\n    ProcessData(file) // io.Readerインターフェースを満たすのでOK\n}\n```\n\n### 6. ゼロ値とコンストラクタ 🧱\n\nGoの型は、明示的に初期化しなくてもゼロ値を持ちます（例: `int`は`0`、`string`は`\"\"`）。この性質は便利ですが、予期せぬ挙動につながることがあります。\n\n- **ゼロ値を活用する**: 多くの場合はゼロ値で十分です。不必要なコンストラクタ関数を作成する必要はありません。\n- **コンストラクタの使用**: ただし、特定のフィールドがゼロ値であってはならない場合や、追加のセットアップが必要な場合は、`New`プレフィックスを付けたコンストラクタ関数を定義します。\n\n```go\ntype User struct {\n    ID   int\n    Name string\n}\n\n// コンストラクタ関数\nfunc NewUser(name string) (*User, error) {\n    if name == \"\" {\n        return nil, fmt.Errorf(\"name cannot be empty\")\n    }\n    return &User{\n        Name: name,\n    }, nil\n}\n```\n\n### 7. 並行処理のベストプラクティス 🏎️\n\nGoのゴルーチンとチャネルを安全に使うための注意点です。\n\n- **競合状態（Race Conditions）の回避**: 複数のゴルーチンが共有するデータにアクセスする場合、`sync.Mutex`などのロックを使って、同時アクセスを防ぎます。\n\n```go\nimport \"sync\"\n\nvar mu sync.Mutex\nvar counter int\n\nfunc increment() {\n    mu.Lock()\n    defer mu.Unlock()\n    counter++\n}\n```\n\n- **sync.WaitGroupの使用**: 複数のゴルーチンの完了を待機する場合、チャネルよりも`sync.WaitGroup`が適しています。\n\n```go\nimport \"sync\"\n\nfunc main() {\n    var wg sync.WaitGroup\n    for i := 0; i \u003C 5; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            // ... 処理\n        }(i)\n    }\n    wg.Wait()\n}\n```\n\n### 8. ドキュメンテーションとコメント 📝\n\nGoのコメントは、単なるコードの説明だけでなく、公式ドキュメント（`go doc`や`pkg.go.dev`）としても機能します。\n\n- **公開されたシンボル**: 公開された関数、変数、構造体、インターフェースには、その目的を説明するコメントを記述します。\n\n```go\n// User represents a user in the system.\ntype User struct {\n    ID   int\n    Name string\n}\n\n// NewUser creates a new User with the given name.\nfunc NewUser(name string) *User {\n    // ...\n}\n```\n\n- **パッケージコメント**: パッケージの目的や概要を説明するコメントを、`package`宣言の上に記述します。\n\n```go\n// Package greeting provides functions for generating greetings.\npackage greeting\n\n// Greet returns a greeting message for the given name.\nfunc Greet(name string) string {\n    return fmt.Sprintf(\"Hello, %s!\", name)\n}\n```\n\nこれらの実践的なガイドラインに従うことで、Goのコードはより堅牢で、保守しやすく、他の開発者にとって理解しやすいものになります。","src/content/docs/Goガイド/03_中級/スタイルガイド.mdx","10033e2798d834d8"]