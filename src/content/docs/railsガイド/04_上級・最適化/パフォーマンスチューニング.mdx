---
title: "パフォーマンスチューニング"
label: "パフォーマンスチューニング"
---

## キャッシュの利用

Railsには、パフォーマンスを向上させるための複数のキャッシュ機能が用意されています。

- **ページキャッシュ**: コントローラーのアクション全体をHTMLファイルとしてキャッシュします。これは、動的な要素が少ない静的なページで特に有効です。

- **フラグメントキャッシュ**: ビューの特定の部分（フラグメント）をキャッシュします。これにより、ページの大部分がキャッシュされ、動的な部分だけがレンダリングされるため、動的なコンテンツを含むページで有効です。

```ruby
# フラグメントキャッシュの例
<% cache 'products_list' do %>
  <ul>
    <% @products.each do |product| %>
      <li><%= product.name %></li>
    <% end %>
  </ul>
<% end %>
```

- **オブジェクトキャッシュ**: ビューやコントローラーで頻繁にアクセスされるオブジェクトをキャッシュします。

## データベースの最適化

データベースは、アプリケーションのパフォーマンスボトルネックになりがちな部分です。

- **インデックス**: 検索や結合のパフォーマンスを向上させるために、頻繁にクエリされるカラムにインデックスを設定します。`db/migrate`ファイルで`add_index`を使ってインデックスを追加します。

- **N+1問題の解決**: `includes`、`preload`、`eager_load`などを使用して、関連するデータをまとめて事前に読み込みます。これにより、データベースへのクエリ回数を削減し、パフォーマンスを大幅に向上させることができます。

```ruby
# N+1問題の例
# Bad: ループ内でクエリが発生
User.all.each do |user|
  puts user.posts.count
end

# Good: `includes`で関連データをまとめて読み込み
User.includes(:posts).each do |user|
  puts user.posts.count
end
```

## 非同期処理の導入

時間のかかる処理（例: メール送信、画像処理、外部APIへのリクエスト）は、ユーザーリクエストとは別にバックグラウンドで実行することで、レスポンスタイムを改善できます。

- **Active Job**: Railsの組み込み機能で、様々なジョブキュー（Sidekiq、Resqueなど）と連携できます。

## ロギングとモニタリング

パフォーマンス問題の特定には、アプリケーションの挙動を詳細に把握することが不可欠です。

- **ログの分析**: Railsのログ（`log/development.log`や`log/production.log`）には、各リクエストにかかった時間やデータベースクエリの詳細が記録されています。これを分析することで、パフォーマンスのボトルネックを特定できます。

- **外部ツール**: New RelicやScout APMなどのアプリケーションパフォーマンスモニタリング（APM）ツールを利用すると、ボトルネックの特定やパフォーマンスの可視化が容易になります。

## その他の最適化

- **アセットパイプライン**: JavaScriptやCSSを圧縮・結合することで、リクエスト数を減らし、ページの読み込み速度を向上させます。

- **HTTP/2の利用**: 複数のリソースを同時にダウンロードできるため、アセットの読み込み速度が向上します。

- **キャッシュ戦略の最適化**: キャッシュは効果的ですが、適切に設定しないと古くなった情報を提供してしまうことがあります。キャッシュキーを動的に設定することで、データの更新時にキャッシュが自動的に無効化されるようにします。

- **依存関係に基づくキャッシュキー**: `cache`ヘルパーにモデルオブジェクトを渡すと、Railsは自動的にモデル名/id-updated_atのような形式のキャッシュキーを生成します。データが更新されると`updated_at`タイムスタンプが変わるため、キャッシュが自動的に無効化されます。

```ruby
<% @products.each do |product| %>
  <% cache product do %>
    <li><%= product.name %></li>
  <% end %>
<% end %>
```

## データベースコネクションプールの調整

アプリケーションがデータベースに接続する際のコネクション数もパフォーマンスに影響します。特に、多数の同時リクエストを処理する場合、コネクションプールを適切に設定することが重要です。

`database.yml`ファイルで、`pool`の値をアプリケーションのニーズに合わせて調整します。デフォルトは5ですが、リクエスト数に応じて増やすことを検討してください。ただし、あまりに大きな値を設定すると、データベースサーバーに負荷がかかるため注意が必要です。

```yaml
# config/database.yml
default: &default
  adapter: postgresql
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
```

## メモリの最適化

アプリケーションのメモリ使用量を削減することも、パフォーマンス向上に繋がります。

- **オブジェクト生成の抑制**: 不要なオブジェクトの生成を避けます。例えば、`select`メソッドで必要なカラムのみを読み込むことで、メモリ使用量を削減できます。

```ruby
# すべてのカラムを読み込む
@users = User.all

# 必要なカラムのみを読み込む
@users = User.select(:id, :name)
```

- **ガーベージコレクションのチューニング**: Rubyのガーベージコレクション（GC）は、デフォルトで最適な設定になっていますが、特定の条件下では手動で調整することも可能です。ただし、これは高度なテクニックであり、安易な変更はかえってパフォーマンスを悪化させる可能性があるため、慎重に行う必要があります。

## フロントエンドの最適化

Railsアプリケーションはバックエンドのパフォーマンスだけでなく、フロントエンドのパフォーマンスも重要です。

- **画像の最適化**: 画像を圧縮したり、WebPなどの最新の画像フォーマットを使用したりすることで、ページの読み込み速度を大幅に改善できます。

- **非同期読み込み**: JavaScriptやCSSファイルを`async`や`defer`属性を使って非同期で読み込むことで、ページのレンダリングをブロックしないようにします。