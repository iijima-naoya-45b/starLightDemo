---
title: "N+1問題"
label: "N+1問題"
---

## N+1問題とは
N+1問題とは、データベースからデータを取得する際に発生するパフォーマンスの問題です。特に、関連するデータを繰り返し取得するループ処理でよく見られます。この問題は、1つの親レコードを取得するクエリ（1クエリ）と、その親レコードに紐づくN個の子レコードをそれぞれ取得するクエリ（Nクエリ）が合計でN+1回のクエリを発行してしまうことから、その名がつけられました。

### N+1問題の発生例
RailsのActive RecordでN+1問題が発生する典型的な例を見てみましょう。

UserモデルとPostモデルがあり、Userが複数のPostを持っているとします。

```ruby
class User < ApplicationRecord
  has_many :posts
end

class Post < ApplicationRecord
  belongs_to :user
end
```

ユーザーの一覧ページで、各ユーザーの最新の投稿タイトルを表示したい場合、以下のようなコードを書くかもしれません。

```erb
<% @users.each do |user| %>
  <p>ユーザー名: <%= user.name %></p>
  <p>最新の投稿: <%= user.posts.last.title %></p>
<% end %>
```

このコードでは、以下のクエリが実行されます。

- 1クエリ: `@users`を取得するために1つのクエリが発行されます。
  ```sql
  SELECT * FROM users;
  ```

- Nクエリ: ループ内で`user.posts.last`が呼び出されるたびに、そのユーザーに紐づく投稿を取得するクエリが発行されます。ユーザーがN人いれば、N個のクエリが発行されます。
  ```sql
  SELECT * FROM posts WHERE user_id = 1;
  SELECT * FROM posts WHERE user_id = 2;
  ...
  ```

結果として、合計N+1回のクエリが発行され、データベースへの負荷が増加し、アプリケーションのパフォーマンスが低下します。

## 解決策
N+1問題を解決する最も一般的な方法は、**関連データを事前に読み込む（Eager Loading）**ことです。これにより、必要なデータを少ないクエリ数でまとめて取得できます。

### includesメソッドの使用
`includes`メソッドは、関連データを事前にロードするための最も一般的な方法です。

```ruby
# before
@users = User.all

# after
@users = User.includes(:posts)
```

この変更により、以下の2つのクエリのみが実行されます。

```sql
SELECT * FROM users;
SELECT * FROM posts WHERE user_id IN (1, 2, 3, ...);
```

`includes`は、ユーザーに紐づくすべての投稿を一度に取得するため、ループ内の`user.posts`が呼ばれても新たなクエリは発行されません。これにより、クエリ数が劇的に減少し、パフォーマンスが大幅に向上します。

## 開発時の注意点
- **Bullet Gem**: 開発中に N+1 問題を自動的に検知し、警告を出してくれるBullet Gemは非常に便利です。
- **ログの確認**: 開発中は、`log/development.log`を確認し、不必要なクエリが発行されていないかを常にチェックする習慣をつけましょう。

これらの対策を講じることで、データベースへの負荷を最小限に抑え、Railsアプリケーションのパフォーマンスを最適化できます。

## N+1問題の解決によるパフォーマンスの向上
N+1問題が解決されると、データベースへのクエリ数がN+1から2に減少します。これにより、以下のメリットが得られます。

- **データベース負荷の軽減**: サーバーはデータベースと何度も通信する必要がなくなるため、データベースサーバーへの負荷が大幅に軽減されます。
- **応答速度の向上**: クエリの数が減ることで、ページの読み込み時間が短縮されます。特に、Nの値（取得する関連データの数）が大きいほど、パフォーマンス改善の効果は顕著になります。

### 例：ユーザーが100人いる場合
ユーザーが100人いるページで、各ユーザーの最新の投稿を取得するケースを考えます。

- **N+1問題が発生している場合**:
  - ユーザー取得クエリ: 1回
  - 投稿取得クエリ: 100回
  - 合計クエリ数: 101回

- **includesを使って解決した場合**:
  - ユーザー取得クエリ: 1回
  - 投稿取得クエリ: 1回（すべての投稿をまとめて取得）
  - 合計クエリ数: 2回

この場合、データベースへのアクセス回数は約50分の1に減少し、ページの表示速度は数倍から数十倍に向上する可能性があります。

クエリ数が101回から2回になるというだけでも、パフォーマンス改善の効果がいかに大きいかが分かります。アプリケーションの規模が大きくなればなるほど、この差はさらに広がり、ユーザーエクスペリエンスに大きな影響を与えます。