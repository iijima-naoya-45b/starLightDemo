---
title: "Rails ORM"
label: "Rails ORM"
---

Rails ORM
RailsにおけるORM（Object-Relational Mapping）は、Active Recordというライブラリを指します。Active Recordは、データベースのテーブルをRubyのクラスとして扱い、SQLを直接書かずにデータベース操作を可能にするフレームワークです。これにより、開発者はオブジェクト指向的なアプローチでデータと向き合うことができ、コードの可読性と保守性が向上します。

#### ⚠️ Active RecordはSQLを隠蔽するが、消し去るわけではない

「SQLを書かずに操作できる」のは最大の利点ですが、発行されるSQLを意識しないことが「N+1問題」の最大の原因です。

**重要な理解**:
`user.posts`をループの中で呼ぶことは、実務では「禁止事項」に近い扱いです。

**問題点**:
100人のユーザーの投稿を表示する際、101回のSQLを発行するのではなく、`User.includes(:posts).all`を使って2回（ユーザー取得 + 投稿の一括取得）のSQLで済ませる感覚を常に持ちましょう。

```ruby
# ❌ 危険: N+1問題が発生
users = User.all  # SQL: SELECT * FROM users (1回)
users.each do |user|
  puts user.posts.count  # SQL: SELECT * FROM posts WHERE user_id = ? (100回)
end
# 合計: 101回のSQLが発行される

# ✅ 安全: Eager Loadingを使用
users = User.includes(:posts).all  # SQL: 2回のみ
# 1. SELECT * FROM users
# 2. SELECT * FROM posts WHERE user_id IN (1, 2, 3, ..., 100)
users.each do |user|
  puts user.posts.count  # 追加のSQLは発行されない
end
# 合計: 2回のSQLのみ
```

**推奨されるアプローチ**:
- 関連データを取得する際は、常に`includes`、`preload`、`eager_load`を検討する
- 開発中はBullet Gemを使用してN+1問題を自動検知する
- ログで発行されるSQLを常に確認する習慣をつける

Active Recordの主な機能
1. データベースとの連携
Active Recordは、モデルクラスとデータベーステーブルを自動でマッピングします。例えば、usersという名前のテーブルがあれば、Userというモデルクラスを定義するだけで、テーブルの各カラムがモデルの属性（attribute）として利用可能になります。

例：データの取得
Userクラスを使って、データベースからデータを取得できます。

Ruby

# 全ユーザーを取得
users = User.all

#### ⚠️ メモリ消費の物理的制約

Reactの解説で「大量のDOMノード」を懸念したのと同様に、ORMでもメモリは重要です。

**重要な理解**:
`User.all`は、全件をRubyのメモリ上に展開します。

**問題点**:
100万件のデータがあるテーブルで`User.all.each`を実行した瞬間に、サーバーのメモリが枯渇しプロセスがクラッシュします。

```ruby
# ❌ 危険: 全データを一度にメモリに読み込む
User.all.each do |user|
  puts user.name
end
# 100万件のユーザーがすべてメモリに載る → メモリ不足でクラッシュ

# ✅ 安全: バッチ処理で小分けに読み込む
User.find_each do |user|  # デフォルトで1000件ずつ処理
  puts user.name
end
# 1000件ずつ処理されるため、メモリ使用量が一定に保たれる

# バッチサイズを指定することも可能
User.find_each(batch_size: 500) do |user|
  puts user.name
end
```

**改善案**:
大量データを処理する場合は、`find_each`メソッドを使いましょう。これは自動的に1,000件ずつ分割して取得してくれる、メモリに優しい「バッチ処理」用メソッドです。

**find_eachの動作**:
1. `SELECT * FROM users LIMIT 1000 OFFSET 0`で最初の1000件を取得
2. 1000件を処理
3. `SELECT * FROM users LIMIT 1000 OFFSET 1000`で次の1000件を取得
4. これを繰り返す

これにより、データ量が増えてもメモリ使用量が一定に保たれ、サーバーがクラッシュすることを防げます。

# IDが1のユーザーを取得
user = User.find(1)

# メールアドレスでユーザーを検索
user = User.find_by(email: "test@example.com")
2. データの作成・更新・削除
Active Recordは、データのCRUD（Create, Read, Update, Delete）操作をメソッドとして提供します。

例：データの作成
Ruby

# 新しいユーザーインスタンスを作成し、データベースに保存
user = User.create(name: "Alice", email: "alice@example.com")
例：データの更新
Ruby

# 既存ユーザーの情報を更新
user.update(email: "new_email@example.com")

#### ⚠️ updateとupdate_columnsの使い分け

「データの更新」メソッドには種類があります。

**重要な理解**:
`update`はバリデーションとコールバックを実行しますが、`update_columns`はそれらを全てスキップして直接SQLを発行します。

**問題点**:
「バリデーションを通さずに、特定のフラグだけを高速に書き換えたい」というシーンで使い分けが必要ですが、安易にスキップするとデータの整合性が壊れます。

```ruby
# update: バリデーションとコールバックを実行
user.update(email: "new_email@example.com")
# 1. バリデーションを実行
# 2. before_saveコールバックを実行
# 3. SQLを発行
# 4. after_saveコールバックを実行
# 5. updated_atが自動更新される

# update_columns: バリデーションとコールバックをスキップ
user.update_columns(email: "new_email@example.com", last_login_at: Time.current)
# 1. バリデーションをスキップ
# 2. コールバックをスキップ
# 3. 直接SQLを発行（高速）
# 4. updated_atは自動更新されない（手動で指定が必要）

# update_column: 単一カラムのみ更新（スキップ系）
user.update_column(:last_login_at, Time.current)
# 1. バリデーションをスキップ
# 2. コールバックをスキップ
# 3. updated_atも更新されない
```

**改善案**:
基本は`update`を使い、パフォーマンスが極限まで求められる時や、システム管理用のフラグ更新時のみスキップ系メソッドを検討する、という優先順位を記述しましょう。

**使い分けの指針**:

| メソッド | バリデーション | コールバック | updated_at | 使用場面 |
| --- | --- | --- | --- | --- |
| `update` | ✅ 実行 | ✅ 実行 | ✅ 自動更新 | **基本はこれを使用** |
| `update_columns` | ❌ スキップ | ❌ スキップ | ❌ 更新されない | パフォーマンスが極限まで必要な時 |
| `update_column` | ❌ スキップ | ❌ スキップ | ❌ 更新されない | システム管理用フラグの更新 |

**推奨される使用例**:

```ruby
# ✅ 通常の更新: updateを使用
user.update(email: "new_email@example.com")

# ✅ パフォーマンスが重要な場合: update_columnsを使用
# 例: 大量のレコードを一括更新するバッチ処理
User.where(active: false).find_each do |user|
  user.update_columns(last_login_at: Time.current)  # 高速
end

# ✅ システム管理用フラグ: update_columnを使用
# 例: ログイン時刻の更新（バリデーション不要）
user.update_column(:last_login_at, Time.current)
```

**重要な原則**:
- **基本は`update`**: バリデーションとコールバックを実行し、データの整合性を保つ
- **スキップ系は慎重に**: パフォーマンスが極限まで必要な時や、システム管理用フラグのみ
- **データの整合性を優先**: パフォーマンスよりもデータの整合性を優先する

この使い分けにより、適切な場面で適切なメソッドを使用でき、データの整合性を保ちながらパフォーマンスも最適化できます。
例：データの削除
Ruby

# ユーザーをデータベースから削除
user.destroy

#### ⚠️ 「データの破壊」に対する安全策

`user.destroy`についての補強です。

**重要な理解**:
実務のBtoBサービスや大規模サービスでは、`destroy`（物理削除）を直接使うことは稀です。

**問題点**:
誤操作でデータを消すと復旧が困難なため、`deleted_at`カラムなどを用いた「論理削除」や、関連するデータも一緒に消す`dependent: :destroy`の設定をセットで考える必要があります。

```ruby
# ❌ 危険: 物理削除と関連データの不整合
class User < ApplicationRecord
  has_many :posts  # dependent: :destroyがない
end

user.destroy  # ユーザーは削除されるが、投稿は残る（ゴミデータ）

# ✅ 安全1: 論理削除を使用
class User < ApplicationRecord
  has_many :posts, dependent: :destroy
  
  # 論理削除（paranoia gemなどを使用）
  def soft_delete
    update(deleted_at: Time.current)
  end
  
  scope :active, -> { where(deleted_at: nil) }
end

# ✅ 安全2: dependent: :destroyを設定
class User < ApplicationRecord
  has_many :posts, dependent: :destroy
  # ユーザーが削除されると、関連する投稿も自動的に削除される
end

# ✅ 安全3: dependent: :nullify（外部キーをnullにする）
class User < ApplicationRecord
  has_many :posts, dependent: :nullify
  # ユーザーが削除されると、投稿のuser_idがnullになる
end
```

**改善案**:
関連付けの定義時に`has_many :posts, dependent: :destroy`と書かないと、親（ユーザー）が消えても子（投稿）が残る「ゴミデータ（不整合）」が発生することを警告しましょう。

**推奨されるアプローチ**:
- **論理削除**: 重要なデータは`deleted_at`カラムを使用した論理削除を検討
- **dependent: :destroy**: 親が削除されたら子も削除する場合
- **dependent: :nullify**: 親が削除されても子を残す場合（外部キーをnullに）
- **dependent: :restrict_with_error**: 子が存在する場合は削除を拒否

この安全策により、データの整合性を保ち、誤操作によるデータ損失を防げます。
3. バリデーションとコールバック
Active Recordは、データの整合性を保つための機能も提供します。

例：バリデーション
validatesメソッドを使って、データ保存前の検証ルールを定義できます。

Ruby

class User < ApplicationRecord
  validates :name, presence: true # 名前が必須であることを検証
  validates :email, uniqueness: true # メールアドレスが一意であることを検証
end
例：コールバック
データの保存や削除といった特定のイベントが発生したときに、自動で実行されるメソッドを定義できます。

Ruby

class Post < ApplicationRecord
  before_save :set_slug

  private
  def set_slug
    # タイトルからスラグを自動生成
    self.slug = self.title.parameterize
  end
end
4. 関連付け（Association）
複数のモデル間の関係性を定義することで、関連するデータを簡単に操作できます。

例：1対多の関係
has_many：Userは多数のPostを持つ。

belongs_to：Postは1つのUserに属する。

Ruby

class User < ApplicationRecord
  has_many :posts
end

class Post < ApplicationRecord
  belongs_to :user
end
この関連付けを定義することで、user.postsでそのユーザーの投稿一覧を、post.userでその投稿の作成者を取得できます。

**注意**: 関連付けをループ内で使用する際は、必ず`includes`や`preload`を使用してEager Loadingを行い、N+1問題を防ぎましょう。

Active Recordは、これらの機能を通じてデータベース操作を抽象化し、Rails開発の生産性を大幅に向上させます。

ただし、実務では以下の点に注意が必要です：
- **SQLを意識する**: Active RecordはSQLを隠蔽しますが、消し去るわけではありません。発行されるSQLを常に意識する
- **データの破壊に対する安全策**: 物理削除は慎重に、論理削除や`dependent`オプションを適切に設定する
- **メモリ消費**: 大量データを処理する際は`find_each`を使用し、メモリ使用量を一定に保つ
- **更新メソッドの使い分け**: 基本は`update`を使用し、パフォーマンスが極限まで必要な時のみスキップ系メソッドを検討する

これらの実務的な知識を理解することで、安全で効率的なデータベース操作が可能になります。