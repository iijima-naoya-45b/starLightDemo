---
title: "環境構築"
label: "環境構築"
---

## 環境構築

Railsでの開発を始めるには、まず開発環境を整える必要があります。ここでは、実務レベルの環境構築手順を段階的に解説します。

### OSレイヤーの準備: HomebrewでRubyのビルドに必要なツールを揃える

macOSでRails開発を始める際、まずはRubyのビルドに必要なツールをインストールします。Homebrewを使用して、必要な開発ツールを一括でインストールします。

```bash
# Homebrewがインストールされていない場合は、まずインストール
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Rubyのビルドに必要なツールをインストール
brew install openssl readline libyaml libffi
```

これらのツールは、Rubyのコンパイル時に必要となる依存関係です。事前にインストールしておくことで、Rubyのインストールがスムーズに進みます。

### ランタイム管理: rbenvでRubyを入れる

Rubyのバージョン管理には「rbenv」の利用をおすすめします。これにより、複数のRubyバージョンを簡単に切り替えることができ、プロジェクトごとに最適なバージョンを使えます。

#### rbenvのインストール

ターミナルを開き、以下のコマンドを実行してrbenvをインストールします。

```bash
# rbenvのインストール
brew install rbenv ruby-build

# rbenvの初期化
rbenv init
```

`rbenv init`を実行すると、ターミナル起動時にrbenvが自動的に読み込まれるよう設定が行われます。指示に従って、`.zshrc`や`.bash_profile`などのシェル設定ファイルに追記してください。

```bash
# .zshrcまたは.bash_profileに追加される内容の例
eval "$(rbenv init - zsh)"  # zshの場合
# または
eval "$(rbenv init - bash)" # bashの場合
```

設定後、新しいターミナルを開くか、以下のコマンドで設定を読み込みます。

```bash
source ~/.zshrc  # zshの場合
# または
source ~/.bash_profile  # bashの場合
```

#### Rubyのインストール

次に、rbenvを使ってRubyをインストールします。ここでは例としてバージョン3.3.0をインストールしますが、Railsガイドなどで推奨されている最新の安定版を選ぶと良いでしょう。

```bash
# 利用可能なRubyバージョンを確認
rbenv install -l

# Rubyのインストール（例: 3.3.0）
rbenv install 3.3.0

# インストールしたバージョンをシステム全体で使うように設定
rbenv global 3.3.0

# インストールの確認
ruby -v
```

プロジェクトごとに異なるRubyバージョンを使用する場合は、プロジェクトディレクトリで以下のコマンドを実行します。

```bash
# プロジェクトディレクトリで特定のバージョンを指定
rbenv local 3.3.0

# これにより、.ruby-versionファイルが作成されます
```

### 周辺環境の整備: Node.jsとPostgreSQLをインストール・起動する

Railsアプリケーションを開発する際には、Node.js（JavaScriptランタイム）とPostgreSQL（データベース）が必要です。

#### Node.jsのインストール

Rails 7以降では、JavaScriptのビルドツールとしてNode.jsが必要です。Homebrewを使ってインストールします。

```bash
# Node.jsのインストール
brew install node

# インストールの確認
node -v
npm -v
```

#### PostgreSQLのインストールと起動

PostgreSQLは、多くのRailsアプリケーションで使用されるデータベースです。

```bash
# PostgreSQLのインストール
brew install postgresql@16

# PostgreSQLの起動（Homebrewサービスとして起動）
brew services start postgresql@16

# 起動の確認
brew services list
```

PostgreSQLが起動したら、必要に応じてデータベースユーザーを作成します。

```bash
# PostgreSQLに接続
psql postgres

# データベースユーザーの作成（PostgreSQL内で実行）
CREATE USER your_username WITH PASSWORD 'your_password';
ALTER USER your_username CREATEDB;
\q
```

### プロジェクト開始: rails newをbundle exec経由で行い、バージョンをGemfile.lockで固定する

環境が整ったら、いよいよRailsプロジェクトを作成します。実務では、`bundle exec`を使用して正確なバージョンでコマンドを実行し、`Gemfile.lock`で依存関係を固定します。

#### Bundlerのインストール

まず、Bundlerをインストールします。Bundlerは、Rubyの依存関係管理ツールです。

```bash
# Bundlerのインストール
gem install bundler

# インストールの確認
bundle -v
```

#### Railsプロジェクトの作成

Railsプロジェクトを作成する際は、`bundle exec`を使用してインストールされたRailsのバージョンで実行します。

```bash
# 新規Railsプロジェクトの作成
rails new my_app --database=postgresql

# または、特定のRailsバージョンを使用する場合
rails _7.0.0_ new my_app --database=postgresql
```

プロジェクトディレクトリに移動します。

```bash
cd my_app
```

#### 依存関係のインストールと固定

プロジェクトディレクトリで、依存関係をインストールします。

```bash
# Gemfile.lockを生成し、依存関係をインストール
bundle install

# これにより、Gemfile.lockが作成され、依存関係のバージョンが固定されます
```

`Gemfile.lock`は、プロジェクトの依存関係の正確なバージョンを記録するファイルです。このファイルをGitにコミットすることで、チーム全体で同じバージョンの依存関係を使用できます。

#### データベースのセットアップ

PostgreSQLを使用する場合、データベースを作成します。

```bash
# データベースの作成
bundle exec rails db:create

# マイグレーションの実行
bundle exec rails db:migrate

# 開発用データの投入（必要に応じて）
bundle exec rails db:seed
```

#### ⚠️ database.ymlの設定（まさかり版）

`config/database.yml`は、ただDBを繋ぐ場所ではなく、**「システムの同時接続数」と「リソース管理」**を司る場所です。

**問題点**:
- **コネクションプール（pool）の不一致**: Railsのスレッド数（Pumaのスレッド数）より`pool`数が少ないと、アクセスが増えた瞬間に`ActiveRecord::ConnectionTimeoutError`でアプリが落ちます
- **パスワードの直書き**: `database.yml`にパスワードを直書きしてGitHubに上げた瞬間に、そのDBは世界中の攻撃対象になります
- **DBホストの設定**: `localhost`だけでなく、Docker環境なら`db`、AWSならエンドポイントが入るように、柔軟な設定が必要です

```yaml
# ❌ 悪い例（デフォルトのまま）
default: &default
  adapter: postgresql
  encoding: unicode
  pool: 5  # ← ここが事故の元
```

```yaml
# ✅ 良い例（実務レベル・詳細版）
default: &default
  adapter: postgresql
  encoding: unicode
  # 1. Poolサイズは「WEBスレッド数 +α」に
  # まさかり：開発環境でもコネクションプール不足で詰まることがある
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i + 2 %>
  # 2. タイムアウト設定を明示する
  timeout: 5000
  # まさかり：チェックアウトタイムアウトは短すぎても長すぎてもダメ。5秒が標準的。
  checkout_timeout: 5
  # まさかり：アイドル状態の接続をいつ切るか。リソース節約に重要。
  # 死んだコネクションを掃除する頻度（秒）。設定しないとゴーストコネクションがDBを圧迫する
  reaping_frequency: 10
  # 3. 接続情報は環境変数から（直書き厳禁）
  username: <%= ENV['DB_USER'] %>
  password: <%= ENV['DB_PASSWORD'] %>
  host: <%= ENV['DB_HOST'] || 'localhost' %>
  database: <%= ENV['DB_NAME'] %>

development:
  <<: *default
  database: myapp_development
  # まさかり：Dockerを使う場合は host: db などの設定が必要
  host: <%= ENV.fetch("DB_HOST") { "localhost" } %>

test:
  <<: *default
  database: myapp_test
  # まさかり：テストの並列実行（parallelize）を有効にするなら、pool数を増やす必要がある
  # Rails 6以降の並列テストを使う場合、テストワーカーの数だけ接続が必要になるため、余裕を持たせた設定が必須
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i * 2 %>

production:
  <<: *default
  # 本番特有の接続数制限や、コネクションプーラー（PgBouncerなど）への対応が必要な場合がある
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i + 2 %>
  timeout: 5000
  checkout_timeout: 5
  reaping_frequency: 10
  username: <%= ENV['DB_USER'] %>
  password: <%= ENV['DB_PASSWORD'] %>
  host: <%= ENV['DB_HOST'] %>
  database: <%= ENV['DB_NAME'] %>
```

**重要な設定ポイント**:
1. **Poolサイズ**: `RAILS_MAX_THREADS + 2`（余裕を持たせる）
   - 開発環境でもコネクションプール不足で詰まることがあるため、適切なサイズを設定
   - テスト環境で並列実行を使う場合は、`RAILS_MAX_THREADS * 2`に増やす
2. **タイムアウト**: 明示的に設定（デフォルトは5秒）
   - `timeout`: 接続タイムアウト（ミリ秒）
   - `checkout_timeout`: プールから接続を取得する際のタイムアウト（秒）。5秒が標準的
3. **reaping_frequency**: アイドル状態の接続を切る頻度（秒）
   - 死んだコネクションを掃除する頻度。設定しないとゴーストコネクションがDBを圧迫する
   - 10秒が標準的な設定
4. **環境変数**: パスワードや接続情報は必ず環境変数から取得
5. **ホストの柔軟性**: Docker環境（`db`）やAWS（エンドポイント）に対応
   - Dockerを使う場合は`host: db`などの設定が必要

**テスト環境での並列実行**:
Rails 6以降の並列テスト（`parallelize`）を使う場合、テストワーカーの数だけ接続が必要になるため、`pool`数を増やす必要があります。デフォルトの5では不足するため、`RAILS_MAX_THREADS * 2`などの余裕を持たせた設定が必須です。

この設定により、コネクションプールの不足によるエラーを防ぎ、リソース管理を最適化し、セキュリティも確保できます。

#### 開発サーバーの起動

環境構築が完了したら、開発サーバーを起動します。

```bash
# 開発サーバーの起動
bundle exec rails server

# または短縮形
bundle exec rails s
```

ブラウザで `http://localhost:3000` にアクセスし、Railsアプリケーションが正常に起動していることを確認します。

### 💡 究極の「まさかり」：Dockerへの移行

最近の現場では、Macに直接Rubyを入れるのではなく、「Docker」で環境を閉じるのが主流です。

#### なぜDockerを使うのか

「自分のPCでは動くのに、チームメイトのPCでは動かない」という環境の不一致を防ぐため、最初からDockerfileとdocker-compose.ymlで構築する手順に舵を切るのも、令和の設計原則としては正解です。

Dockerを使用することで以下のメリットがあります：

- **環境の統一**: チーム全体で同じ開発環境を共有できる
- **OS非依存**: macOS、Linux、Windows問わず同じ環境を構築できる
- **クリーンな環境**: ホストマシンを汚さずに、コンテナ内で完結する
- **再現性**: 常に同じ環境を再現できる

#### Dockerでの環境構築の流れ

Dockerを使用する場合の基本的な流れは以下の通りです：

1. **Dockerfileの作成**: RubyとRailsの環境を定義
2. **docker-compose.ymlの作成**: アプリケーションとPostgreSQLなどのサービスを定義
3. **コンテナのビルドと起動**: `docker-compose up`で環境を構築

詳細なDockerを使った環境構築手順は、Dockerガイドを参照してください。

### 【注意】「魔法」に頼りすぎない

Railsは非常に賢いフレームワークですが、裏側で何が起きているか（SQLがどう発行されているかなど）を意識しないと、「N+1問題」などのパフォーマンス劣化を簡単に引き起こします。

#### N+1問題とは

N+1問題は、データベースへのクエリが不必要に多く発行される問題です。例えば、記事（Article）とその著者（Author）の関係がある場合、以下のようなコードは問題を引き起こします：

```ruby
# 問題のあるコード例
@articles = Article.all
@articles.each do |article|
  puts article.author.name  # 各記事ごとに著者の情報を取得するクエリが発行される
end
```

この場合、最初に記事一覧を取得するクエリが1回（N件の記事）、その後各記事の著者情報を取得するクエリがN回発行されます。合計で1+N回のクエリが発行されるため、「N+1問題」と呼ばれます。

#### N+1問題の解決方法

Railsでは、`includes`や`preload`、`eager_load`などのメソッドを使用して、関連データを事前に読み込むことで解決できます：

```ruby
# 解決策: includesを使用
@articles = Article.includes(:author).all
@articles.each do |article|
  puts article.author.name  # 追加のクエリは発行されない
end
```

この場合、記事と著者の情報が2回のクエリ（1回で記事を取得、1回で著者を取得）で効率的に取得されます。

#### パフォーマンスを意識する重要性

Railsの「魔法」に頼りすぎず、以下を意識することが重要です：

- **発行されるSQLを確認する**: `rails console`やログで、実際に発行されているSQLを確認する習慣をつける
- **クエリログを監視する**: 開発環境でもクエリログを確認し、不必要なクエリがないかチェックする
- **パフォーマンステストを書く**: 重要な処理にはパフォーマンステストを書いて、問題を早期に発見する
- **N+1問題検出ツールを使用する**: `bullet`などのGemを使用して、開発中にN+1問題を自動検出する

```ruby
# Gemfileに追加
group :development do
  gem 'bullet'
end
```

環境構築の段階から、これらの意識を持って開発を始めることが、後々のパフォーマンス問題を防ぐことにつながります。

### 【設計のヒント】モノリス構成とAPIサーバー構成の選択

最初はViewまでRailsで作る「モノリス構成」が楽ですが、将来的にReact等でSPA化したい場合は、最初から`rails new --api`でAPIサーバーとして構築する選択肢も検討しましょう。

#### モノリス構成（従来型）

モノリス構成では、Railsがフロントエンドとバックエンドの両方を担当します。ERBやSlimなどのテンプレートエンジンを使用して、サーバー側でHTMLを生成します。

```bash
# モノリス構成でのRailsプロジェクト作成
rails new my_app --database=postgresql
```

**メリット**:
- 開発が簡単で、Railsの機能をフル活用できる
- 初期の開発速度が速い
- セッション管理やCSRF対策など、Railsの標準機能がそのまま使える
- SEO対策が比較的容易（サーバーサイドレンダリング）

**デメリット**:
- フロントエンドとバックエンドが密結合になりやすい
- SPA化する際に大規模なリファクタリングが必要になる可能性がある
- フロントエンドの複雑なUIの実装が難しい場合がある

#### APIサーバー構成（rails new --api）

APIサーバー構成では、RailsはバックエンドAPIのみを担当し、フロントエンドは別のアプリケーション（React、Vue.js、Next.jsなど）で構築します。

```bash
# APIサーバーとしてRailsプロジェクトを作成
rails new my_app --api --database=postgresql
```

`--api`オプションを指定すると、以下のような変更が行われます：

- Viewファイルやヘルパーメソッドが生成されない
- CSRFトークン保護が無効化される（代わりにAPIトークン認証などを使用）
- ミドルウェアが最適化される（API用途に不要なものは除外）
- JSONレスポンスに最適化された設定になる

**メリット**:
- フロントエンドとバックエンドの責任が明確に分離される
- モダンなフロントエンドフレームワーク（React、Vue.jsなど）を自由に選択できる
- 将来のSPA化を前提とした設計が容易
- モバイルアプリなど、複数のクライアントに対応しやすい
- チーム内でフロントエンドとバックエンドを分業しやすい

**デメリット**:
- 初期の開発コストがやや高い（フロントエンドとバックエンドを別々に開発）
- 認証・認可の実装が必要（JWT、OAuthなど）
- CORSの設定が必要になる場合がある
- SEO対策に工夫が必要（SSR、SSGなどの技術を検討）

#### どちらを選ぶべきか

プロジェクトの要件や将来の展開を考慮して選択しましょう：

**モノリス構成を選ぶべき場合**:
- 小規模なプロジェクトで、迅速にリリースしたい場合
- Railsの標準的な機能で十分な場合
- チームにRails開発者が多く、フロントエンド専門家がいない場合
- SEOが重要なマーケティングサイトの場合

**APIサーバー構成を選ぶべき場合**:
- 将来的にSPA化することが確定している場合
- 複数のクライアント（Web、モバイルアプリなど）に対応する必要がある場合
- フロントエンドとバックエンドで専門性を分けたい場合
- モダンなフロントエンドフレームワークを使用したい場合

#### ハイブリッドアプローチ

また、段階的な移行も可能です：

1. **初期段階**: モノリス構成で開発を開始
2. **段階的にAPI化**: 特定の機能からAPIとして提供し始める
3. **完全なAPI化**: フロントエンドを完全にSPAに移行

このアプローチでは、既存のRailsアプリケーションにAPIエンドポイントを追加し、徐々にフロントエンドを切り替えていくことができます。

環境構築の段階から、プロジェクトの将来像を考慮した設計選択を行うことが、長期的な保守性と拡張性につながります。

### まとめ

実務レベルのRails環境構築では、以下の手順を踏みます：

1. **OSレイヤーの準備**: HomebrewでRubyのビルドに必要なツールを揃える
2. **ランタイム管理**: rbenvでRubyを入れる
3. **周辺環境の整備**: Node.jsとPostgreSQLをインストール・起動する
4. **プロジェクト開始**: `rails new`を`bundle exec`経由で行い、バージョンを`Gemfile.lock`で固定する

また、最近の現場ではDockerを使用した環境構築も検討することをおすすめします。これにより、チーム全体で一貫した開発環境を維持できます。