---
title: Riverpodによる状態管理
sidebar:
    label: Riverpod
---

## RiverpodとProviderの比較 ⚖️
RiverpodとProviderは、どちらもFlutterで状態管理を行うためのライブラリですが、依存関係の管理方法と安全性に大きな違いがあります。

| 特徴 | Provider | Riverpod |
| --- | --- | --- |
| 依存関係 | ウィジェットツリーに依存 | ウィジェットツリーから独立 |
| 安全性 | 実行時にエラーが発生する可能性あり | 型安全で、コンパイル時にエラーを検知 |
| ボイラープレート | 多い | 少ない |
| テスト | ウィジェットツリーをモックする必要あり | プロバイダ単体をテスト可能 |

### Provider
Providerは、ウィジェットツリーを介して状態を供給します。そのため、`Provider.of(context)`のように、状態にアクセスする際に`BuildContext`を必要とします。この依存性から、状態にアクセスするウィジェットがツリーのどこに位置するかを常に意識する必要があります。

### Riverpod
Riverpodは、ウィジェットツリーから独立しています。プロバイダはグローバルに定義され、どのウィジェットからでも安全にアクセスできます。これにより、複雑なウィジェットツリーを持つアプリケーションでも、依存関係をシンプルに管理できます。

## Providerの基本的な使い方 💡
Providerは、シンプルで直感的な状態管理に適しています。

### 1. プロバイダの定義
`ChangeNotifierProvider`は、状態が変更されたときにリスナーに通知する機能を提供します。

```dart
// 状態を管理するモデルクラス
class Counter with ChangeNotifier {
  int _count = 0;

  int get count => _count;

  void increment() {
    _count++;
    notifyListeners(); // 状態が変更されたことを通知
  }
}

// プロバイダの定義
final counterProvider = ChangeNotifierProvider((ref) => Counter());
```

### 2. 状態へのアクセス
`Provider.of`や`Consumer`ウィジェットを使って、状態にアクセスします。

```dart
// Provider.ofを使用
final counter = Provider.of<Counter>(context);
counter.increment();

// Consumerウィジェットを使用
Consumer<Counter>(
  builder: (context, counter, child) {
    return Text('${counter.count}');
  },
)
```

## Riverpodの基本的な使い方 ✨
Riverpodは、より安全で、テストしやすい状態管理を提供します。

### 1. プロバイダの定義
`StateNotifierProvider`は、状態とロジックを分離するのに適しています。

```dart
// 状態を管理するクラス（StateNotifierを継承）
class CounterNotifier extends StateNotifier<int> {
  CounterNotifier() : super(0); // 初期値は0

  void increment() {
    state++; // stateで状態を直接更新
  }
}

// プロバイダの定義
final counterProvider = StateNotifierProvider<CounterNotifier, int>((ref) {
  return CounterNotifier();
});
```

### 2. 状態へのアクセス
`ConsumerWidget`または`Consumer`ウィジェットを使い、`ref`を介して状態にアクセスします。

```dart
// ConsumerWidgetを使用
class CounterPage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 状態を監視（変化を検知）
    final count = ref.watch(counterProvider);
    
    return Text('$count');
  }
}
```

## 実践的な使い分け 🗺️
- **Provider**:
  - 小規模なアプリケーションや、状態管理の概念を学び始める場合に適しています。
  - 既存のコードベースに部分的に状態管理を導入したい場合に、シンプルで扱いやすいです。

- **Riverpod**:
  - 大規模で複雑なアプリケーションに適しています。
  - 堅牢なテスト体制を構築したい場合。
  - ウィジェットツリーの階層に依存しない、より安全で予測可能な状態管理を求める場合。

多くの開発者は、新しいプロジェクトを始める際にはRiverpodを選択することが多くなっています。Riverpodは、Providerの利点をすべて持ちつつ、より多くの問題点を解決しているからです。

## Riverpodの概要
Riverpodは、Flutterアプリケーションでの状態管理を簡素化するためのライブラリです。Providerの進化版として、より柔軟で安全な状態管理を提供します。

### なぜRiverpodを使うのか
- **型安全**: 型安全な状態管理が可能です。コンパイル時に型チェックが行われるため、バグを未然に防ぐことができます。
- **ホットリロード対応**: 状態を保持したままホットリロードが可能です。開発中にコードを変更しても、アプリの状態を失うことなく即座に反映されます。
- **依存関係の管理**: Riverpodは、プロバイダ間の依存関係を明示的に定義できるため、複雑なアプリケーションでも管理が容易です。
- **テストの容易さ**: Riverpodは、状態管理のロジックを分離してテストしやすくします。プロバイダをモック化することで、ユニットテストが簡単に行えます。

### よく使われるプロバイダの種類
- **`Provider`**: 読み取り専用の状態を提供します。
- **`StateProvider`**: 状態を持ち、変更可能な状態を提供します。
- **`FutureProvider`**: 非同期処理の結果を提供します。
- **`StreamProvider`**: ストリームのデータを提供します。

## Riverpodのインストール
Riverpodをプロジェクトに追加するには、以下のコマンドを実行します。

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod: ^1.0.0 // ここに追加
```

```bash
flutter pub add flutter_riverpod
```

## Riverpodによる状態管理の実践 🚀
Riverpodは、Flutterの状態管理ライブラリの中でも特に人気が高く、大規模アプリケーション開発に適しています。

### 1. なぜRiverpodを使うのか
Riverpodは、従来のProviderライブラリの弱点を克服するために開発されました。

- **型安全性の向上**: Providerは特定のウィジェットツリーに依存していましたが、Riverpodはグローバルにプロバイダを定義するため、より安全に型を扱えます。
- **ボイラープレートの削減**: `ConsumerWidget`や`Consumer`を使用することで、状態の監視と利用を簡潔に記述できます。

### 2. よく使われるプロバイダの種類
プロバイダは、アプリケーションの状態を保持し、ウィジェットに提供するための「箱」です。

- **Provider**: 単純な値を渡す際に使います。変更されない設定値や、サービスインスタンスなどに適しています。
- **StateProvider**: 変更可能な状態を管理します。シンプルなカウンターアプリなど、UIから直接変更される状態に使います。
- **StateNotifierProvider**: より複雑な状態（複数のプロパティを持つクラスなど）と、その状態を変更するロジックを管理します。ビジネスロジックをUIから分離する際に非常に重要です。
- **FutureProvider & StreamProvider**: 非同期処理（API通信など）の結果を管理します。ローディング、エラー、データの各状態を自動的に処理してくれるため、非常に便利です。

### 3. カウンターアプリのより実践的な例
単純なカウンターアプリでも、`StateNotifierProvider`を使うことで、ビジネスロジックを分離できます。

```dart
// 状態を管理するクラス（ビジネスロジック）
class CounterNotifier extends StateNotifier<int> {
  CounterNotifier() : super(0); // 初期値は0

  void increment() {
    state++; // 状態を更新
  }
}

// StateNotifierProviderを定義
final counterProvider = StateNotifierProvider<CounterNotifier, int>((ref) {
  return CounterNotifier();
});

class CounterPage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 状態を監視
    final count = ref.watch(counterProvider);
    
    return Scaffold(
      appBar: AppBar(title: const Text('Riverpod Counter')),
      body: Center(
        child: Text('$count', style: Theme.of(context).textTheme.headline4),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // ビジネスロジックを呼び出す
          ref.read(counterProvider.notifier).increment();
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

## UIコンポーネントのカスタマイズと再利用 🎨
Flutterは「すべてがウィジェット」という思想に基づいています。カスタムウィジェットを作成し、再利用することは、大規模アプリ開発の基本です。

### 1. なぜカスタムウィジェットを作るのか
- **コードの重複を避ける**: 複数の画面で同じデザインのボタンやカードを使う場合に、カスタムウィジェットとして定義することで、コードの重複をなくせます。
- **メンテナンス性の向上**: UIの変更が必要になった場合、カスタムウィジェットを1箇所修正するだけで、アプリ全体のUIが更新されます。
- **関心の分離**: UIのデザインとロジックを分離することで、コードが読みやすくなります。

### 2. カスタムウィジェットのベストプラクティス
- カスタムウィジェットは、可能な限り**StatelessWidget**として作成しましょう。これにより、不要な再構築を防ぎ、パフォーマンスを向上させます。
- 親ウィジェットから受け取るデータは`final`で宣言し、コンストラクタで受け取るようにします。
- ウィジェット内で状態を持つ必要がある場合は、`StatefulWidget`を使用しますが、必要最低限に留めます。

## パフォーマンス最適化の実践 ⚙️
美しいUIだけでなく、スムーズな動作も重要です。

### 1. イメージの最適化
画像はアプリのサイズとパフォーマンスに大きく影響します。

- **適切なフォーマットの選択**: WebPやPNGは、JPEGよりも透明度をサポートし、より高い圧縮率を提供します。
- **画像の解像度**: デバイスの画面サイズに合わせて、適切な解像度の画像を準備しましょう。
- **画像のキャッシュ**: `CachedNetworkImage`のようなライブラリを使って、ネットワークから取得した画像をキャッシュすることで、再度ダウンロードする手間を省きます。

### 2. ウィジェットの再構築の最適化
Flutterは高速ですが、不必要なウィジェットの再構築はパフォーマンス低下の原因になります。

- **constコンストラクタ**: コンパイル時に値が確定するウィジェットには、`const`を付けましょう。これにより、再構築時にウィジェットが再作成されるのを防ぎます。
- **Consumerウィジェット**: `Consumer`は、監視しているプロバイダが更新されたときのみ、その子ウィジェットを再構築します。これにより、不要なUIの再構築を最小限に抑えられます。
- **selectメソッド**: プロバイダ内の複数のプロパティのうち、特定のプロパティが変更されたときのみ再構築したい場合に`select`を使用します。これにより、よりピンポイントな再構築が可能になります。

これらの実践的なアドバイスを適用することで、より効率的で、パフォーマンスの高いFlutterアプリケーションを開発できます。