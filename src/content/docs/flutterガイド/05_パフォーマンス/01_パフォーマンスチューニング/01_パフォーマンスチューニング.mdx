---
title: パフォーマンス最適化
sidebar:
    label: パフォーマンス最適化
---

# Flutterパフォーマンス最適化完全ガイド

Flutterアプリケーションのパフォーマンスを向上させるための実践的なテクニックを詳しく解説します。

## 1. Widgetの再構築を最小限に抑える

### constコンストラクタの使用

```dart
// 悪い例
Widget build(BuildContext context) {
  return Column(
    children: [
      Text('Hello'),
      Text('World'),
    ],
  );
}

// 良い例
Widget build(BuildContext context) {
  return Column(
    children: const [
      Text('Hello'),
      Text('World'),
    ],
  );
}
```

### constコンストラクタの効果

- 再構築時に同じインスタンスを再利用
- メモリ使用量の削減
- パフォーマンスの向上

### RepaintBoundaryの使用

再描画が必要な部分だけを分離します。

```dart
class OptimizedWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        RepaintBoundary(
          child: AnimatedWidget(), // 頻繁に再描画される部分
        ),
        StaticWidget(), // 再描画が不要な部分
      ],
    );
  }
}
```

## 2. リストのパフォーマンス最適化

### ListView.builderの使用

```dart
// 悪い例: すべてのアイテムを一度に構築
ListView(
  children: items.map((item) => ListTile(title: Text(item))).toList(),
)

// 良い例: 必要なアイテムだけを構築
ListView.builder(
  itemCount: items.length,
  itemBuilder: (context, index) {
    return ListTile(
      title: Text(items[index]),
    );
  },
)
```

### アイテムのキーを指定

```dart
ListView.builder(
  itemCount: items.length,
  itemBuilder: (context, index) {
    return ListTile(
      key: ValueKey(items[index].id), // 一意のキーを指定
      title: Text(items[index].title),
    );
  },
)
```

### 仮想スクロールの最適化

```dart
ListView.builder(
  itemCount: items.length,
  cacheExtent: 500, // キャッシュする範囲を指定
  itemBuilder: (context, index) {
    return ListTile(
      title: Text(items[index]),
    );
  },
)
```

## 3. 画像の最適化

### CachedNetworkImageの使用

```dart
import 'package:cached_network_image/cached_network_image.dart';

CachedNetworkImage(
  imageUrl: 'https://example.com/image.jpg',
  placeholder: (context, url) => CircularProgressIndicator(),
  errorWidget: (context, url, error) => Icon(Icons.error),
  memCacheWidth: 200, // メモリ内の画像サイズを制限
  memCacheHeight: 200,
)
```

### 画像の遅延読み込み

```dart
class LazyImage extends StatelessWidget {
  final String imageUrl;

  LazyImage(this.imageUrl);

  @override
  Widget build(BuildContext context) {
    return Image.network(
      imageUrl,
      loadingBuilder: (context, child, loadingProgress) {
        if (loadingProgress == null) return child;
        return CircularProgressIndicator();
      },
    );
  }
}
```

### 画像のリサイズ

```dart
Image.network(
  imageUrl,
  width: 200,
  height: 200,
  fit: BoxFit.cover,
)
```

## 4. メモリリークの検出と対策

### よくあるメモリリークの原因

1. **コントローラーの破棄漏れ**

```dart
// 悪い例
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: Duration(seconds: 1),
      vsync: this,
    );
  }

  // disposeが実装されていない！
}

// 良い例
class _MyWidgetState extends State<MyWidget> {
  AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: Duration(seconds: 1),
      vsync: this,
    );
  }

  @override
  void dispose() {
    _controller.dispose(); // 必ず破棄
    super.dispose();
  }
}
```

2. **ストリームの購読解除漏れ**

```dart
// 悪い例
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  StreamSubscription? _subscription;

  @override
  void initState() {
    super.initState();
    _subscription = stream.listen((data) {
      // 処理
    });
  }

  // 購読解除が実装されていない！
}

// 良い例
class _MyWidgetState extends State<MyWidget> {
  StreamSubscription? _subscription;

  @override
  void initState() {
    super.initState();
    _subscription = stream.listen((data) {
      // 処理
    });
  }

  @override
  void dispose() {
    _subscription?.cancel(); // 必ず購読解除
    super.dispose();
  }
}
```

### メモリリークの検出方法

```bash
# Flutter DevToolsでメモリプロファイリング
flutter run --profile
# ブラウザでDevToolsを開く
```

## 5. ビルドサイズの最適化

### コード分割

```dart
// 必要な時だけインポート
import 'package:my_package/screen1.dart' deferred as screen1;

Future<void> loadScreen1() async {
  await screen1.loadLibrary();
  // screen1を使用
}
```

### 未使用のリソースの削除

```yaml
# pubspec.yaml
flutter:
  assets:
    - images/icon.png  # 必要なリソースのみ指定
```

### ProGuard/R8の設定（Android）

```gradle
// android/app/build.gradle
buildTypes {
  release {
    minifyEnabled true
    shrinkResources true
    proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
  }
}
```

### ビルドサイズの確認

```bash
# APKのサイズを確認
flutter build apk --analyze-size

# iOSのサイズを確認
flutter build ios --analyze-size
```

## 6. アニメーションの最適化

### AnimatedBuilderの使用

```dart
// 悪い例: 全体が再構築される
class BadAnimatedWidget extends StatefulWidget {
  @override
  _BadAnimatedWidgetState createState() => _BadAnimatedWidgetState();
}

class _BadAnimatedWidgetState extends State<BadAnimatedWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  Widget build(BuildContext context) {
    return Transform.rotate(
      angle: _controller.value * 2 * 3.14159,
      child: ExpensiveWidget(), // 毎回再構築される
    );
  }
}

// 良い例: 必要な部分だけ再構築
class GoodAnimatedWidget extends StatefulWidget {
  @override
  _GoodAnimatedWidgetState createState() => _GoodAnimatedWidgetState();
}

class _GoodAnimatedWidgetState extends State<GoodAnimatedWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Transform.rotate(
          angle: _controller.value * 2 * 3.14159,
          child: child, // constウィジェットを再利用
        );
      },
      child: const ExpensiveWidget(), // constで再構築を防ぐ
    );
  }
}
```

## 7. 実務でのパフォーマンス分析手法

### Flutter DevToolsの活用

```bash
# DevToolsの起動
flutter pub global activate devtools
flutter pub global run devtools
```

#### パフォーマンスタブ

- **Frame Rendering**: フレームレンダリング時間の確認
- **Memory**: メモリ使用量の監視
- **CPU**: CPU使用率の確認

#### メモリタブ

- **Heap Snapshot**: メモリのスナップショット取得
- **Memory Timeline**: メモリ使用量の推移を確認

### パフォーマンス測定

```dart
import 'package:flutter/foundation.dart';

void measurePerformance() {
  final stopwatch = Stopwatch()..start();
  
  // 測定したい処理
  performExpensiveOperation();
  
  stopwatch.stop();
  if (kDebugMode) {
    print('Operation took: ${stopwatch.elapsedMilliseconds}ms');
  }
}
```

## 8. レンダリング最適化のテクニック

### Opacityの代わりにColorFilterを使用

```dart
// 悪い例: Opacityは重い
Opacity(
  opacity: 0.5,
  child: Image.network(imageUrl),
)

// 良い例: ColorFilterを使用
ColorFiltered(
  colorFilter: ColorFilter.mode(Colors.white.withOpacity(0.5), BlendMode.modulate),
  child: Image.network(imageUrl),
)
```

### Clipの最適化

```dart
// 悪い例: 不要なClip
ClipRRect(
  borderRadius: BorderRadius.circular(0), // 不要
  child: Container(),
)

// 良い例: 必要な場合のみClip
Container(
  decoration: BoxDecoration(
    borderRadius: BorderRadius.circular(8),
  ),
)
```

## 9. よくある問題と解決策

### 問題1: アプリが重い

**解決策**:
- `const`コンストラクタを積極的に使用
- `ListView.builder`を使用
- 不要な再構築を避ける

### 問題2: メモリ使用量が多い

**解決策**:
- コントローラーやストリームを確実に破棄
- 画像のサイズを制限
- キャッシュの適切な管理

### 問題3: ビルドサイズが大きい

**解決策**:
- 未使用のリソースを削除
- コード分割を活用
- ProGuard/R8を有効化

これで、Flutterアプリケーションのパフォーマンス最適化の実装方法を理解できるようになりました。