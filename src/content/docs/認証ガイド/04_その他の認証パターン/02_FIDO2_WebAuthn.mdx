---
title: "FIDO2/WebAuthn"
label: "FIDO2/WebAuthn"
---

## ğŸ” FIDO2/WebAuthn

`FIDO2/WebAuthn`ã¯ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ¬ã‚¹`èªè¨¼`ã‚’å®Ÿç¾ã™ã‚‹æ¨™æº–ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚ç”Ÿä½“èªè¨¼ã‚„ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦ã€ã‚ˆã‚Šå®‰å…¨ã§åˆ©ä¾¿æ€§ã®é«˜ã„`èªè¨¼`ã‚’æä¾›ã—ã¾ã™ã€‚

### ğŸ¯ ãªãœFIDO2/WebAuthnãŒé‡è¦ãªã®ã‹

#### âš ï¸ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ¬ã‚¹èªè¨¼ã®å¿…è¦æ€§

**ğŸ’¡ å®Ÿéš›ã®äº‹ä¾‹:**

ã‚ã‚‹ä¼æ¥­ã§ã€`ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰`é–¢é€£ã®`ã‚µãƒãƒ¼ãƒˆã‚³ã‚¹ãƒˆ`ãŒå¹´é–“ç´„5000ä¸‡å††ã§ã—ãŸï¼š

- âŒ **å•é¡Œ**: 
  - âš ï¸ `ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰`ã®ãƒªã‚»ãƒƒãƒˆè¦æ±‚ãŒå¤šç™º
  - ğŸ”¥ `ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰`ã®ä½¿ã„å›ã—ã«ã‚ˆã‚‹`ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯`
  - ğŸ’¸ `ã‚µãƒãƒ¼ãƒˆã‚³ã‚¹ãƒˆ`ã®å¢—åŠ 

**âœ… FIDO2/WebAuthnå°å…¥å¾Œã®åŠ¹æœ:**
- âœ… `ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰`é–¢é€£ã®`ã‚µãƒãƒ¼ãƒˆã‚³ã‚¹ãƒˆ`ãŒç´„80%å‰Šæ¸›
- âœ… `ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆ`ãŒç´„90%æ¸›å°‘
- âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼æº€è¶³åº¦ãŒå‘ä¸Š

**æ•™è¨“:**
- âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ¬ã‚¹`èªè¨¼`ã¯ã€`ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£`ã¨åˆ©ä¾¿æ€§ã®ä¸¡æ–¹ã‚’å‘ä¸Šã•ã›ã‚‹
- âœ… `FIDO2/WebAuthn`ã¯ã€æ¥­ç•Œæ¨™æº–ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ¬ã‚¹`èªè¨¼`ãƒ—ãƒ­ãƒˆã‚³ãƒ«
- âœ… ç”Ÿä½“èªè¨¼ã‚„ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãƒˆãƒ¼ã‚¯ãƒ³ã§ã€ã‚ˆã‚Šå®‰å…¨ãª`èªè¨¼`ã‚’å®Ÿç¾

### ğŸ”„ FIDO2/WebAuthnã®ä»•çµ„ã¿

#### â• 1. ç™»éŒ²ãƒ•ãƒ­ãƒ¼

**ç™»éŒ²ãƒ•ãƒ­ãƒ¼ã®å®Ÿè£…:**

```javascript
// FIDO2/WebAuthnç™»éŒ²ã®å®Ÿè£…
class WebAuthnRegistration {
  async register(userId, userName) {
    // 1. ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã‚’ç”Ÿæˆ
    const challenge = this.generateChallenge();
    
    // 2. å…¬é–‹éµã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ä½œæˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
    const publicKeyCredentialCreationOptions = {
      challenge: challenge,
      rp: {
        name: 'MyApp',
        id: 'example.com',
      },
      user: {
        id: this.encodeUserId(userId),
        name: userName,
        displayName: userName,
      },
      pubKeyCredParams: [
        { alg: -7, type: 'public-key' },  // ES256
        { alg: -257, type: 'public-key' }, // RS256
      ],
      authenticatorSelection: {
        authenticatorAttachment: 'platform',  // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ èªè¨¼å™¨ï¼ˆæŒ‡ç´‹ãªã©ï¼‰
        userVerification: 'required',
        requireResidentKey: false,
      },
      timeout: 60000,
      attestation: 'direct',
    };
    
    // 3. ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ã‚’ä½œæˆ
    const credential = await navigator.credentials.create({
      publicKey: publicKeyCredentialCreationOptions,
    });
    
    // 4. ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
    const response = await fetch('/api/webauthn/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        userId,
        credential: {
          id: credential.id,
          rawId: this.arrayBufferToBase64(credential.rawId),
          response: {
            attestationObject: this.arrayBufferToBase64(
              credential.response.attestationObject
            ),
            clientDataJSON: this.arrayBufferToBase64(
              credential.response.clientDataJSON
            ),
          },
          type: credential.type,
        },
        challenge,
      }),
    });
    
    if (!response.ok) {
      throw new Error('Registration failed');
    }
    
    return await response.json();
  }
  
  generateChallenge() {
    // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒãƒ£ãƒ¬ãƒ³ã‚¸ã‚’ç”Ÿæˆ
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return this.arrayBufferToBase64(array);
  }
  
  encodeUserId(userId) {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’Uint8Arrayã«å¤‰æ›
    return new Uint8Array(Buffer.from(userId, 'utf8'));
  }
  
  arrayBufferToBase64(buffer) {
    // ArrayBufferã‚’Base64ã«å¤‰æ›
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
}
```

#### ğŸ” 2. èªè¨¼ãƒ•ãƒ­ãƒ¼

**èªè¨¼ãƒ•ãƒ­ãƒ¼ã®å®Ÿè£…:**

```javascript
// FIDO2/WebAuthnèªè¨¼ã®å®Ÿè£…
class WebAuthnAuthentication {
  async authenticate(userId) {
    // 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«IDã‚’å–å¾—
    const credentials = await this.getUserCredentials(userId);
    
    if (credentials.length === 0) {
      throw new Error('No credentials found');
    }
    
    // 2. ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã‚’ç”Ÿæˆ
    const challenge = this.generateChallenge();
    
    // 3. å…¬é–‹éµã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«è¦æ±‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
    const publicKeyCredentialRequestOptions = {
      challenge: challenge,
      allowCredentials: credentials.map(cred => ({
        id: this.base64ToArrayBuffer(cred.credentialId),
        type: 'public-key',
        transports: ['internal', 'usb', 'nfc', 'ble'],
      })),
      timeout: 60000,
      userVerification: 'required',
    };
    
    // 4. ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ã‚’å–å¾—
    const assertion = await navigator.credentials.get({
      publicKey: publicKeyCredentialRequestOptions,
    });
    
    // 5. ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
    const response = await fetch('/api/webauthn/authenticate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        userId,
        assertion: {
          id: assertion.id,
          rawId: this.arrayBufferToBase64(assertion.rawId),
          response: {
            authenticatorData: this.arrayBufferToBase64(
              assertion.response.authenticatorData
            ),
            clientDataJSON: this.arrayBufferToBase64(
              assertion.response.clientDataJSON
            ),
            signature: this.arrayBufferToBase64(
              assertion.response.signature
            ),
            userHandle: assertion.response.userHandle
              ? this.arrayBufferToBase64(assertion.response.userHandle)
              : null,
          },
          type: assertion.type,
        },
        challenge,
      }),
    });
    
    if (!response.ok) {
      throw new Error('Authentication failed');
    }
    
    return await response.json();
  }
  
  async getUserCredentials(userId) {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ã‚’å–å¾—
    const response = await fetch(`/api/webauthn/credentials/${userId}`);
    return await response.json();
  }
  
  base64ToArrayBuffer(base64) {
    // Base64ã‚’ArrayBufferã«å¤‰æ›
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }
}
```

#### ğŸ–¥ï¸ 3. ã‚µãƒ¼ãƒãƒ¼å´ã®å®Ÿè£…

**ã‚µãƒ¼ãƒãƒ¼å´ã®å®Ÿè£…:**

```javascript
// FIDO2/WebAuthnã‚µãƒ¼ãƒãƒ¼å´ã®å®Ÿè£…
const cbor = require('cbor');
const { Fido2Lib } = require('fido2-lib');

class WebAuthnServer {
  constructor() {
    this.f2l = new Fido2Lib({
      timeout: 60000,
      rpId: 'example.com',
      rpName: 'MyApp',
      rpIcon: 'https://example.com/icon.png',
      challengeSize: 128,
      attestation: 'direct',
      cryptoParams: [-7, -257],
      authenticatorAttachment: 'platform',
      authenticatorRequireResidentKey: false,
      userVerification: 'required',
    });
  }
  
  async register(userId, credential, challenge) {
    // 1. ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ã‚’æ¤œè¨¼
    const attestationExpectations = {
      challenge: challenge,
      origin: 'https://example.com',
      factor: 'either',
    };
    
    const regResult = await this.f2l.attestationResult(
      credential.response.attestationObject,
      credential.response.clientDataJSON,
      attestationExpectations
    );
    
    // 2. ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ã‚’ä¿å­˜
    await db.webauthnCredentials.create({
      userId,
      credentialId: credential.id,
      publicKey: regResult.authnrData.get('credentialPublicKey'),
      counter: regResult.authnrData.get('counter'),
      createdAt: new Date(),
    });
    
    return { success: true };
  }
  
  async authenticate(userId, assertion, challenge) {
    // 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ã‚’å–å¾—
    const credential = await db.webauthnCredentials.findOne({
      userId,
      credentialId: assertion.id,
    });
    
    if (!credential) {
      throw new Error('Credential not found');
    }
    
    // 2. ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ¤œè¨¼
    const assertionExpectations = {
      challenge: challenge,
      origin: 'https://example.com',
      factor: 'either',
      publicKey: credential.publicKey,
      prevCounter: credential.counter,
      userHandle: null,
    };
    
    const authResult = await this.f2l.assertionResult(
      assertion.response.authenticatorData,
      assertion.response.clientDataJSON,
      assertion.response.signature,
      assertionExpectations
    );
    
    // 3. ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’æ›´æ–°
    await db.webauthnCredentials.update(credential.id, {
      counter: authResult.authnrData.get('counter'),
      lastUsedAt: new Date(),
    });
    
    // 4. ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
    const sessionToken = await this.createSession(userId);
    
    return {
      success: true,
      sessionToken,
    };
  }
}
```

### âœ… FIDO2/WebAuthnã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

#### ğŸ”„ 1. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èªè¨¼

**ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èªè¨¼ã®å®Ÿè£…:**

```javascript
// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èªè¨¼ã®å®Ÿè£…
class FallbackAuthentication {
  async authenticate(userId, method) {
    // WebAuthnãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ
    if (this.isWebAuthnSupported() && method === 'webauthn') {
      try {
        return await webAuthnAuth.authenticate(userId);
      } catch (error) {
        // WebAuthnèªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        console.error('WebAuthn authentication failed:', error);
      }
    }
    
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    if (method === 'password') {
      return await passwordAuth.authenticate(userId);
    }
    
    // å¤šè¦ç´ èªè¨¼ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    if (method === 'mfa') {
      return await mfaAuth.authenticate(userId);
    }
    
    throw new Error('Authentication method not supported');
  }
  
  isWebAuthnSupported() {
    // WebAuthnãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    return !!(
      window.PublicKeyCredential &&
      navigator.credentials &&
      navigator.credentials.create
    );
  }
}
```

#### ğŸ”‘ 2. è¤‡æ•°ã®èªè¨¼å™¨ã®ç®¡ç†

**è¤‡æ•°ã®èªè¨¼å™¨ã®ç®¡ç†:**

```javascript
// è¤‡æ•°ã®èªè¨¼å™¨ã®ç®¡ç†
class AuthenticatorManager {
  async registerAuthenticator(userId, authenticatorInfo) {
    // èªè¨¼å™¨ã‚’ç™»éŒ²
    await db.authenticators.create({
      userId,
      credentialId: authenticatorInfo.credentialId,
      name: authenticatorInfo.name,  // ä¾‹: "iPhoneã®æŒ‡ç´‹èªè¨¼"
      type: authenticatorInfo.type,  // ä¾‹: "platform"
      registeredAt: new Date(),
    });
  }
  
  async getUserAuthenticators(userId) {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èªè¨¼å™¨ä¸€è¦§ã‚’å–å¾—
    return await db.authenticators.find({ userId });
  }
  
  async removeAuthenticator(userId, credentialId) {
    // èªè¨¼å™¨ã‚’å‰Šé™¤
    await db.authenticators.delete({
      userId,
      credentialId,
    });
    
    // ã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ã‚‚å‰Šé™¤
    await db.webauthnCredentials.delete({
      userId,
      credentialId,
    });
  }
}
```

### ğŸ¯ ã¾ã¨ã‚

`FIDO2/WebAuthn`ã®ãƒã‚¤ãƒ³ãƒˆï¼š

- âœ… **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ¬ã‚¹**: `ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰`ä¸è¦ã®`èªè¨¼`
- ğŸ”’ **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: ç”Ÿä½“èªè¨¼ã‚„ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãƒˆãƒ¼ã‚¯ãƒ³ã§é«˜ã„`ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£`
- âœ… **åˆ©ä¾¿æ€§**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®å‘ä¸Š
- ğŸŒ **æ¨™æº–ãƒ—ãƒ­ãƒˆã‚³ãƒ«**: æ¥­ç•Œæ¨™æº–ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«
- ğŸ”„ **ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**: è¤‡æ•°ã®`èªè¨¼`æ–¹æ³•ã‚’ã‚µãƒãƒ¼ãƒˆ

é©åˆ‡ãª`FIDO2/WebAuthn`ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ¬ã‚¹ã§å®‰å…¨ãª`èªè¨¼`ã‚’æä¾›ã§ãã¾ã™ã€‚

