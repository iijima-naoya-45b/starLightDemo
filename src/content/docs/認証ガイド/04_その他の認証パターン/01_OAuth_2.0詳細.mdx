---
title: "OAuth 2.0è©³ç´°"
label: "OAuth 2.0è©³ç´°"
---

## ğŸ” OAuth 2.0è©³ç´°

`OAuth 2.0`ã¯ã€ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®èªå¯ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚`èªè¨¼`ã«ã‚‚ä½¿ç”¨ã§ãã€å¤šãã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§æ¡ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

### ğŸ¯ ãªãœOAuth 2.0ãŒé‡è¦ãªã®ã‹

#### âœ… OAuth 2.0ã®å¿…è¦æ€§

**ğŸ’¡ å®Ÿéš›ã®äº‹ä¾‹:**

ã‚ã‚‹SNSã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒGoogleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸï¼š

- âœ… **åŠ¹æœ**: 
  - âœ… æ–°è¦ç™»éŒ²ã®æ‰‹é–“ãŒå‰Šæ¸›
  - ğŸ“ˆ ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ç‡ãŒ30%å‘ä¸Š
  - âœ… `ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰`ç®¡ç†ã®è² æ‹…ãŒè»½æ¸›

**æ•™è¨“:**
- âœ… `OAuth 2.0`ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’å‘ä¸Šã•ã›ã‚‹
- âœ… ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£`èªè¨¼`ã«ã‚ˆã‚Šã€æ–°è¦ç™»éŒ²ã®ãƒãƒ¼ãƒ‰ãƒ«ã‚’ä¸‹ã’ã‚‹
- âœ… `ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£`ã‚’ç¢ºä¿ã—ãªãŒã‚‰ã€åˆ©ä¾¿æ€§ã‚’æä¾›

### ğŸ”„ OAuth 2.0ã®ä»•çµ„ã¿

#### ğŸ”„ 1. OAuth 2.0ã®èªè¨¼ãƒ•ãƒ­ãƒ¼

**ğŸ“‹ èªè¨¼ã‚³ãƒ¼ãƒ‰ãƒ•ãƒ­ãƒ¼ï¼ˆAuthorization Code Flowï¼‰:**

```
1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹
   â†“
2. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒèªè¨¼ã‚µãƒ¼ãƒãƒ¼ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
   â†“
3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒèªè¨¼ã‚µãƒ¼ãƒãƒ¼ã§èªè¨¼
   â†“
4. èªè¨¼ã‚µãƒ¼ãƒãƒ¼ãŒèªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ç™ºè¡Œ
   â†“
5. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«æˆ»ã‚‹ï¼ˆèªè¨¼ã‚³ãƒ¼ãƒ‰ä»˜ãï¼‰
   â†“
6. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒèªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ã«äº¤æ›
   â†“
7. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹
```

**å®Ÿè£…ä¾‹:**

```javascript
// OAuth 2.0èªè¨¼ã‚µãƒ¼ãƒãƒ¼ï¼ˆãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ï¼‰ã®å®Ÿè£…
class OAuth2Provider {
  async authorize(clientId, redirectUri, scope, state) {
    // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’æ¤œè¨¼
    const client = await this.validateClient(clientId, redirectUri);
    
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
    const authCode = this.generateAuthCode();
    
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜
    await db.authCodes.create({
      code: authCode,
      clientId,
      redirectUri,
      scope,
      state,
      expiresAt: new Date(Date.now() + 10 * 60 * 1000),  // 10åˆ†
    });
    
    // èªè¨¼URLã‚’è¿”ã™
    return `${redirectUri}?code=${authCode}&state=${state}`;
  }
  
  async exchangeToken(code, clientId, clientSecret, redirectUri) {
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
    const authCode = await db.authCodes.findOne({
      code,
      clientId,
      redirectUri,
      expiresAt: { $gt: new Date() },
      used: false,
    });
    
    if (!authCode) {
      throw new Error('Invalid or expired authorization code');
    }
    
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨æ¸ˆã¿ã«ã™ã‚‹
    await db.authCodes.update(authCode.id, { used: true });
    
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã¨ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    const accessToken = this.generateAccessToken(authCode);
    const refreshToken = this.generateRefreshToken(authCode);
    
    return {
      access_token: accessToken,
      token_type: 'Bearer',
      expires_in: 3600,  // 1æ™‚é–“
      refresh_token: refreshToken,
      scope: authCode.scope,
    };
  }
  
  async validateToken(accessToken) {
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼
    const token = await db.accessTokens.findOne({
      token: accessToken,
      expiresAt: { $gt: new Date() },
      revoked: false,
    });
    
    if (!token) {
      throw new Error('Invalid or expired access token');
    }
    
    return token;
  }
}
```

#### 2. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã®å®Ÿè£…

**ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã®å®Ÿè£…:**

```javascript
// OAuth 2.0ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®å®Ÿè£…
class OAuth2Client {
  constructor(providerUrl, clientId, clientSecret, redirectUri) {
    this.providerUrl = providerUrl;
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.redirectUri = redirectUri;
  }
  
  async initiateLogin(scope = 'openid profile email') {
    // stateã‚’ç”Ÿæˆï¼ˆCSRFå¯¾ç­–ï¼‰
    const state = this.generateState();
    
    // stateã‚’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ä¿å­˜
    await this.saveState(state);
    
    // èªè¨¼URLã‚’ç”Ÿæˆ
    const authUrl = `${this.providerUrl}/authorize?` +
      `client_id=${this.clientId}&` +
      `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
      `response_type=code&` +
      `scope=${encodeURIComponent(scope)}&` +
      `state=${state}`;
    
    // ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
    window.location.href = authUrl;
  }
  
  async handleCallback(code, state) {
    // stateã‚’æ¤œè¨¼ï¼ˆCSRFå¯¾ç­–ï¼‰
    const storedState = await this.getStoredState();
    if (state !== storedState) {
      throw new Error('Invalid state parameter');
    }
    
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ã«äº¤æ›
    const tokenResponse = await fetch(`${this.providerUrl}/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': `Basic ${btoa(`${this.clientId}:${this.clientSecret}`)}`,
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code,
        redirect_uri: this.redirectUri,
      }),
    });
    
    if (!tokenResponse.ok) {
      throw new Error('Failed to exchange token');
    }
    
    const tokens = await tokenResponse.json();
    
    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
    await this.saveTokens(tokens);
    
    return tokens;
  }
  
  async refreshAccessToken(refreshToken) {
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ›´æ–°
    const tokenResponse = await fetch(`${this.providerUrl}/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': `Basic ${btoa(`${this.clientId}:${this.clientSecret}`)}`,
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
      }),
    });
    
    if (!tokenResponse.ok) {
      throw new Error('Failed to refresh token');
    }
    
    const tokens = await tokenResponse.json();
    
    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ›´æ–°
    await this.updateTokens(tokens);
    
    return tokens;
  }
  
  async getResource(accessToken, resourceUrl) {
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹
    const response = await fetch(resourceUrl, {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
      },
    });
    
    if (!response.ok) {
      if (response.status === 401) {
        // ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœŸé™åˆ‡ã‚Œã®å ´åˆã€ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
        const refreshToken = await this.getRefreshToken();
        const newTokens = await this.refreshAccessToken(refreshToken);
        return await this.getResource(newTokens.access_token, resourceUrl);
      }
      throw new Error('Failed to get resource');
    }
    
    return await response.json();
  }
}
```

### ğŸ”„ OAuth 2.0ã®èªè¨¼ãƒ•ãƒ­ãƒ¼

#### âœ… 1. èªè¨¼ã‚³ãƒ¼ãƒ‰ãƒ•ãƒ­ãƒ¼ï¼ˆæ¨å¥¨ï¼‰

**ğŸ“‹ ç‰¹å¾´:**
- âœ… æœ€ã‚‚å®‰å…¨ãªãƒ•ãƒ­ãƒ¼
- ğŸŒ Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§æ¨å¥¨
- ğŸ”„ `èªè¨¼`ã‚³ãƒ¼ãƒ‰ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ã«äº¤æ›

**ä½¿ç”¨ä¾‹:**

```javascript
// èªè¨¼ã‚³ãƒ¼ãƒ‰ãƒ•ãƒ­ãƒ¼ã®ä½¿ç”¨ä¾‹
const oauthClient = new OAuth2Client(
  'https://oauth.example.com',
  'client-id',
  'client-secret',
  'https://app.example.com/auth/callback'
);

// ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
document.getElementById('login-button').addEventListener('click', () => {
  oauthClient.initiateLogin();
});

// ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
const urlParams = new URLSearchParams(window.location.search);
const code = urlParams.get('code');
const state = urlParams.get('state');

if (code && state) {
  oauthClient.handleCallback(code, state)
    .then(tokens => {
      // ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ
      window.location.href = '/dashboard';
    })
    .catch(error => {
      console.error('Login failed:', error);
    });
}
```

#### ğŸ“‹ 2. ã‚¤ãƒ³ãƒ—ãƒªã‚·ãƒƒãƒˆãƒ•ãƒ­ãƒ¼

**ğŸ“‹ ç‰¹å¾´:**
- âœ… ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ãƒ­ãƒ¼
- ğŸ“± ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒªã‚„SPAã§ä½¿ç”¨
- ğŸ”‘ ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›´æ¥å–å¾—

**å®Ÿè£…ä¾‹:**

```javascript
// ã‚¤ãƒ³ãƒ—ãƒªã‚·ãƒƒãƒˆãƒ•ãƒ­ãƒ¼ã®å®Ÿè£…
class ImplicitFlow {
  async initiateLogin() {
    const state = this.generateState();
    await this.saveState(state);
    
    const authUrl = `${this.providerUrl}/authorize?` +
      `client_id=${this.clientId}&` +
      `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
      `response_type=token&` +
      `scope=openid profile email&` +
      `state=${state}`;
    
    window.location.href = authUrl;
  }
  
  async handleCallback() {
    // URLãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const hash = window.location.hash.substring(1);
    const params = new URLSearchParams(hash);
    
    const accessToken = params.get('access_token');
    const state = params.get('state');
    const expiresIn = params.get('expires_in');
    
    // stateã‚’æ¤œè¨¼
    const storedState = await this.getStoredState();
    if (state !== storedState) {
      throw new Error('Invalid state');
    }
    
    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
    await this.saveTokens({
      access_token: accessToken,
      expires_in: parseInt(expiresIn),
    });
    
    return { access_token: accessToken };
  }
}
```

#### ğŸ“‹ 3. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ãƒ¼

**ğŸ“‹ ç‰¹å¾´:**
- ğŸ–¥ï¸ ã‚µãƒ¼ãƒãƒ¼é–“é€šä¿¡ã§ä½¿ç”¨
- âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼`èªè¨¼`ä¸è¦
- ğŸ” ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³`èªè¨¼`ã®ã¿

**å®Ÿè£…ä¾‹:**

```javascript
// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ãƒ¼ã®å®Ÿè£…
class ClientCredentialsFlow {
  async getAccessToken() {
    const response = await fetch(`${this.providerUrl}/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': `Basic ${btoa(`${this.clientId}:${this.clientSecret}`)}`,
      },
      body: new URLSearchParams({
        grant_type: 'client_credentials',
        scope: 'api:read api:write',
      }),
    });
    
    if (!response.ok) {
      throw new Error('Failed to get access token');
    }
    
    const tokens = await response.json();
    
    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
    await this.saveTokens(tokens);
    
    return tokens;
  }
}
```

### âœ… OAuth 2.0ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

#### ğŸ”’ 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–

**ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã®å®Ÿè£…:**

```javascript
// OAuth 2.0ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã®å®Ÿè£…
class OAuth2Security {
  async validateClient(clientId, redirectUri) {
    // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’æ¤œè¨¼
    const client = await db.clients.findById(clientId);
    
    if (!client) {
      throw new Error('Invalid client ID');
    }
    
    // ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆURIã‚’æ¤œè¨¼
    if (!client.allowedRedirectUris.includes(redirectUri)) {
      throw new Error('Invalid redirect URI');
    }
    
    return client;
  }
  
  async generateState() {
    // CSRFå¯¾ç­–ç”¨ã®stateã‚’ç”Ÿæˆ
    return crypto.randomBytes(32).toString('hex');
  }
  
  async generatePKCE() {
    // PKCEï¼ˆProof Key for Code Exchangeï¼‰ã‚’ç”Ÿæˆ
    const codeVerifier = crypto.randomBytes(32).toString('base64url');
    const codeChallenge = crypto
      .createHash('sha256')
      .update(codeVerifier)
      .digest('base64url');
    
    return {
      codeVerifier,
      codeChallenge,
    };
  }
  
  async validatePKCE(codeVerifier, codeChallenge) {
    // PKCEã‚’æ¤œè¨¼
    const calculatedChallenge = crypto
      .createHash('sha256')
      .update(codeVerifier)
      .digest('base64url');
    
    return calculatedChallenge === codeChallenge;
  }
}
```

#### ğŸ”‘ 2. ãƒˆãƒ¼ã‚¯ãƒ³ã®ç®¡ç†

**ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†ã®å®Ÿè£…:**

```javascript
// OAuth 2.0ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†ã®å®Ÿè£…
class TokenManager {
  async saveTokens(tokens) {
    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æš—å·åŒ–ã—ã¦ä¿å­˜
    const encryptedAccessToken = await this.encrypt(tokens.access_token);
    const encryptedRefreshToken = await this.encrypt(tokens.refresh_token);
    
    await db.tokens.create({
      userId: this.getCurrentUserId(),
      accessToken: encryptedAccessToken,
      refreshToken: encryptedRefreshToken,
      expiresAt: new Date(Date.now() + tokens.expires_in * 1000),
      createdAt: new Date(),
    });
  }
  
  async getAccessToken() {
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const token = await db.tokens.findOne({
      userId: this.getCurrentUserId(),
      expiresAt: { $gt: new Date() },
    });
    
    if (!token) {
      // ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœŸé™åˆ‡ã‚Œã®å ´åˆã€ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
      return await this.refreshToken();
    }
    
    return await this.decrypt(token.accessToken);
  }
  
  async refreshToken() {
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ›´æ–°
    const token = await db.tokens.findOne({
      userId: this.getCurrentUserId(),
    });
    
    if (!token) {
      throw new Error('No refresh token found');
    }
    
    const refreshToken = await this.decrypt(token.refreshToken);
    const newTokens = await oauthClient.refreshAccessToken(refreshToken);
    
    await this.saveTokens(newTokens);
    
    return newTokens.access_token;
  }
}
```

### ğŸ¯ ã¾ã¨ã‚

`OAuth 2.0`ã®ãƒã‚¤ãƒ³ãƒˆï¼š

- âœ… **èªè¨¼ã‚³ãƒ¼ãƒ‰ãƒ•ãƒ­ãƒ¼**: æœ€ã‚‚å®‰å…¨ãªãƒ•ãƒ­ãƒ¼ã€Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§æ¨å¥¨
- âœ… **ã‚¤ãƒ³ãƒ—ãƒªã‚·ãƒƒãƒˆãƒ•ãƒ­ãƒ¼**: ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ãƒ­ãƒ¼ã€ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒªã‚„SPAã§ä½¿ç”¨
- âœ… **ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¯ãƒ¬ãƒ‡ãƒ³ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ãƒ¼**: ã‚µãƒ¼ãƒãƒ¼é–“é€šä¿¡ã§ä½¿ç”¨
- ğŸ”’ **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: stateã€PKCEã€é©åˆ‡ãª`ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†`
- ğŸ”‘ **ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†**: æš—å·åŒ–ã€ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã€é©åˆ‡ãªæœ‰åŠ¹æœŸé™

é©åˆ‡ãª`OAuth 2.0`ã®å®Ÿè£…ã«ã‚ˆã‚Šã€ã‚»ã‚­ãƒ¥ã‚¢ãª`èªè¨¼`ã¨èªå¯ã‚’æä¾›ã§ãã¾ã™ã€‚

