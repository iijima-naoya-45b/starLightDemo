---
title: "頻出ライブラリ"
label: "頻出ライブラリ"
---

## `Django REST Framework` (`DRF`)

`DRF`は、`Django`で`RESTful API`を構築するためのデファクトスタンダードです。シリアライザー、ビューセット、ルーターを組み合わせることで、`CRUD`操作を迅速に実装できます。

### 使用方法

- **インストール**: `pip install djangorestframework`
- **`settings.py`**: `INSTALLED_APPS`に`'rest_framework'`を追加します。
- **モデルとシリアライザーの定義**: モデルとそれを`JSON`に変換する`ModelSerializer`を作成します。
- **ビューセットとルーター**: `viewsets.ModelViewSet`で`CRUD`操作をまとめ、`DefaultRouter`で`URL`を自動生成します。

```python
# myapp/views.py
from rest_framework import viewsets
from .models import MyModel
from .serializers import MyModelSerializer

class MyModelViewSet(viewsets.ModelViewSet):
    queryset = MyModel.objects.all()
    serializer_class = MyModelSerializer

# myproject/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from myapp.views import MyModelViewSet

router = DefaultRouter()
router.register(r'mymodels', MyModelViewSet)

urlpatterns = [
    path('api/', include(router.urls)),
]
```

これにより、`/api/mymodels/`で一覧取得や新規作成、`/api/mymodels/<id>/`で詳細取得や更新、削除が可能になります。

## `Django Debug Toolbar`

開発中にデータベースクエリやパフォーマンスのボトルネックを特定するのに役立つツールです。

### 使用方法

- **インストール**: `pip install django-debug-toolbar`
- **`settings.py`**: `INSTALLED_APPS`に`'debug_toolbar'`を追加し、`MIDDLEWARE`に`'debug_toolbar.middleware.DebugToolbarMiddleware'`を追加します。`INTERNAL_IPS`にローカル`IP`アドレスを設定する必要があります。

```python
# settings.py
INSTALLED_APPS = [
    # ...
    'debug_toolbar',
]
MIDDLEWARE = [
    # ...
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    # ...
]
INTERNAL_IPS = ['127.0.0.1']
```

- **`urls.py`**: 開発環境でのみツールバーを有効にするため、`urls.py`に設定を追加します。

```python
# myproject/urls.py
from django.urls import path, include
if settings.DEBUG:
    import debug_toolbar
    urlpatterns = [
        path('__debug__/', include(debug_toolbar.urls)),
    ] + urlpatterns
```

これで、開発サーバーを起動し、ブラウザでページにアクセスすると画面右側にデバッグパネルが表示されます。

## `Pillow`

`Django`で画像を扱う際の標準ライブラリです。`ImageField`と連携し、画像のアップロードや簡単な加工を可能にします。

### 使用方法

- **インストール**: `pip install Pillow`
- **モデルでの使用**: `ImageField`をモデルに定義します。
- **リサイズ処理**: ビューやモデルの`save`メソッドで、`Pillow`の機能を使って画像をリサイズします。

```python
# myapp/models.py
from django.db import models
from PIL import Image

class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    image = models.ImageField(upload_to='profile_pics')

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        img = Image.open(self.image.path)
        if img.height > 300 or img.width > 300:
            output_size = (300, 300)
            img.thumbnail(output_size)
            img.save(self.image.path)
```

この例では、ユーザーが画像をアップロードするたびに、画像のサイズが300x300ピクセルを超える場合に自動でリサイズされます。

## `django-crispy-forms`

テンプレートでのフォームのレンダリングを簡素化し、`Bootstrap`などの`CSS`フレームワークに準拠した美しいフォームを簡単に作成します。

### 使用方法

- **インストール**: `pip install django-crispy-forms`
- **`settings.py`**: `INSTALLED_APPS`に`'crispy_forms'`を追加します。
- **テンプレートでの使用**: フォームをレンダリングするテンプレートで`{% load crispy_forms_tags %}`を使い、`{{ form|crispy }}`のように記述します。

```html
{% load crispy_forms_tags %}
<form method="post">
    {% csrf_token %}
    {{ form|crispy }}
    <button type="submit">Submit</button>
</form>
```

これにより、`as_p`や`as_table`のようなデフォルトのレンダリングより、はるかに見栄えの良いフォームが自動で生成されます。

## `Celery`

時間のかかるタスクをバックグラウンドで非同期に実行するタスクキューです。`Web`サーバーがリクエストに素早く応答できるようになります。

### 使用方法

- **インストール**: `pip install celery` と、`Redis`や`RabbitMQ`などのブローカーが必要です。
- **`Celery`インスタンスの作成**: `Django`プロジェクト内に`Celery`インスタンスを作成します。
- **タスクの定義**: `@shared_task`デコレーターを使ってタスクを定義します。

```python
# myapp/tasks.py
from celery import shared_task
from django.core.mail import send_mail

@shared_task
def send_welcome_email(user_email):
    send_mail(
        'Welcome to Our App!',
        'Thank you for registering.',
        'from@example.com',
        [user_email],
        fail_silently=False,
    )
```

- **タスクの呼び出し**: ビューやモデルのシグナルからタスクを呼び出します。

```python
# myapp/views.py
from django.shortcuts import render
from .tasks import send_welcome_email

def register_user(request):
    # ... ユーザー登録処理 ...
    user_email = 'user@example.com'
    send_welcome_email.delay(user_email) # 非同期タスクとして実行
    return render(request, 'success.html')
```

`delay()`メソッドを使うことで、タスクがバックグラウンドで実行され、ビューの応答時間をブロックしません。

## `django-allauth`

ソーシャル認証やアカウント管理機能（登録、ログイン、パスワードリセットなど）を簡単に実装します。

### 使用方法

- **インストール**: `pip install django-allauth`
- **`settings.py`**: `INSTALLED_APPS`に`'allauth'`, `'allauth.account'`, `'allauth.socialaccount'`を追加し、認証関連の設定を行います。
- **`urls.py`**: `allauth`の`URL`をインクルードします。

```python
# myproject/urls.py
from django.urls import path, include

urlpatterns = [
    # ...
    path('accounts/', include('allauth.urls')),
    # ...
]
```

これにより、`/accounts/login/`、`/accounts/signup/`などの`URL`が自動で利用可能になります。

## `django-storages`

クラウドストレージ（`Amazon S3`など）にファイルを保存するためのバックエンドを提供します。

### 使用方法

- **インストール**: `pip install django-storages` と、使用するクラウドの`SDK` (`boto3` for `S3`) が必要です。
- **`settings.py`**: `DEFAULT_FILE_STORAGE`を設定し、クラウドストレージの認証情報を記述します。

```python
# settings.py
DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
AWS_STORAGE_BUCKET_NAME = 'your-bucket-name'
AWS_S3_REGION_NAME = 'ap-northeast-1'
# ... その他の認証情報 ...
```

この設定だけで、`Django`の`FileField`や`ImageField`が、ローカルではなく指定された`S3`バケットにファイルを自動でアップロードするようになります。

## `Gunicorn` / `uWSGI`

`Django`アプリケーションを本番環境で実行するための`WSGI`サーバーです。

### 使用方法

- **インストール**: `pip install gunicorn`
- **実行**: プロジェクトのルートディレクトリから以下のコマンドを実行します。

```bash
gunicorn myproject.wsgi:application --bind 0.0.0.0:8000
```

これは、`myproject`ディレクトリ内の`wsgi.py`ファイルにある`application`オブジェクトを使って、`Gunicorn`をポート`8000`で実行する基本的なコマンドです。

## `django-filter`

モデルのデータを`URL`のクエリパラメータに基づいて簡単にフィルタリングできます。

### 使用方法

- **インストール**: `pip install django-filter`
- **`settings.py`**: `INSTALLED_APPS`に`'django_filters'`を追加し、`REST_FRAMEWORK`の設定でバックエンドを有効にします。

```python
# settings.py
INSTALLED_APPS = [
    # ...
    'django_filters',
]
REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend'],
}
```

- **ビューでの使用**: `filterset_fields`をビューに追加するだけでフィルタリングが可能になります。

```python
# myapp/views.py
from rest_framework import viewsets
from .models import MyModel
from .serializers import MyModelSerializer

class MyModelViewSet(viewsets.ModelViewSet):
    queryset = MyModel.objects.all()
    serializer_class = MyModelSerializer
    filterset_fields = ['name', 'created_at'] # このフィールドでフィルタリング可能
```

これにより、`/api/mymodels/?name=test`のような`URL`でデータを絞り込めるようになります。