---
title: "APIモード"
label: "APIモード"
---

## `Django`の`API`モードとは

`Django`には、デフォルトで「`API`モード」という特別な設定があるわけではありません。`Django`を`API`として機能させるためには、**`Django REST Framework`（`DRF`）**のようなライブラリを組み合わせて使用することが一般的です。これにより、ウェブサイトの機能と`API`機能を共存させたり、`API`専用のバックエンドを構築したりすることができます。

### `API`モードの主要コンポーネント

`Django`で`API`を構築する際は、以下の主要なコンポーネントを理解することが重要です。

1. **シリアライザー（`Serializer`）**
   - **シリアライゼーション**: モデルインスタンスを`JSON`形式に変換し、レスポンスとして返す。
   - **デシリアライゼーション**: `JSON`形式のデータを受信し、モデルインスタンスに変換してデータベースに保存する。
   - **バリデーション**: 受信したデータが正しい形式かどうかを検証する。

2. **ビュー（`View`）**
   - **リクエスト処理**: `GET`、`POST`、`PUT`、`DELETE`などの`HTTP`リクエストを処理。
   - **データ取得・保存**: モデルを操作してデータベースからデータを取得したり、保存したりする。
   - **レスポンス生成**: シリアライザーを使ってデータを整形し、レスポンスを返す。

3. **ルーティング（`Routing`）**
   - **`URL`パターンとビューを結びつける。**
   - **エンドポイントを論理的にグループ化する。**

### `API`モードのユースケース

`Django`を`API`として利用する主なユースケースは以下の通りです。

- **`SPA`（`Single Page Application`）のバックエンド**: `React`、`Vue.js`、`Angular`といったフロントエンドフレームワークと連携し、データを提供する`API`サーバーとして機能します。
- **モバイルアプリケーションのバックエンド**: `iOS`や`Android`アプリにデータを供給するための`API`を構築します。
- **マイクロサービス**: 複数のサービスが連携するアーキテクチャにおいて、他のサービスにデータや機能を提供する`API`として利用されます。

これらのコンポーネントを組み合わせることで、`Django`は柔軟かつ強力な`API`バックエンドとして機能し、多様なクライアントからのデータ要求に応えることができます。

ここでは、簡単なブログアプリケーションを想定し、「記事（`Article`）」データを操作する`API`を作成します。

1. **モデルの定義**
   - `API`で扱うデータを定義する`Django`モデルを作成します。

   ```python
   # blog/models.py
   from django.db import models

   class Article(models.Model):
       title = models.CharField(max_length=200)
       content = models.TextField()
       is_published = models.BooleanField(default=False)
       created_at = models.DateTimeField(auto_now_add=True)
       updated_at = models.DateTimeField(auto_now=True)

       def __str__(self):
           return self.title
   ```

2. **シリアライザーの作成**
   - モデルを`JSON`形式に変換するためのシリアライザーを作成します。`ModelSerializer`を使うと、モデルのフィールドを自動的にマッピングしてくれます。

   ```python
   # blog/serializers.py
   from rest_framework import serializers
   from .models import Article

   class ArticleSerializer(serializers.ModelSerializer):
       class Meta:
           model = Article
           fields = ['id', 'title', 'content', 'is_published', 'created_at']
   ```

3. **ビューの作成**
   - `API`のリクエストを処理するビューを作成します。ここでは、`DRF`の汎用ビューを使用し、`CRUD`（作成、読み取り、更新、削除）操作を簡潔に実装します。

   ```python
   # blog/views.py
   from rest_framework import generics
   from .models import Article
   from .serializers import ArticleSerializer

   # 記事のリスト表示と新規作成
   class ArticleListCreateView(generics.ListCreateAPIView):
       queryset = Article.objects.all()
       serializer_class = ArticleSerializer

   # 特定の記事の取得、更新、削除
   class ArticleRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):
       queryset = Article.objects.all()
       serializer_class = ArticleSerializer
   ```

4. **`URL`ルーティングの設定**
   - `API`のエンドポイントを定義します。これにより、特定の`URL`パターンが対応するビューと紐付けられます。

   ```python
   # myproject/urls.py
   from django.urls import path
   from blog.views import ArticleListCreateView, ArticleRetrieveUpdateDestroyView

   urlpatterns = [
       # APIのルートエンドポイント
       path('api/articles/', ArticleListCreateView.as_view(), name='article-list'),
       # IDを指定して特定の記事を操作するエンドポイント
       path('api/articles/<int:pk>/', ArticleRetrieveUpdateDestroyView.as_view(), name='article-detail'),
   ]
   ```

このコードをデプロイすると、以下の`API`エンドポイントが利用可能になります。

```bash
- **GET /api/articles/**: すべての記事をリストで取得します。
- **POST /api/articles/**: 新しい記事を作成します。
- **GET /api/articles/<id>/**: 特定の記事を取得します。
- **PUT /api/articles/<id>/**: 特定の記事を更新します。
- **DELETE /api/articles/<id>/**: 特定の記事を削除します。
```

`DRF`のブラウザブル`API`機能のおかげで、これらのエンドポイントにウェブブラウザから直接アクセスし、簡単に動作を確認できます。

### `Django`における`API`開発：`Django REST Framework` (`DRF`) の活用

`Django`自体には「`API`モード」という特別な設定はありません。`Django`を`API`バックエンドとして機能させるためには、**`Django REST Framework` (`DRF`)**のようなライブラリを統合して使用するのが一般的です。`DRF`は、`Web`サイトの機能と`API`機能を共存させたり、`API`専用のバックエンドを構築したりする際に非常に強力なツールとなります。

1. **`API`開発の主要コンポーネント**
   - `Django`で`API`を構築する際は、以下の3つの主要なコンポーネントが相互に連携します。

   - **シリアライザー**: `Django`モデルのインスタンス（`Python`オブジェクト）と、`API`で扱う`JSON`などのデータ形式との間で変換を行います。これにより、データのバリデーション（検証）と整形を効率的に行えます。

   - **ビュー**: `API`リクエストを処理し、シリアライザーを使ってレスポンスを生成します。`DRF`の汎用ビューは、一般的な`CRUD`（作成、読み取り、更新、削除）操作を簡単に実装できるように設計されています。

   - **ルーティング**: 特定の`URL`と、そのリクエストを処理するビューを結びつけます。これにより、`API`のエンドポイントを整理し、論理的な`URL`構造を設計できます。

2. **具体的な実装例：ブログ`API`の構築**
   - 簡単なブログアプリケーションを想定し、「記事（`Article`）」データを操作する`API`を作成する手順は以下の通りです。

   - **モデルとシリアライザーの定義**
     - `API`で扱うデータの構造を`Article`モデルで定義し、そのデータを`JSON`に変換するための`ArticleSerializer`を作成します。

     ```python
     # blog/models.py
     from django.db import models
     class Article(models.Model):
         # ... モデルの定義 ...

     # blog/serializers.py
     from rest_framework import serializers
     from .models import Article
     class ArticleSerializer(serializers.ModelSerializer):
         class Meta:
             model = Article
             fields = ['id', 'title', 'content', 'is_published', 'created_at']
     ```

   - **ビューと`URL`の設定（手動での方法）**
     - `DRF`の汎用ビューを使って、記事の一覧/作成 (`ArticleListCreateView`) と、詳細/更新/削除 (`ArticleRetrieveUpdateDestroyView`) の2つのビューを定義します。その後、`urls.py`でそれぞれのビューに`URL`を割り当てます。

     ```python
     # blog/views.py
     from rest_framework import generics
     from .models import Article
     from .serializers import ArticleSerializer

     class ArticleListCreateView(generics.ListCreateAPIView):
         queryset = Article.objects.all()
         serializer_class = ArticleSerializer

     class ArticleRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):
         queryset = Article.objects.all()
         serializer_class = ArticleSerializer

     # myproject/urls.py
     from django.urls import path
     from blog.views import ArticleListCreateView, ArticleRetrieveUpdateDestroyView
     urlpatterns = [
         path('api/articles/', ArticleListCreateView.as_view()),
         path('api/articles/<int:pk>/', ArticleRetrieveUpdateDestroyView.as_view()),
     ]
     ```

     この方法では、`CRUD`操作ごとに異なるビューを定義し、それぞれに`URL`を設定する必要があります。

3. **ビューセットとルーターによる開発の簡素化**
   - 上記の手動設定は、ビューセットとルーターを使用することで大幅に簡素化できます。

   - **ビューセット**: 複数の`API`エンドポイント（一覧表示、詳細表示、作成、更新、削除など）のロジックを一つのクラスにまとめます。`ModelViewSet`は、`CRUD`操作をすべて自動で提供するため、最もよく使われます。

   - **ルーター**: ビューセットを自動的に分析し、対応する`URL`を自動生成します。

   - **ビューセットとルーターを使った実装**
     - `ArticleViewSet`という単一のビューセットクラスを定義し、これを`DRF`のルーターに登録するだけで、複数の`URL`が自動生成されます。

     ```python
     # blog/views.py
     from rest_framework import viewsets
     from .models import Article
     from .serializers import ArticleSerializer

     # ModelViewSetは、CRUD操作をすべて自動で提供
     class ArticleViewSet(viewsets.ModelViewSet):
         queryset = Article.objects.all()
         serializer_class = ArticleSerializer

     # myproject/urls.py
     from django.urls import path, include
     from rest_framework.routers import DefaultRouter
     from blog.views import ArticleViewSet

     # ルーターをインスタンス化
     router = DefaultRouter()
     # ビューセットをルーターに登録
     router.register(r'articles', ArticleViewSet)

     urlpatterns = [
         # ルーターが生成したURLをインクルード
         path('api/', include(router.urls)),
     ]
     ```

     この設定だけで、`GET /api/articles/`、`POST /api/articles/`、`GET /api/articles/<pk>/`、`PUT /api/articles/<pk>/`、`DELETE /api/articles/<pk>/`といったすべての`CRUD`エンドポイントが自動的に利用可能になります。

ビューセットとルーターの組み合わせは、`DRF`の強力な機能の一つであり、`API`開発を劇的に効率化します。これにより、開発者はよりビジネスロジックに集中できるようになります。