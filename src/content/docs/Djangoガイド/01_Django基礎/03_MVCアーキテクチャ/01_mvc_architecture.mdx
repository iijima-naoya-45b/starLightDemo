---
title: "MVCアーキテクチャ"
label: "MVCアーキテクチャ"
---

# `MVC`アーキテクチャ

`MVC`アーキテクチャは、ウェブアプリケーションを`Model`、`View`、`Controller`の3つの独立したコンポーネントに分割する設計パターンです。これにより、各コンポーネントが単一の役割に集中し、コードの管理や再利用が容易になります。

### なぜMVCアーキテクチャが必要なのか

#### 問題のあるコード（MVCがない場合）

**問題のあるコード:**

```python
# 問題: すべてのロジックが1つのファイルに混在
# views.py
from django.http import HttpResponse
import json

def handle_request(request):
    # HTTP処理
    user_id = request.GET.get('id')
    
    # データベース操作
    from django.db import connection
    with connection.cursor() as cursor:
        cursor.execute("SELECT * FROM users WHERE id = %s", [user_id])
        user = cursor.fetchone()
    
    # ビジネスロジック
    if user and user[3] < 18:  # age
        status = 'minor'
    else:
        status = 'adult'
    
    # HTML生成
    html = f"<html><body><h1>{user[1]}</h1><p>Status: {status}</p></body></html>"
    return HttpResponse(html)

# 問題点:
# 1. テストが困難（HTTP、DB、ビジネスロジックが混在）
# 2. 再利用性が低い（他のビューで同じロジックを使えない）
# 3. 責務が不明確（どこを変更すべきか分からない）
# 4. チーム開発が困難（デザイナーとエンジニアが競合する）
```

**解決: MVCパターン**

```python
# Model: データとビジネスロジック
# models.py
class User(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField()
    
    def is_minor(self):
        return self.age < 18
    
    def get_status(self):
        return 'minor' if self.is_minor() else 'adult'

# View: HTTPリクエストの処理
# views.py
def user_detail(request, user_id):
    user = User.objects.get(id=user_id)
    return render(request, 'users/detail.html', {'user': user})

# Template: HTMLの生成
# templates/users/detail.html
<h1>{{ user.name }}</h1>
<p>Status: {{ user.get_status }}</p>

# メリット:
# 1. 各コンポーネントを独立してテスト可能
# 2. ビジネスロジックの再利用が容易
# 3. 責務が明確（変更箇所が明確）
# 4. チーム開発が容易（デザイナーとエンジニアが並行作業可能）
```

- **`Model`**: アプリケーションのデータ構造とビジネスロジックを定義します。
- **`View`**: ユーザーに表示されるユーザーインターフェースを担当します。
- **`Controller`**: ユーザーからのリクエストを受け付け、モデルとビューを連携させます。

## `Django`の`MTV`アーキテクチャ

`Django`は、一般的な`MVC`に似た**`MTV`（`Model-Template-View`）**アーキテクチャを採用しています。これは、ウェブアプリケーションのコンポーネントを3つの明確な役割に分離することで、コードの管理や再利用を容易にする設計パターンです。

- **`Model`（モデル）**: データベースのテーブルに対応し、データの`CRUD`操作とビジネスロジックを定義します。
- **`Template`（テンプレート）**: ユーザーに表示されるユーザーインターフェースを担当します。`HTML`や`CSS`などで構成され、ビューから渡されたデータを動的に埋め込みます。
- **`View`（ビュー）**: ユーザーからのリクエストを受け付け、ビジネスロジックを実行し、モデルと連携してデータを取得します。その後、データをテンプレートに渡し、レスポンスを生成してユーザーに返します。

## `MVC`と`MTV`の違い

一般的な`MVC`の「`Controller`」にあたる部分が、`Django`では「`View`」と「`URL`ディスパッチャ」によって分担されています。`Django`の`View`はビジネスロジックとデータベースとのやり取りを扱い、`URL`ディスパッチャはリクエストを適切なビューにルーティングする役割を担います。これにより、各コンポーネントの役割がより明確になります。

## `Django`の`MTV`アーキテクチャの主なメリット

- **役割の明確化と分離**: 各コンポーネントが特定の役割に集中するため、開発者は担当部分に専念でき、コードの重複を防ぎ、可読性を高めます。
- **協業の促進**: 役割が明確に分かれているため、バックエンド開発者とフロントエンド開発者が並行して作業を進めやすくなります。
- **再利用性の向上**: 各コンポーネントが独立しているため、コードの再利用性が高まり、メンテナンスが容易になります。
- **拡張性とメンテナンス性**: コンポーネントが独立しているため、大規模なプロジェクトでも拡張しやすく、問題が発生した場合の原因特定が容易になります。

## サンプルコード（`Django MTV`）

簡単なブログアプリケーションを例に、`Django`の`Model`, `Template`, `View`の連携を見てみましょう。

### `Model` (`models.py`)

```python
# blog/models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title
```

### `View` (`views.py`)

```python
# blog/views.py
from django.shortcuts import render
from .models import Post

def post_list(request):
    posts = Post.objects.all().order_by('-created_at')
    context = {'posts': posts}
    return render(request, 'blog/post_list.html', context)
```

### `Template` (`post_list.html`)

```html
<!DOCTYPE html>
<html>
<head>
    <title>ブログ記事一覧</title>
</head>
<body>
    <h1>最新のブログ記事</h1>
    {% for post in posts %}
        <article>
            <h2>{{ post.title }}</h2>
            <p>{{ post.content }}</p>
            <small>公開日: {{ post.created_at }}</small>
        </article>
        <hr>
    {% endfor %}
</body>
</html>
```

## `Django MTV`と`React`の連携

`Vue.js`や`React`のようなモダンなフロントエンドフレームワークを使用する場合、`Django`は主にバックエンドとして機能し、この連携は`API`ファーストのアーキテクチャと呼ばれます。

- **`Django`（バックエンド）の役割**: データの管理と`API`の提供に特化します。ビューは`HTML`テンプレートを返す代わりに、`JSON`形式のデータを返します。
- **`React`（フロントエンド）の役割**: `Django`から提供された`JSON`データを基に、動的な`UI`を構築します。ユーザーの操作は`API`を通じて`Django`に送られます。

### サンプルコード（`Django + React`）

#### `Django`の`API View`

```python
# blog/views.py (Django REST Framework)
from rest_framework import generics
from .models import Post
from .serializers import PostSerializer

class PostListAPIView(generics.ListAPIView):
    queryset = Post.objects.all().order_by('-created_at')
    serializer_class = PostSerializer
```

#### `React`のコンポーネント

```javascript
// PostList.js (React)
import React, { useState, useEffect } from 'react';

const PostList = () => {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    // Django APIからデータを取得
    fetch('http://localhost:8000/api/posts/')
      .then(response => response.json())
      .then(data => setPosts(data));
  }, []);

  return (
    <div>
      <h1>最新のブログ記事</h1>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.content}</p>
          <small>公開日: {post.created_at}</small>
        </article>
      ))}
    </div>
  );
};

export default PostList;
```

このモデルでは、`Django`はデータソースとなり、`React`がプレゼンテーション層を完全に担当します。この分業により、それぞれの専門領域に集中した開発が可能になります。

### Django MTVの実践的なユースケース

#### ユースケース1: ECサイトの注文処理

```python
# Model: ビジネスロジック
# models.py
class Order(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    total_amount = models.DecimalField(max_digits=10, decimal_places=2)
    status = models.CharField(max_length=20, default='pending')
    created_at = models.DateTimeField(auto_now_add=True)
    
    def calculate_total(self):
        return self.order_items.aggregate(
            total=Sum(F('price') * F('quantity'))
        )['total'] or 0
    
    def can_cancel(self):
        return self.status == 'pending' and \
               (timezone.now() - self.created_at).days < 1
    
    def apply_discount(self, discount_code):
        discount = Discount.objects.filter(code=discount_code).first()
        if discount and discount.is_valid():
            self.total_amount *= (1 - discount.rate)
            self.save()

# View: HTTPリクエストの処理
# views.py
class OrderCreateView(CreateView):
    model = Order
    form_class = OrderForm
    
    def form_valid(self, form):
        order = form.save(commit=False)
        order.user = self.request.user
        order.total_amount = order.calculate_total()
        
        # 割引コードの適用
        discount_code = self.request.POST.get('discount_code')
        if discount_code:
            order.apply_discount(discount_code)
        
        order.save()
        return redirect('order_detail', pk=order.pk)

# Template: HTMLの生成
# templates/orders/detail.html
<h1>Order #{{ order.id }}</h1>
<p>Total: ${{ order.total_amount }}</p>
<p>Status: {{ order.status }}</p>

{% if order.can_cancel %}
    <a href="{% url 'order_cancel' order.pk %}">Cancel Order</a>
{% endif %}
```

#### ユースケース2: ユーザー認証システム

```python
# Model: 認証ロジック
# models.py
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    email = models.EmailField(unique=True)
    is_email_verified = models.BooleanField(default=False)
    
    def generate_verification_token(self):
        return default_token_generator.make_token(self)
    
    def verify_token(self, token):
        return default_token_generator.check_token(self, token)

# View: 認証処理
# views.py
class UserRegistrationView(CreateView):
    model = User
    form_class = UserRegistrationForm
    template_name = 'users/register.html'
    
    def form_valid(self, form):
        user = form.save()
        # メール送信
        send_verification_email(user)
        return redirect('registration_success')

class EmailVerificationView(View):
    def get(self, request, user_id, token):
        user = User.objects.get(id=user_id)
        if user.verify_token(token):
            user.is_email_verified = True
            user.save()
            return redirect('verification_success')
        return redirect('verification_failed')
```

### Django MTVのアンチパターン

#### アンチパターン1: Fat View（太ったビュー）

**問題のあるコード:**

```python
# 問題: Viewにビジネスロジックが集中
def create_order(request):
    if request.method == 'POST':
        # 問題: バリデーションロジックがViewにある
        if not request.POST.get('user_id'):
            return HttpResponse('User ID is required', status=400)
        
        # 問題: ビジネスロジックがViewにある
        total = 0
        for item_data in request.POST.getlist('items'):
            product = Product.objects.get(id=item_data['product_id'])
            total += product.price * item_data['quantity']
            
            if product.stock < item_data['quantity']:
                return HttpResponse('Insufficient stock', status=400)
        
        # 問題: データベース操作がViewにある
        order = Order.objects.create(
            user_id=request.POST['user_id'],
            total_amount=total
        )
        
        # 問題: メール送信ロジックがViewにある
        send_order_confirmation(order)
        
        return redirect('order_detail', order.id)
    
    return render(request, 'orders/create.html')

# 解決: ビジネスロジックをModelに移動
class Order(models.Model):
    # ... フィールド定義
    
    def calculate_total(self):
        return self.order_items.aggregate(
            total=Sum(F('price') * F('quantity'))
        )['total'] or 0
    
    def validate_stock(self):
        for item in self.order_items.all():
            if item.product.stock < item.quantity:
                raise ValidationError(f'Insufficient stock for {item.product.name}')
    
    def send_confirmation_email(self):
        send_order_confirmation(self)

# Viewはシンプルに
def create_order(request):
    if request.method == 'POST':
        form = OrderForm(request.POST)
        if form.is_valid():
            order = form.save()
            try:
                order.validate_stock()
                order.send_confirmation_email()
                return redirect('order_detail', order.id)
            except ValidationError as e:
                form.add_error(None, e)
    else:
        form = OrderForm()
    return render(request, 'orders/create.html', {'form': form})
```

#### アンチパターン2: Fat Model（太ったモデル）

**問題のあるコード:**

```python
# 問題: ModelにViewロジックが含まれている
class User(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()
    
    def get_display_name(self):
        # 問題: ViewロジックがModelにある
        return f"{self.name} ({self.email})"
    
    def format_created_at(self):
        # 問題: フォーマットロジックがModelにある
        return self.created_at.strftime("%Y年%m月%d日")

# 解決: ViewロジックはTemplateまたはTemplateタグに移動
# templates/users/detail.html
<h1>{{ user.name }} ({{ user.email }})</h1>
<p>Created: {{ user.created_at|date:"Y年m月d日" }}</p>

# または、Templateタグを使用
# templatetags/user_tags.py
@register.filter
def display_name(user):
    return f"{user.name} ({user.email})"
```

### Django MTV vs クリーンアーキテクチャ

**Django MTVが適している場合:**

```python
# 適用範囲:
# - 中規模から大規模のWebアプリケーション
# - CRUD操作が中心のアプリケーション
# - Djangoの標準パターンに従いたい場合

# 構造
View → Model → Database
```

**クリーンアーキテクチャが適している場合:**

```python
# 適用範囲:
# - 複雑なビジネスロジックを持つアプリケーション
# - 複数の外部システムとの統合が必要
# - 長期的な保守性を最優先する場合

# 構造
View → Use Case → Domain → Repository → Database
```

**判断基準:**

| 観点 | Django MTV | クリーンアーキテクチャ |
|------|-----------|---------------------|
| **学習コスト** | 低い | 高い |
| **開発速度** | 高い | 中程度 |
| **Djangoとの親和性** | 非常に高い | 中程度 |
| **ビジネスロジックの表現力** | 中程度 | 高い |
| **適用範囲** | 中規模 | 大規模 |

### まとめ

DjangoのMTVアーキテクチャは、Webアプリケーション開発において明確な責務分離を実現する重要な設計パターンです。

**シニアエンジニアとして考慮すべき点:**

1. **プロジェクト規模に応じた選択**: 中規模ならMTV、大規模ならクリーンアーキテクチャを検討
2. **責務の明確化**: 各レイヤーの責務を明確にし、混在を避ける
3. **テスト容易性**: 各レイヤーを独立してテストできるように設計
4. **段階的な改善**: 既存のコードベースに段階的にパターンを適用