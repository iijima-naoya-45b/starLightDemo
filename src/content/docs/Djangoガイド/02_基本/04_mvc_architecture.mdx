---
title: "MVCアーキテクチャ"
label: "MVCアーキテクチャ"
---

# `MVC`アーキテクチャ

`MVC`アーキテクチャは、ウェブアプリケーションを`Model`、`View`、`Controller`の3つの独立したコンポーネントに分割する設計パターンです。これにより、各コンポーネントが単一の役割に集中し、コードの管理や再利用が容易になります。

- **`Model`**: アプリケーションのデータ構造とビジネスロジックを定義します。
- **`View`**: ユーザーに表示されるユーザーインターフェースを担当します。
- **`Controller`**: ユーザーからのリクエストを受け付け、モデルとビューを連携させます。

## `Django`の`MTV`アーキテクチャ

`Django`は、一般的な`MVC`に似た**`MTV`（`Model-Template-View`）**アーキテクチャを採用しています。これは、ウェブアプリケーションのコンポーネントを3つの明確な役割に分離することで、コードの管理や再利用を容易にする設計パターンです。

- **`Model`（モデル）**: データベースのテーブルに対応し、データの`CRUD`操作とビジネスロジックを定義します。
- **`Template`（テンプレート）**: ユーザーに表示されるユーザーインターフェースを担当します。`HTML`や`CSS`などで構成され、ビューから渡されたデータを動的に埋め込みます。
- **`View`（ビュー）**: ユーザーからのリクエストを受け付け、ビジネスロジックを実行し、モデルと連携してデータを取得します。その後、データをテンプレートに渡し、レスポンスを生成してユーザーに返します。

## `MVC`と`MTV`の違い

一般的な`MVC`の「`Controller`」にあたる部分が、`Django`では「`View`」と「`URL`ディスパッチャ」によって分担されています。`Django`の`View`はビジネスロジックとデータベースとのやり取りを扱い、`URL`ディスパッチャはリクエストを適切なビューにルーティングする役割を担います。これにより、各コンポーネントの役割がより明確になります。

## `Django`の`MTV`アーキテクチャの主なメリット

- **役割の明確化と分離**: 各コンポーネントが特定の役割に集中するため、開発者は担当部分に専念でき、コードの重複を防ぎ、可読性を高めます。
- **協業の促進**: 役割が明確に分かれているため、バックエンド開発者とフロントエンド開発者が並行して作業を進めやすくなります。
- **再利用性の向上**: 各コンポーネントが独立しているため、コードの再利用性が高まり、メンテナンスが容易になります。
- **拡張性とメンテナンス性**: コンポーネントが独立しているため、大規模なプロジェクトでも拡張しやすく、問題が発生した場合の原因特定が容易になります。

## サンプルコード（`Django MTV`）

簡単なブログアプリケーションを例に、`Django`の`Model`, `Template`, `View`の連携を見てみましょう。

### `Model` (`models.py`)

```python
# blog/models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title
```

### `View` (`views.py`)

```python
# blog/views.py
from django.shortcuts import render
from .models import Post

def post_list(request):
    posts = Post.objects.all().order_by('-created_at')
    context = {'posts': posts}
    return render(request, 'blog/post_list.html', context)
```

### `Template` (`post_list.html`)

```html
<!DOCTYPE html>
<html>
<head>
    <title>ブログ記事一覧</title>
</head>
<body>
    <h1>最新のブログ記事</h1>
    {% for post in posts %}
        <article>
            <h2>{{ post.title }}</h2>
            <p>{{ post.content }}</p>
            <small>公開日: {{ post.created_at }}</small>
        </article>
        <hr>
    {% endfor %}
</body>
</html>
```

## `Django MTV`と`React`の連携

`Vue.js`や`React`のようなモダンなフロントエンドフレームワークを使用する場合、`Django`は主にバックエンドとして機能し、この連携は`API`ファーストのアーキテクチャと呼ばれます。

- **`Django`（バックエンド）の役割**: データの管理と`API`の提供に特化します。ビューは`HTML`テンプレートを返す代わりに、`JSON`形式のデータを返します。
- **`React`（フロントエンド）の役割**: `Django`から提供された`JSON`データを基に、動的な`UI`を構築します。ユーザーの操作は`API`を通じて`Django`に送られます。

### サンプルコード（`Django + React`）

#### `Django`の`API View`

```python
# blog/views.py (Django REST Framework)
from rest_framework import generics
from .models import Post
from .serializers import PostSerializer

class PostListAPIView(generics.ListAPIView):
    queryset = Post.objects.all().order_by('-created_at')
    serializer_class = PostSerializer
```

#### `React`のコンポーネント

```javascript
// PostList.js (React)
import React, { useState, useEffect } from 'react';

const PostList = () => {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    // Django APIからデータを取得
    fetch('http://localhost:8000/api/posts/')
      .then(response => response.json())
      .then(data => setPosts(data));
  }, []);

  return (
    <div>
      <h1>最新のブログ記事</h1>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.content}</p>
          <small>公開日: {post.created_at}</small>
        </article>
      ))}
    </div>
  );
};

export default PostList;
```

このモデルでは、`Django`はデータソースとなり、`React`がプレゼンテーション層を完全に担当します。この分業により、それぞれの専門領域に集中した開発が可能になります。