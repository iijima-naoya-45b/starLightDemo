---
title: "Goの基本構文"
label: "Goの基本構文"
---

## `Go`の基本構文 🧩

`Go`はシンプルで、読み書きしやすい構文を持つことが特徴です。以下にその主要な要素をまとめます。

### 1. パッケージとインポート 📦

`Go`のプログラムはすべてパッケージに属します。実行可能なプログラムの起点となるのは特別なパッケージ`main`です。

- `package main`: プログラムが実行可能であることを示します。
- `import`: 他のパッケージの機能を利用するために使います。

```go
package main

import (
    "fmt"  // I/Oフォーマットを提供
    "math" // 数学関数を提供
)
```

### 2. 関数 ⚙️

関数は`func`キーワードで定義し、引数と戻り値の型を明示します。

- `func main()`: プログラムのエントリーポイントです。
- 複数の戻り値: `Go`の関数は複数の値を返すことができ、エラーハンドリングに広く使われます。

```go
// 戻り値がない関数
func sayHello() {
    fmt.Println("Hello!")
}

// 複数の戻り値がある関数
func swap(x, y string) (string, string) {
    return y, x
}
```

### 3. 変数と定数 ✍️

- `var`: 変数を宣言します。型を明示するか、コンパイラに推論させることができます。
- `:=`: 関数内でのみ使える簡潔な変数宣言と初期化の方法です。
- `const`: コンパイル時に値が確定する定数を宣言します。

```go
var name string = "Alice"
age := 30
const PI = 3.14
```

### 4. 複合データ型 📝

`Go`のデータ型は静的で、コンパイル時にチェックされます。

- 配列 (`Array`): 固定長のデータ型です。サイズは型の一部となります。
- スライス (`Slice`): 可変長のデータ型で、内部的には配列を参照します。メモリ効率が良く、ほとんどの`Go`プログラムで使われます。
- マップ (`Map`): キーと値のペアを格納するデータ型です。
- 構造体 (`Struct`): 異なる型のデータをまとめて一つの単位として扱うための複合型です。他の言語のクラスに似ています。

```go
// 配列の例 (固定長)
var a [2]string
a[0] = "Hello"
a[1] = "World"
fmt.Println(a[0], a[1]) // Hello World

// スライスの例 (可変長)
s := []int{1, 2, 3}
s = append(s, 4, 5) // 要素の追加
fmt.Println(s) // [1 2 3 4 5]

// マップの例
m := make(map[string]int)
m["Apple"] = 100
m["Banana"] = 200
fmt.Println(m["Apple"]) // 100

// 構造体の例
type Person struct {
    Name string
    Age  int
}
p := Person{Name: "Bob", Age: 25}
fmt.Println(p.Name) // Bob
```

### 5. 制御構造 🔁

`Go`の制御構造は非常にシンプルです。

- `if`: 条件分岐に使います。括弧`()`は不要ですが、中括弧`{}`は必須です。
- `for`: `Go`には`while`文がなく、すべてのループは`for`文で記述します。
- `switch`: 複数の条件を簡潔に記述でき、明示的な`break`は不要です。

```go
// if/elseの例
if 7%2 == 0 {
    fmt.Println("7 is even")
} else {
    fmt.Println("7 is odd") // 実行される
}

// forループの例
sum := 0
for i := 1; i <= 10; i++ {
    sum += i
}
fmt.Println(sum) // 55

// switchの例
i := 2
switch i {
case 1:
    fmt.Println("one")
case 2:
    fmt.Println("two") // 実行される
case 3:
    fmt.Println("three")
}
```

### 6. ポインタ 📍

`Go`はポインタをサポートしますが、`C`言語とは異なり、算術演算はできません。

- `&`: 変数のメモリアドレスを取得します。
- `*`: ポインタが指す先の値にアクセスします。

```go
// ポインタの例
i := 10
p := &i       // iのメモリアドレスをポインタpに代入
fmt.Println(*p) // pが指す値（10）を出力
*p = 20       // pが指すiの値を20に変更
fmt.Println(i)  // 20
```

### 7. 並行処理の基本 🧵

`Go`の並行処理は言語レベルで組み込まれています。

- `Goroutine`: 軽量なスレッドで、`go`キーワードを使って関数を非同期で実行します。
- `Channel`: 複数の`Goroutine`間で安全にデータをやり取りするためのパイプです。`Go`の設計思想である「通信によってメモリを共有する」を実現します。

```go
import (
    "fmt"
    "time"
)

// Goroutineの例
func say(s string) {
    for i := 0; i < 2; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    go say("world") // バックグラウンドで実行
    say("hello")     // メインのゴルーチンで実行

    // Channelの例
    messages := make(chan string)
    go func() { messages <- "ping" }() // 別ゴルーチンでチャネルに値を送信
    msg := <-messages // メインゴルーチンでチャネルから値を受信
    fmt.Println(msg)  // ping
}
```

ご提示いただいた`Go`の基本構文は、非常に簡潔で分かりやすくまとめられています。`Go`言語の特徴であるシンプルさと実用性がよく伝わってきます。パッケージ、関数、変数といった基本的な要素から、スライス、マップ、構造体といった複合型、そして`Go`の最大の強みである並行処理まで、主要な概念を網羅しています。

このガイドに加えて、さらに`Go`の理解を深めるために、以下のトピックを追加で補足することをおすすめします。

### 8. エラーハンドリング 🚨

`Go`には例外処理の機構がありません。代わりに、関数が複数の戻り値を返す機能を利用し、慣例として最後の戻り値で`error`型を返します。このシンプルで明示的な方法は、エラーを無視することを防ぎ、堅牢なアプリケーションの構築を促します。

#### 使用例

エラーハンドリングを伴う関数呼び出しの例です。

```go
package main

import (
    "fmt"
    "strconv" // 文字列と数値の変換を提供
)

func main() {
    // 文字列を数値に変換する関数
    i, err := strconv.Atoi("42")
    if err != nil {
        // エラーが発生した場合
        fmt.Println("文字列を数値に変換できませんでした:", err)
        return
    }
    // エラーがnil（存在しない）の場合
    fmt.Println("変換された数値:", i) // 変換された数値: 42
}
```

この構文は、`Go`のコード全体で頻繁に見られます。エラーをチェックして適切に処理することが、`Go`プログラミングの基本です。

### 9. インターフェース 🤝

`Go`のインターフェースは、他の言語のように明示的な実装宣言が不要な、ユニークな特徴を持っています。ある構造体がインターフェースのすべてのメソッドを実装していれば、自動的にそのインターフェースを満たすと見なされます。この「ダックタイピング」の考え方は、`Go`の柔軟性と再利用性を高めます。

#### 使用例

`Shaper`インターフェースを定義し、`Circle`と`Rectangle`構造体がこれを満たす例です。

```go
package main

import "fmt"

// `Shaper`インターフェースは`Area()`メソッドを持つ
type Shaper interface {
    Area() float64
}

// `Circle`は`Shaper`インターフェースを満たす
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}

// `Rectangle`も`Shaper`インターフェースを満たす
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func main() {
    c := Circle{Radius: 5}
    r := Rectangle{Width: 3, Height: 4}

    // インターフェースの変数を宣言
    var s Shaper

    s = c
    fmt.Println("円の面積:", s.Area())

    s = r
    fmt.Println("長方形の面積:", s.Area())
}
```

このように、インターフェースを使うことで、異なる型を持つオブジェクトを共通の振る舞いを通じて扱うことができます。

### 10. レシーバとメソッド ✍️

構造体に関連付けられた関数をメソッドと呼びます。メソッドは、`func`キーワードと関数名の間にレシーバを記述することで定義します。

- 値レシーバ: レシーバのコピーに対して操作を行います。元の値は変更されません。
- ポインタレシーバ: レシーバのポインタ（メモリアドレス）に対して操作を行います。元の値を直接変更できます。

#### 使用例

`Wallet`構造体と、値レシーバおよびポインタレシーバを持つメソッドの例です。

```go
package main

import "fmt"

type Wallet struct {
    Balance int
}

// 値レシーバ: ウォレットの残高を返す
func (w Wallet) GetBalance() int {
    return w.Balance
}

// ポインタレシーバ: ウォレットの残高を直接変更
func (w *Wallet) Deposit(amount int) {
    w.Balance += amount
}

func main() {
    myWallet := Wallet{Balance: 100}

    // 値レシーバの呼び出し
    fmt.Println("現在の残高:", myWallet.GetBalance()) // 100

    // ポインタレシーバの呼び出し
    myWallet.Deposit(50)
    fmt.Println("預金後の残高:", myWallet.GetBalance()) // 150 (値が変更されている)
}
```

これらの要素は、`Go`でより複雑なアプリケーションを構築する上で不可欠な概念です。特にエラーハンドリングは、`Go`のコーディングスタイルを特徴づける重要な部分であり、必ず押さえておくべきトピックです。