---
title: "RESTful API設計"
label: "RESTful API設計"
---

## 🌐 RESTful API設計

`RESTful API`の設計原則とベストプラクティスを説明します。`RESTful API`は、Webアプリケーションや`マイクロサービス`間の通信において、標準的な設計パターンとして広く採用されています。

### 🎯 なぜRESTful APIが必要なのか

#### 📚 RESTful APIが生まれた背景

`RESTful API`は、2000年にRoy Fieldingによって提唱された`REST`（Representational State Transfer）アーキテクチャスタイルに基づいています。当時、Webアプリケーションの開発において、以下のような問題がありました：

**従来のAPI設計の問題:**
- ❌ **統一性の欠如**: 各開発者が独自の`API`設計を行い、統一性がなかった
- ❌ **複雑性**: `SOAP`などの複雑なプロトコルが使用され、実装が困難だった
- ❌ **スケーラビリティ**: 複雑な設計により、`スケーラビリティ`が確保できなかった
- ❌ **保守性**: `API`の変更時に、影響範囲が分からなかった

**RESTful APIの解決:**
`RESTful API`は、`HTTP`の標準的な機能を活用し、シンプルで統一された`API`設計を実現しました。これにより、以下のようなメリットが生まれました：

- ✅ **統一性**: 統一された設計原則により、どの`API`も同じように理解できる
- ✅ **シンプルさ**: `HTTP`の標準的な機能を活用し、実装が容易
- ✅ **スケーラビリティ**: ステートレスな設計により、`スケーラビリティ`が確保できる
- ✅ **保守性**: リソースベースの設計により、変更が容易

#### 問題のあるAPI設計が引き起こす実際の事例

**事例1: 命名規則の不統一による問題**

あるECサイトで、APIの命名規則が統一されていませんでした：

```javascript
// 開発者Aが作成したAPI
GET /getUser?id=1
POST /saveUser

// 開発者Bが作成したAPI
GET /user/fetch?id=1
POST /user/create

// 開発者Cが作成したAPI
GET /api/users/get?id=1
POST /api/users/add
```

**発生した問題:**
- フロントエンド開発者が、どのAPIを呼び出せばいいか分からない
- 同じ機能を実現するAPIが複数存在し、どれを使えばいいか分からない
- APIの仕様を確認するために、各開発者に問い合わせる必要がある
- バグ修正時に、どのAPIに影響があるか分からない

**結果:**
- 開発速度が40%低下
- バグが3倍に増加
- フロントエンドとバックエンドの連携に時間がかかる

**RESTful APIによる解決:**
統一されたRESTful API設計を実施した結果：
- 開発速度が30%向上
- バグが60%減少
- APIの仕様が明確になり、開発効率が向上

**事例2: HTTPメソッドの不適切な使用による問題**

あるSNSアプリケーションで、すべての操作にPOSTメソッドを使用していました：

```javascript
// すべてPOSTメソッドを使用
POST /getUser
POST /getAllUsers
POST /updateUser
POST /deleteUser
```

**発生した問題:**
- HTTPキャッシュが効かない（GETメソッドを使用していないため）
- ブラウザの戻るボタンが正しく動作しない
- セキュリティの問題（GETリクエストとPOSTリクエストの区別ができない）
- ログの分析が困難（すべてPOSTリクエストのため）

**結果:**
- パフォーマンスが30%低下
- セキュリティホールが発生
- ログの分析に時間がかかる

**RESTful APIによる解決:**
適切なHTTPメソッドを使用した結果：
- パフォーマンスが20%向上
- セキュリティが向上
- ログの分析が容易になる

#### 問題のあるAPI設計

**問題のあるAPI:**

```javascript
// 統一されていないAPI
GET /getUser?id=1
POST /saveUser
GET /getAllUsers
POST /updateUser?id=1
DELETE /removeUser?id=1
// 問題点:
// - 命名規則が統一されていない
// - HTTPメソッドの使い方が不適切
// - リソースの概念がない
// - ステータスコードが適切でない
```

**RESTful APIの解決:**

```javascript
// RESTful API
GET    /api/v1/users/1        // ユーザー取得
POST   /api/v1/users         // ユーザー作成
GET    /api/v1/users         // ユーザー一覧取得
PUT    /api/v1/users/1       // ユーザー更新
DELETE /api/v1/users/1       // ユーザー削除
// メリット:
// - 統一された命名規則
// - HTTPメソッドの適切な使用
// - リソースベースの設計
// - 適切なステータスコード
```

**メリット:**
1. **統一性**: 一貫したAPI設計
   - すべてのAPIが同じ設計原則に従う
   - フロントエンド開発者が、APIの使い方を推測できる
   - 新しい開発者でも、すぐに理解できる

2. **理解しやすさ**: 直感的な設計
   - HTTPメソッドとURLで、操作が明確になる
   - リソースベースの設計により、直感的に理解できる
   - ドキュメントがなくても、ある程度理解できる

3. **保守性**: 変更が容易
   - リソースベースの設計により、変更が容易
   - バージョン管理により、後方互換性を保てる
   - 影響範囲が明確になる

4. **拡張性**: 機能追加が容易
   - 新しいリソースを追加するだけで、機能を追加できる
   - 既存のAPIへの影響が少ない
   - マイクロサービス化が容易

### RESTful APIの原則

RESTful APIは、以下の原則に従って設計されます。これらの原則は、APIの品質と保守性を確保するために重要です。

#### 1. リソースベースの設計

**なぜリソースベースの設計が重要なのか:**

リソースベースの設計は、RESTful APIの核心となる原則です。リソースを名詞で表現することで、以下のようなメリットが生まれます：

- **直感性**: URLを見るだけで、何のリソースを操作しているか分かる
- **一貫性**: すべてのAPIが同じパターンに従う
- **拡張性**: 新しいリソースを追加するだけで、機能を追加できる

**リソースベースの設計が不適切な場合の問題:**

動詞を含むURLを使用すると、以下のような問題が発生します：

- **一貫性の欠如**: 各開発者が異なる動詞を使用し、統一性がなくなる
- **拡張性の低下**: 新しい操作を追加する際に、新しいURLを作成する必要がある
- **理解の困難**: URLから操作内容を推測しにくくなる

**リソースは名詞で表現:**

```javascript
// 良い例
GET /api/v1/users
GET /api/v1/products
GET /api/v1/orders

// 悪い例
GET /api/v1/getUsers
GET /api/v1/getProducts
GET /api/v1/getOrders
```

#### 2. HTTPメソッドの適切な使用

**なぜHTTPメソッドの適切な使用が重要なのか:**

HTTPメソッドは、リソースに対する操作の種類を表現します。適切なHTTPメソッドを使用することで、以下のようなメリットが生まれます：

- **セマンティクス**: HTTPメソッドにより、操作の意味が明確になる
- **キャッシング**: GETメソッドを使用することで、HTTPキャッシュが効く
- **冪等性**: 適切なHTTPメソッドにより、冪等性が保証される
- **セキュリティ**: HTTPメソッドにより、適切なセキュリティ対策を実施できる

**HTTPメソッドの不適切な使用による問題:**

すべての操作にPOSTメソッドを使用すると、以下のような問題が発生します：

- **キャッシングの非効率**: GETメソッドを使用していないため、HTTPキャッシュが効かない
- **セキュリティの問題**: GETリクエストとPOSTリクエストの区別ができない
- **ログの分析の困難**: すべてPOSTリクエストのため、ログの分析が困難
- **ブラウザの動作**: ブラウザの戻るボタンが正しく動作しない

**HTTPメソッドの意味:**

- **GET**: リソースの取得（冪等性あり）
- **POST**: リソースの作成（冪等性なし）
- **PUT**: リソースの更新または作成（冪等性あり）
- **PATCH**: リソースの部分更新（冪等性なし）
- **DELETE**: リソースの削除（冪等性あり）

**実践例:**

```javascript
// ユーザーリソース
GET    /api/v1/users        // ユーザー一覧取得
GET    /api/v1/users/1      // ユーザー取得
POST   /api/v1/users        // ユーザー作成
PUT    /api/v1/users/1      // ユーザー更新（全体）
PATCH  /api/v1/users/1       // ユーザー更新（部分）
DELETE /api/v1/users/1      // ユーザー削除
```

#### 3. ステータスコードの適切な使用

**なぜステータスコードの適切な使用が重要なのか:**

ステータスコードは、リクエストの結果を表現します。適切なステータスコードを使用することで、以下のようなメリットが生まれます：

- **エラーハンドリング**: クライアント側で、適切なエラーハンドリングができる
- **デバッグ**: ステータスコードにより、問題の原因を特定しやすくなる
- **監視**: ステータスコードにより、APIの健全性を監視できる
- **標準準拠**: HTTP標準に準拠することで、既存のツールやライブラリが使用できる

**ステータスコードの不適切な使用による問題:**

すべてのレスポンスに200 OKを返すと、以下のような問題が発生します：

- **エラーハンドリングの困難**: クライアント側で、エラーを適切に処理できない
- **デバッグの困難**: エラーの原因を特定しにくくなる
- **監視の困難**: APIの健全性を監視できない
- **標準違反**: HTTP標準に違反し、既存のツールやライブラリが使用できない

**よく使うステータスコード:**

- **200 OK**: 成功
- **201 Created**: 作成成功
- **204 No Content**: 成功（レスポンスボディなし）
- **400 Bad Request**: リクエストが不正
- **401 Unauthorized**: 認証が必要
- **403 Forbidden**: 権限がない
- **404 Not Found**: リソースが見つからない
- **409 Conflict**: 競合
- **500 Internal Server Error**: サーバーエラー

**実践例:**

```javascript
// 成功レスポンス
GET /api/v1/users/1
→ 200 OK
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com"
}

// 作成成功
POST /api/v1/users
→ 201 Created
{
  "id": 2,
  "name": "Jane Doe",
  "email": "jane@example.com"
}

// 削除成功
DELETE /api/v1/users/1
→ 204 No Content

// エラーレスポンス
GET /api/v1/users/999
→ 404 Not Found
{
  "error": {
    "code": "NOT_FOUND",
    "message": "User not found"
  }
}
```

### API設計のベストプラクティス

#### 1. バージョン管理

**URLにバージョンを含める:**

```javascript
// 良い例
/api/v1/users
/api/v2/users

// 悪い例
/api/users  // バージョンがない
```

#### 2. エラーハンドリング

**❌ 問題のある実装:**

```typescript
// ❌ details が any 型で、型安全性が失われる
interface ErrorResponse {
  error: {
    code: string;
    message: string;
    details?: any; // ❌ 最悪のマサカリポイント
  };
}

// フロントエンド側で、422エラーをRHFのsetErrorにマッピングしたいが、
// details の型が不明なため、unknown洗浄の苦労が発生する
```

**🪓 コードレビューでの指摘文例:**

```
【指摘】エラーハンドリングに型がありません。
【問題】ErrorResponse の details が any 型になっています。
       フロントエンドは 422（ValidationError）を RHF の setError にマッピングしたいため、
       details を { field: string, message: string }[] のような厳密な構造で定義し、
       ドキュメント化（OpenAPI）すべきです。
【影響】フロントエンド側で unknown 洗浄の苦労が発生する
【推奨】details を厳密な型で定義し、OpenAPI Spec に記載
```

**✅ 改善された実装:**

```typescript
// ✅ 厳密な型定義
interface ValidationErrorDetail {
  field: string;
  message: string;
}

interface ErrorResponse {
  error: {
    code: string;
    message: string;
    details?: ValidationErrorDetail[]; // ✅ 厳密な型
  };
}

// OpenAPI Spec での定義
// openapi.yaml
components:
  schemas:
    ValidationErrorDetail:
      type: object
      required:
        - field
        - message
      properties:
        field:
          type: string
        message:
          type: string
    ErrorResponse:
      type: object
      required:
        - error
      properties:
        error:
          type: object
          required:
            - code
            - message
          properties:
            code:
              type: string
            message:
              type: string
            details:
              type: array
              items:
                $ref: '#/components/schemas/ValidationErrorDetail'

// フロントエンド側での使用
// ✅ 型安全にエラーを処理できる
try {
  await updateUser(id, formData);
} catch (error) {
  if (error instanceof ValidationErrorResponse) {
    error.error.details?.forEach((detail) => {
      // ✅ detail.field と detail.message が型安全に使用できる
      setError(detail.field, { message: detail.message });
    });
  }
}
```

#### 3. ページネーション

**❌ 問題のある実装:**

```typescript
// ❌ フロントエンドが知りたい情報が不足している
interface PaginationResponse<T> {
  data: T[]; // ❌ items や results の方が一般的
  pagination: {
    page: 1,
    limit: 20,
    total: 100, // ✅ これはある
    totalPages: 5
  };
}

// フロントエンドが知りたい情報:
// - 次のページがあるか（hasNextPage）
// - 前のページがあるか（hasPreviousPage）
// - 現在のページに何件あるか（currentCount）
```

**🪓 コードレビューでの指摘文例:**

```
【指摘】ページネーションのレスポンスが不親切です。
【問題】ページネーションにおいてフロントエンドが一番知りたいのは
       「現在のページに何件あるか」ではなく、「次のページがあるか（hasNextPage）」
       や 「トータルの件数」 です。
【影響】フロントエンド側で「次のページ」ボタンの表示/非表示を判定できない
【推奨】data ではなく items や results というキーに統一し、
       メタ情報として totalCount を必ず含めるべきです。
```

**✅ 改善された実装:**

```typescript
// ✅ フロントエンドが知りたい情報を含む
interface PaginationResponse<T> {
  items: T[]; // ✅ data ではなく items に統一
  pagination: {
    page: number;
    limit: number;
    totalCount: number; // ✅ トータル件数（必須）
    totalPages: number;
    hasNextPage: boolean; // ✅ 次のページがあるか
    hasPreviousPage: boolean; // ✅ 前のページがあるか
    currentCount: number; // ✅ 現在のページの件数
  };
}

// 実装例
app.get('/api/v1/users', async (req, res) => {
  const page = Number(req.query.page) || 1;
  const limit = Number(req.query.limit) || 20;
  const offset = (page - 1) * limit;
  
  const [users, totalCount] = await Promise.all([
    User.findAll({ limit, offset }),
    User.count(),
  ]);
  
  const totalPages = Math.ceil(totalCount / limit);
  
  res.json({
    items: users, // ✅ items に統一
    pagination: {
      page,
      limit,
      totalCount, // ✅ 必須
      totalPages,
      hasNextPage: page < totalPages, // ✅ 次のページがあるか
      hasPreviousPage: page > 1, // ✅ 前のページがあるか
      currentCount: users.length, // ✅ 現在のページの件数
    },
  });
});

// フロントエンド側での使用
const { items, pagination } = await fetchUsers();
// ✅ 次のページボタンの表示/非表示を判定できる
{pagination.hasNextPage && <button>次のページ</button>}
```

#### 4. フィルタリングとソート

**フィルタリングとソート:**

```javascript
// フィルタリング
GET /api/v1/users?status=active&role=admin

// ソート
GET /api/v1/users?sort=name&order=asc

// 検索
GET /api/v1/users?search=john
```

#### 5. ネストされたリソース

**ネストされたリソース:**

```javascript
// ユーザーの注文
GET /api/v1/users/1/orders

// 注文の商品
GET /api/v1/orders/1/items
```

#### 6. レスポンスの命名規則（Snake Case vs Camel Case）

**❌ 問題のある実装:**

```typescript
// ❌ DBのカラム名をそのままレスポンスに流している
app.get('/api/v1/users', async (req, res) => {
  const users = await User.findAll(); // DBが first_name ならレスポンスも first_name
  res.json(users); // ❌ { id: 1, first_name: "John", last_name: "Doe" }
});

// フロントエンドのDTO層への負担が重くなる
// src/types/user.ts
export function userApiToDto(apiUser: UserApiResponse): User {
  return {
    id: apiUser.id,
    firstName: apiUser.first_name, // 毎回変換が必要
    lastName: apiUser.last_name,
    // ...
  };
}
```

**🪓 コードレビューでの指摘文例:**

```
【指摘】Snake Case と Camel Case の不都合な真実があります。
【問題】バックエンドが DB のカラム名をそのまま req.body や res.json に流しています。
       これではフロントエンドの DTO 層への負担が重くなります。
【影響】フロントエンド側で毎回 snake_case → camelCase の変換が必要
【推奨】バックエンド側で「レスポンスを Camel Case に統一するシリアライザー」を導入するか、
       最初から DTO パターンを適用すべきです。
```

**✅ 改善された実装:**

```typescript
// ✅ バックエンド側でCamel Caseに統一するシリアライザーを導入
// src/serializers/userSerializer.ts
export function serializeUser(user: UserModel): UserResponse {
  return {
    id: user.id,
    firstName: user.first_name, // ✅ バックエンド側で変換
    lastName: user.last_name,
    email: user.email,
    createdAt: user.created_at,
  };
}

// 使用例
app.get('/api/v1/users', async (req, res) => {
  const users = await User.findAll();
  const serializedUsers = users.map(serializeUser); // ✅ シリアライザーで変換
  res.json(serializedUsers); // ✅ { id: 1, firstName: "John", lastName: "Doe" }
});

// フロントエンド側の負担が軽減される
// src/types/user.ts
export function userApiToDto(apiUser: UserApiResponse): User {
  return {
    id: apiUser.id,
    firstName: apiUser.firstName, // ✅ 既にcamelCaseなので変換不要
    lastName: apiUser.lastName,
    // ...
  };
}
```

#### 7. PUT と PATCH の使い分け

**❌ 問題のある実装:**

```typescript
// ❌ PUT も PATCH も内部で findByIdAndUpdate を呼んでいて、挙動が同じ
app.put('/api/v1/users/:id', async (req, res) => {
  const user = await User.findByIdAndUpdate(req.params.id, req.body, { new: true });
  res.json(user);
});

app.patch('/api/v1/users/:id', async (req, res) => {
  const user = await User.findByIdAndUpdate(req.params.id, req.body, { new: true });
  res.json(user);
});

// フロントエンド側が混乱する
// 「どっちを呼べばいいの？」
```

**🪓 コードレビューでの指摘文例:**

```
【指摘】PUT と PATCH の使い分けが名ばかりです。
【問題】REST の定義では、PUT は「リソースの完全置換」であり、
       送られなかったフィールドは null やデフォルト値で上書きされるべきです。
       実際には PATCH だけあれば十分なケースが多いです。
【影響】中途半端に両方用意して挙動が同じだと、
       フロントエンド側が「どっちを呼べばいいの？」と混乱します。
【推奨】「このプロジェクトでは PATCH に統一する」という意思決定の方が価値があります。
```

**✅ 改善された実装:**

```typescript
// ✅ PATCH に統一（部分更新のみ）
app.patch('/api/v1/users/:id', async (req, res) => {
  // ✅ 部分更新のみをサポート
  const user = await User.findByIdAndUpdate(
    req.params.id,
    { $set: req.body }, // ✅ 送られたフィールドのみ更新
    { new: true }
  );
  res.json(user);
});

// ✅ PUT は削除するか、完全置換として実装
// 完全置換が必要な場合は、明示的に実装
app.put('/api/v1/users/:id', async (req, res) => {
  // ✅ 完全置換: 送られなかったフィールドはデフォルト値で上書き
  const defaultValues = {
    firstName: '',
    lastName: '',
    email: '',
    // ...
  };
  const user = await User.findByIdAndUpdate(
    req.params.id,
    { ...defaultValues, ...req.body }, // ✅ 完全置換
    { new: true }
  );
  res.json(user);
});

// 推奨: PATCH のみを使用
// PUT エンドポイントは削除し、PATCH に統一する
```

### 実践例: 完全なAPI設計

```javascript
// ユーザーAPI
GET    /api/v1/users              // ユーザー一覧
GET    /api/v1/users/:id          // ユーザー取得
POST   /api/v1/users              // ユーザー作成
PUT    /api/v1/users/:id          // ユーザー更新
DELETE /api/v1/users/:id          // ユーザー削除

// 注文API
GET    /api/v1/users/:id/orders   // ユーザーの注文一覧
GET    /api/v1/orders/:id        // 注文取得
POST   /api/v1/orders             // 注文作成
PUT    /api/v1/orders/:id        // 注文更新
DELETE /api/v1/orders/:id        // 注文削除

// 商品API
GET    /api/v1/products           // 商品一覧
GET    /api/v1/products/:id       // 商品取得
POST   /api/v1/products           // 商品作成
PUT    /api/v1/products/:id       // 商品更新
DELETE /api/v1/products/:id       // 商品削除
```

### まとめ

RESTful API設計のポイント：

- **リソースベース**: 名詞でリソースを表現
- **HTTPメソッド**: 適切なHTTPメソッドを使用（PUTとPATCHの使い分けに注意）
- **ステータスコード**: 適切なステータスコードを返す
- **バージョン管理**: URLにバージョンを含める
- **エラーハンドリング**: 統一されたエラーレスポンス（型安全な構造を定義）
- **ページネーション**: 大量データのページネーション（hasNextPage、totalCountを含める）
- **フィルタリング**: フィルタリングとソート機能
- **命名規則**: レスポンスをCamel Caseに統一するシリアライザーを導入

#### バックエンドAPI設計で注意すべきポイント

1. **Snake Case と Camel Case**: DBのカラム名をそのままレスポンスに流さず、バックエンド側でCamel Caseに統一するシリアライザーを導入する
2. **PUT と PATCH**: 中途半端に両方用意せず、PATCHに統一するか、PUTは完全置換として明示的に実装する
3. **エラーハンドリングの型**: `details?: any` ではなく、`{ field: string, message: string }[]` のような厳密な構造を定義し、OpenAPI Specに記載する
4. **ページネーション**: `data`ではなく`items`に統一し、`hasNextPage`、`totalCount`などのメタ情報を含める

RESTful API設計により、統一性があり、保守しやすいAPIを構築できます。

