---
title: "よくあるアンチパターン"
label: "よくあるアンチパターン"
---

## よくあるアンチパターン

Reactでよくあるアンチパターンと、実際に事故った構造を詳しく解説します。

### A. メモリリーク

#### 実際に事故った構造

```typescript
// ❌ アンチパターン: メモリリーク
function Component() {
  const [data, setData] = useState<any[]>([]);
  
  useEffect(() => {
    // 問題: イベントリスナーが削除されない
    const handleResize = () => {
      setData(prev => [...prev, { timestamp: Date.now() }]);
    };
    
    window.addEventListener('resize', handleResize);
    // 問題: クリーンアップ関数がない
  }, []);
  
  return <div>Component</div>;
}
```

**なぜ事故るか:**

1. **イベントリスナーのリーク**: イベントリスナーが削除されず、メモリリークが発生
2. **参照の保持**: クロージャーで参照が保持され、ガベージコレクションが動作しない
3. **ブラウザのクラッシュ**: メモリ使用量が増加し、ブラウザがクラッシュ

**設計レビューでの指摘文例:**

```
【指摘】メモリリークが発生しています。
【問題】イベントリスナーが削除されず、メモリリークが発生しています。
【影響】メモリ使用量の増加、ブラウザのクラッシュ
【推奨】useEffectのクリーンアップ関数でイベントリスナーを削除する
```

### B. 不要な再レンダリング

#### 実際に事故った構造

```typescript
// ❌ アンチパターン: 不要な再レンダリング
function Component({ items }: { items: Item[] }) {
  // 問題: 毎回新しい配列が作成される
  const filteredItems = items.filter(item => item.active);
  
  // 問題: 毎回新しい関数が作成される
  const handleClick = (id: number) => {
    console.log('Clicked:', id);
  };
  
  return (
    <div>
      {filteredItems.map(item => (
        <ChildComponent key={item.id} item={item} onClick={handleClick} />
      ))}
    </div>
  );
}

// 問題: メモ化されていない
function ChildComponent({ item, onClick }: { item: Item; onClick: (id: number) => void }) {
  return <div onClick={() => onClick(item.id)}>{item.text}</div>;
}
```

**なぜ事故るか:**

1. **再レンダリングの増加**: 親コンポーネントが再レンダリングされるたびに、子コンポーネントも再レンダリング
2. **メモリ使用量の増加**: 再レンダリングが増加し、メモリ使用量が増加
3. **パフォーマンスの低下**: レンダリングパフォーマンスが低下

### C. 大量のDOMノード

#### 実際に事故った構造

```typescript
// ❌ アンチパターン: 大量のDOMノード
function Component() {
  const [items, setItems] = useState<Item[]>([]);
  
  useEffect(() => {
    // 問題: 10,000件のデータを一度に取得
    fetch('/api/items')
      .then(res => res.json())
      .then(json => setItems(json));
  }, []);
  
  return (
    <div>
      {items.map(item => (
        <div key={item.id}>{item.text}</div>
      ))}
    </div>
  );
}
```

**なぜ事故るか:**

1. **DOMノード数の増加**: 10,000個のDOMノードが作成される
2. **レンダリングパフォーマンスの低下**: DOMノード数が増加すると、レンダリングパフォーマンスが低下
3. **メモリ使用量の増加**: DOMノードはメモリを消費する

**設計レビューでの指摘文例:**

```
【指摘】DOMノード数が過剰です。
【問題】10,000件のデータを一度にレンダリングしています。
【影響】レンダリングパフォーマンスの低下、メモリ使用量の増加
【推奨】仮想スクロールを使用してDOMノード数を制限する
```

### D. 無限ループ

#### 実際に事故った構造

```typescript
// ❌ アンチパターン: 無限ループ
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // 問題: 依存配列にcountが含まれていない
    setCount(count + 1);
    // 問題: countが変更されるたびにuseEffectが実行され、無限ループが発生
  });
  
  return <div>{count}</div>;
}
```

**なぜ事故るか:**

1. **無限ループ**: useEffectが無限に実行され、無限ループが発生
2. **メモリ使用量の増加**: 無限ループにより、メモリ使用量が増加
3. **ブラウザのクラッシュ**: 無限ループにより、ブラウザがクラッシュ

**設計レビューでの指摘文例:**

```
【指摘】無限ループが発生しています。
【問題】useEffectの依存配列が適切に設定されていません。
【影響】無限ループ、メモリ使用量の増加、ブラウザのクラッシュ
【推奨】依存配列を適切に設定する
```

### まとめ

よくあるアンチパターンのポイント：

- **A. メモリリーク**: イベントリスナーが削除されない → ブラウザのクラッシュ
- **B. 不要な再レンダリング**: メモ化されていない → パフォーマンスの低下
- **C. 大量のDOMノード**: 大量のデータを一度にレンダリング → レンダリングパフォーマンスの低下
- **D. 無限ループ**: useEffectの依存配列が適切に設定されていない → ブラウザのクラッシュ

これらのアンチパターンを避けることで、安全で信頼性の高いReactアプリケーションを構築できます。

**重要な原則**: 「正常に動く」よりも「異常時に安全に壊れる」ことを優先する。

