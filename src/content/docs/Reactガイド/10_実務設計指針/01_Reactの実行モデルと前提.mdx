---
title: "Reactの実行モデルと前提"
label: "Reactの実行モデルと前提"
---

## Reactの実行モデルと前提

Reactの実行モデルと、実務で事故を防ぐための前提条件を詳しく解説します。

### 実行モデルとリソースの物理的制約

Reactはクライアントサイドで実行されるため、**ブラウザのリソース制約を考慮する**必要があります。

#### 主な物理的制約

**ブラウザ環境:**

1. **ブラウザメモリ（ヒープメモリ）**
   - モバイルデバイス: 通常512MB〜2GB
   - デスクトップ: 通常2GB〜4GB
   - メモリリークは数時間後にブラウザがクラッシュする

2. **DOMノード数**
   - ブラウザの制限: 通常10,000〜100,000ノード
   - 大量のDOMノードはレンダリングパフォーマンスを低下させる

3. **イベントリスナー**
   - 削除されないイベントリスナーはメモリリークの原因
   - クロージャーで参照が保持される

4. **再レンダリング**
   - 不要な再レンダリングはパフォーマンスを低下させる
   - メモリ使用量が増加する
   - 仮想DOMの差分計算にもコストがかかる

**実際の事故例:**

```
10:00:00 - アプリケーション起動（メモリ使用量: 50MB）
10:00:01 - コンポーネント1レンダリング（メモリ使用量: 100MB）
10:00:02 - コンポーネント2レンダリング（メモリ使用量: 150MB）
...
10:30:00 - コンポーネント100レンダリング（メモリ使用量: 2GB）
10:30:01 - ブラウザがクラッシュ
10:30:02 - ユーザー体験の大幅な低下
```

### Reactの実行モデル

#### コンポーネントライフサイクル

**実行モデル:**

```
Reactコンポーネント
├─ マウント（Mount）
│  ├─ constructor
│  ├─ render
│  └─ componentDidMount
├─ 更新（Update）
│  ├─ render
│  └─ componentDidUpdate
└─ アンマウント（Unmount）
   └─ componentWillUnmount
```

**重要な特徴:**

1. **仮想DOM**: 実際のDOMの代わりに仮想DOMを使用
2. **再レンダリング**: 状態が変更されると再レンダリング
3. **ライフサイクル**: コンポーネントのライフサイクルに合わせて処理を実行
4. **フック**: 関数コンポーネントで状態管理とライフサイクルを管理

#### クライアントサイドでの実行

**制約:**

```typescript
// ❌ 悪い例: クライアントサイドで問題のあるコード
function Component() {
  const [data, setData] = useState<any[]>([]);
  
  useEffect(() => {
    // 問題: 大量のデータをメモリに保持
    fetch('/api/large-data')
      .then(res => res.json())
      .then(json => setData(json));
  }, []);
  
  return (
    <div>
      {data.map(item => (
        <div key={item.id}>{item.text}</div>
      ))}
    </div>
  );
}
```

**問題点:**

- **メモリ制限**: ブラウザのメモリ制限により、大量のデータを保持できない
- **DOMノード数の増加**: 大量のDOMノードが作成され、レンダリングパフォーマンスが低下
- **再レンダリング**: 状態が変更されるたびに再レンダリングが発生

### 実行環境による特性

| 環境 | 特徴 | 主なリスク |
|------|------|------------|
| **ブラウザ** | クライアントサイド実行 | メモリリーク、DOMノード数の増加、イベントリスナーのリーク、不要な再レンダリング |

### まとめ

Reactの実行モデルと前提のポイント：

- **リソースの物理的制約**: ブラウザメモリ・DOMノード数・イベントリスナー・再レンダリングの制約を考慮
- **コンポーネントライフサイクル**: マウント・更新・アンマウントのライフサイクルを理解
- **クライアントサイド**: メモリ制限、DOMノード数の増加、不要な再レンダリング

**重要な原則**: 性能ではなく制約を前提に設計する。リソースの垂れ流しは数時間後にブラウザがクラッシュする。

