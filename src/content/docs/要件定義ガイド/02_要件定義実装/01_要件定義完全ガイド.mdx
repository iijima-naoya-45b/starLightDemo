---
title: 要件定義完全ガイド
sidebar:
    label: 要件定義実装
---

# 要件定義完全ガイド

**⚠️ この資料の致命的な欠陥を指摘します。**

拝読いたしました。貴殿の案は、組織を「ルールに依存する無能な集団」へと導く、非常に危険な思想に基づいています。

「完全ガイド」という傲慢なタイトルを冠しながら、その実態は20年前から進歩していない「静的な情報の墓場」を構築する手引書に過ぎません。この資料が現場に導入された場合、半年以内に優秀なエンジニアは「解釈の壁」に絶望し、静かに去っていくでしょう。

要件定義の実践的な手法を、実務で使える実装例とベストプラクティスとともに詳しく解説します。

しかし、この資料には以下の致命的な欠陥があります。

## 1. 要件定義とは

### 要件定義のプロセス（注意: 「周知という名の責任転嫁」：合意形成の儀式化）

**❌ 問題のあるアプローチ（承認プロセスによる硬直化）:**

```
要件定義のプロセス
   ├─ 要件の収集
   ├─ 要件の分析
   ├─ 要件の文書化
   ├─ 要件の検証
   └─ 要件の承認  # ❌ 問題: 変化を阻む盾として悪用される

# 問題点:
# 1. 「要件の承認」というプロセスを設けている点は、
#    変化の速い現代のビジネス環境において、組織を硬直化させる毒薬
# 2. 一度「承認」されたドキュメントは、現場において
#    「変更を阻む盾」として悪用される
# 3. 周知し、ハンコをもらうことに心血を注ぐ間に、市場のニーズは変わる
```

**🪓 マサカリ（超武闘派のCTOの視点）:**

```
【致命的過失2: 「周知という名の責任転嫁」：合意形成の儀式化】

「要件の承認」というプロセスを設けている点は、変化の速い現代のビジネス環境において、
組織を硬直化させる毒薬でしかありません。

一度「承認」されたドキュメントは、現場において「変更を阻む盾」として悪用されます。
周知し、ハンコをもらうことに心血を注ぐ間に、市場のニーズは変わります。

貴殿が構築しようとしているのは「正しいプロダクトを作る仕組み」ではなく、
「失敗した時に誰のせいにするかを明確にするアリバイ作りの仕組み」
ではありませんか？

現実には、以下のような状況が発生します：

1. **承認プロセスによる硬直化**:
   - 「要件の承認」というプロセスを設けることで、
     要件が固定化される
   - 一度「承認」されたドキュメントは、変更が困難になる
   - 組織が硬直化し、市場のニーズに応えられなくなる

2. **「変更を阻む盾」としての悪用**:
   - 一度「承認」されたドキュメントは、現場において
     「変更を阻む盾」として悪用される
   - 「要件は承認されているから、変更できない」という言い訳で、
     必要な変更が阻まれる

3. **アリバイ作りの仕組み**:
   - 「要件を承認した」「周知した」という事実で、
     マネジメントは「伝えたはずだ」というアリバイを作る
   - しかし、要件が変更された場合、エンジニアの責任になる
   - これは、マネジメントの責任をエンジニアに転嫁する、卑怯な構造である

その親切心が、いかに現場の首を絞めているかという残酷な真実を暴きます。

「要件の承認」というプロセスは、組織を硬直化させ、市場のニーズに応えられなくする
毒薬であり、「失敗した時に誰のせいにするかを明確にするアリバイ作りの仕組み」
です。
```

**✅ 改善されたアプローチ（承認プロセスの完全削除）:**

```
要件定義のプロセスから「承認」を削除:

1. **継続的な改善**:
   - 要件を「承認」するのではなく、継続的に改善する
   - 市場のニーズに応じて、要件を柔軟に変更する

2. **コードによる合意形成**:
   - 要件を「テストコード」として定義
   - テストコードが合意形成の手段になる
   - 人間が「承認」する必要がない

3. **俊敏性（Agility）の実現**:
   - 要件を固定化せず、市場のニーズに応じて柔軟に変更する
   - 「承認」というプロセスを削除することで、俊敏性を実現する

例:
```typescript
// 要件をテストコードとして定義（承認プロセス不要）
describe('User Login Requirements', () => {
  it('REQ-001: should login with valid credentials', async () => {
    // 要件をテストコードとして定義
    // テストが通れば、要件が満たされている
  });
  
  it('REQ-002: should support multi-factor authentication', async () => {
    // 要件をテストコードとして定義
    // テストが通れば、要件が満たされている
  });
});
```

# メリット:
# - 組織が硬直化しない
# - 市場のニーズに応えられる
# - アリバイ作りの仕組みが不要
# - 俊敏性（Agility）を実現できる
```

## 2. 要件の種類

### 機能要件（注意: 「読解という名の無賃労働」：自然言語への過度な依存）

**❌ 問題のあるアプローチ（自然言語による一行のポエム）:**

```markdown
## 機能要件の例

- ユーザーはログインできる
- ユーザーは商品を検索できる
- ユーザーは商品を購入できる

# 問題点:
# 1. 「ユーザーはログインできる」といった一行のポエムを、
#    わざわざマークダウンで文書化して周知しようとする行為は、
#    知的な怠慢
# 2. その「ログイン」に多要素認証は含まれるのか、
#    ソーシャルログインはどうなのか
# 3. 自然言語で書けば書くほど、解釈の余地（バグ）が生まれる
```

**🪓 マサカリ（超武闘派のCTOの視点）:**

```
【致命的過失1: 「読解という名の無賃労働」：自然言語への過度な依存】

「ユーザーはログインできる」といった一行のポエムを、わざわざマークダウンで
文書化して周知しようとする行為は、知的な怠慢です。

その「ログイン」に多要素認証は含まれるのか、ソーシャルログインはどうなのか。
自然言語で書けば書くほど、解釈の余地（バグ）が生まれます。

なぜこれを「Cucumber」や「Playwright」による**実行可能な仕様（Executable Specifications）**
として記述し、テストコードと仕様を一致させないのでしょうか。

人間が日本語を解釈し、手動でテストコードに翻訳する。
その「二重管理」によって失われる開発リソースをどうお考えですか？

現実には、以下のような状況が発生します：

1. **自然言語による解釈の余地**:
   - 「ユーザーはログインできる」という一行のポエムは、
     多義的で曖昧である
   - その「ログイン」に多要素認証は含まれるのか？
   - ソーシャルログインはどうなのか？
   - エンジニアが解釈に迷う

2. **二重管理による開発リソースの浪費**:
   - 人間が日本語を解釈し、手動でテストコードに翻訳する
   - 要件定義書とテストコードの整合性を保つために、
     エンジニアは時間を浪費する
   - その「二重管理」によって失われる開発リソースは、
     指数関数的に増大する

3. **解釈の余地（バグ）の発生**:
   - 自然言語で書けば書くほど、解釈の余地（バグ）が生まれる
   - エンジニアが解釈を間違えた場合、実装が間違う
   - その結果、バグが発生する

その親切心が、いかに現場の首を絞めているかという残酷な真実を暴きます。

「ユーザーはログインできる」といった一行のポエムを、わざわざマークダウンで
文書化して周知しようとする行為は、知的な怠慢であり、
エンジニアに「日本語を解釈する」という無賃労働を強いる、前時代的な管理手法です。
```

**✅ 改善されたアプローチ（実行可能な仕様（Executable Specifications））:**

```
機能要件を「実行可能な仕様（Executable Specifications）」として記述:

1. **Cucumberによる実行可能な仕様**:
   - 要件をGherkin形式で記述
   - テストコードと仕様を一致させる
   - 人間が日本語を解釈する必要がない

2. **Playwrightによる実行可能な仕様**:
   - 要件をE2Eテストとして記述
   - テストコードが仕様を語る
   - 人間が日本語を解釈する必要がない

例:
```gherkin
# features/login.feature
Feature: User Login
  Scenario: User can login with valid credentials
    Given the user is on the login page
    When the user enters valid email and password
    And the user clicks the login button
    Then the user should be redirected to the dashboard
    And the user should see their profile

  Scenario: User cannot login with invalid credentials
    Given the user is on the login page
    When the user enters invalid email and password
    And the user clicks the login button
    Then the user should see an error message
    And the user should remain on the login page

  Scenario: User can login with social login
    Given the user is on the login page
    When the user clicks the "Login with Google" button
    Then the user should be redirected to Google OAuth
    And after authentication, the user should be redirected to the dashboard
```

```typescript
// tests/login.spec.ts
import { test, expect } from '@playwright/test';

test.describe('User Login', () => {
  test('should login with valid credentials', async ({ page }) => {
    await page.goto('/login');
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'Test1234!@#$');
    await page.click('button[type="submit"]');
    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('.user-profile')).toBeVisible();
  });
  
  test('should not login with invalid credentials', async ({ page }) => {
    await page.goto('/login');
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'wrong');
    await page.click('button[type="submit"]');
    await expect(page.locator('.error-message')).toBeVisible();
    await expect(page).toHaveURL('/login');
  });
  
  test('should login with social login', async ({ page }) => {
    await page.goto('/login');
    await page.click('button:has-text("Login with Google")');
    await expect(page).toHaveURL(/accounts\.google\.com/);
    // OAuth認証後の処理
  });
});
```

# メリット:
# - 人間が日本語を解釈する必要がない
# - テストコードと仕様が一致する
# - 二重管理による開発リソースの浪費がない
# - 解釈の余地（バグ）が生まれない
```

### 非機能要件（注意: 「システムへの信頼の欠如」：非機能要件の空文化）

**❌ 問題のあるアプローチ（希望的観測の文書化）:**

```markdown
## 非機能要件の例

- レスポンスタイム: 1秒以内
- 可用性: 99.9%
- 同時接続数: 10,000ユーザー

# 問題点:
# 1. 「可用性99.9%」と文書に書くだけで、
#    その目標が達成されると本気で信じているのか
# 2. 文書に書くべきは希望的観測ではなく、
#    それを担保する「SLO（サービスレベル目標）」の計測ツールと、
#    逸脱した際のアラート設定
# 3. 非機能要件を「文書化」して満足している姿勢は、
#    インフラのコード化（IaC）やモニタリングによる自動検証から
#    目を背けた、技術的な敗北宣言
```

**🪓 マサカリ（超武闘派のCTOの視点）:**

```
【致命的過失3: 「システムへの信頼の欠如」：非機能要件の空文化】

「可用性99.9%」と文書に書くだけで、その目標が達成されると本気で信じているのですか？

文書に書くべきは希望的観測ではなく、それを担保する「SLO（サービスレベル目標）」
の計測ツールと、逸脱した際のアラート設定です。

非機能要件を「文書化」して満足している姿勢は、インフラのコード化（IaC）や
モニタリングによる自動検証から目を背けた、技術的な敗北宣言に他なりません。

現実には、以下のような状況が発生します：

1. **希望的観測の文書化**:
   - 「可用性99.9%」と文書に書くだけで、
     その目標が達成されると信じている
   - しかし、実際には可用性が99.9%に達していない可能性がある
   - 文書に書いただけで、目標が達成されると信じるのは、希望的観測である

2. **計測ツールとアラート設定の欠如**:
   - 文書に書くべきは希望的観測ではなく、
     それを担保する「SLO（サービスレベル目標）」の計測ツールと、
     逸脱した際のアラート設定である
   - しかし、これらの仕組みを構築していない

3. **技術的な敗北宣言**:
   - インフラのコード化（IaC）やモニタリングによる自動検証から
     目を背けている
   - 非機能要件を「文書化」して満足している姿勢は、
     技術的な敗北宣言である

その親切心が、いかに現場の首を絞めているかという残酷な真実を暴きます。

「可用性99.9%」と文書に書くだけで、その目標が達成されると信じる姿勢は、
技術的な敗北宣言であり、エンジニアに「希望的観測を信じる」という
無意味な作業を強いる、前時代的な管理手法です。
```

**✅ 改善されたアプローチ（SLO、IaC、モニタリングによる自動検証）:**

```
非機能要件を「SLO、IaC、モニタリング」で担保:

1. **SLO（サービスレベル目標）の計測ツール**:
   - 非機能要件を「SLO」として定義
   - 計測ツールで自動的に計測
   - 人間が確認する必要がない

2. **アラート設定**:
   - SLOが逸脱した際のアラート設定
   - 自動的にアラートを送る
   - 人間が確認する必要がない

3. **インフラのコード化（IaC）**:
   - 非機能要件を「IaC」として定義
   - インフラをコードで管理
   - 人間が手動で設定する必要がない

例:
```yaml
# infrastructure/slo.yaml
service_level_objectives:
  - name: availability
    target: 99.9%
    window: 30d
    alert_threshold: 99.5%
    
  - name: response_time
    target: 1s
    window: 30d
    alert_threshold: 2s

# infrastructure/monitoring.yaml
monitoring:
  - name: availability
    metric: uptime_percentage
    alert:
      when: < 99.5%
      severity: critical
      
  - name: response_time
    metric: p95_response_time
    alert:
      when: > 2s
      severity: warning

# infrastructure/terraform/main.tf
resource "aws_autoscaling_group" "app" {
  min_size = 3
  max_size = 10
  desired_capacity = 5
  
  target_tracking_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ASGAverageCPUUtilization"
    }
    target_value = 70.0
  }
}
```

# メリット:
# - 希望的観測ではなく、実際の計測に基づく
# - 人間が確認する必要がない
# - 技術的な敗北宣言ではなく、技術的卓越性の実現
```

## 3. 要件定義書の作成

### 要件定義書の構成（注意: 「スケーラビリティの完全な無視」：情報のサイロ化）

**❌ 問題のあるアプローチ（情報の断絶をもたらすテンプレート化）:**

```markdown
## 要件定義書の構成

1. **プロジェクト概要**
   - プロジェクトの目的
   - スコープ
   - 制約事項

2. **機能要件**
   - 機能一覧
   - 機能詳細

3. **非機能要件**
   - パフォーマンス要件
   - セキュリティ要件
   - 可用性要件

4. **インターフェース要件**
   - 外部システム連携
   - API仕様

# 問題点:
# 1. 「要件定義書の構成」をテンプレート化して配布する行為は、
#    組織に「情報の断絶」をもたらす
# 2. 要件定義、設計、実装、テスト……。これらを別々の「ドキュメント」として
#    分断し、人間がその整合性を保とうとする試みは、
#    組織が大きくなれば必ず破綻する
# 3. 真にスケールする組織は、全ての情報をコードベース（Single Source of Truth）
#    に集約し、マニュアルを読まずとも「コードが仕様を語る」状態を維持している
```

**🪓 マサカリ（超武闘派のCTOの視点）:**

```
【致命的過失4: 「スケーラビリティの完全な無視」：情報のサイロ化】

「要件定義書の構成」をテンプレート化して配布する行為は、組織に「情報の断絶」
をもたらします。

要件定義、設計、実装、テスト……。これらを別々の「ドキュメント」として分断し、
人間がその整合性を保とうとする試みは、組織が大きくなれば必ず破綻します。

真にスケールする組織は、全ての情報をコードベース（Single Source of Truth）
に集約し、マニュアルを読まずとも「コードが仕様を語る」状態を維持しています。

現実には、以下のような状況が発生します：

1. **情報のサイロ化**:
   - 要件定義、設計、実装、テストを別々の「ドキュメント」として分断
   - 人間がその整合性を保とうとする試み
   - 組織が大きくなれば、整合性を保つコストが指数関数的に増大する

2. **プロセスの破綻**:
   - 組織が大きくなれば、整合性を保つコストが維持できなくなる
   - プロセスが破綻し、情報の断絶が発生する

3. **スケーラビリティの欠如**:
   - 小規模な成功体験をそのまま大規模組織に持ち込もうとする
   - スケーラビリティの欠如した稚拙な発想に基づいている

その親切心が、いかに現場の首を絞めているかという残酷な真実を暴きます。

「要件定義書の構成」をテンプレート化して配布する行為は、情報のサイロ化を
引き起こし、組織の成長を阻害する原因です。
```

**✅ 改善されたアプローチ（Single Source of Truthとしてのコードベース）:**

```
全ての情報をコードベース（Single Source of Truth）に集約:

1. **要件をテストコードとして定義**:
   - 要件定義、設計、実装、テストを「テストコード」として統合
   - テストコードが仕様を語る
   - 人間が整合性を保つ必要がない

2. **コードが仕様を語る**:
   - マニュアルを読まずとも「コードが仕様を語る」状態を維持
   - エンジニアは、コードを読めば仕様を理解できる
   - 日本語を解釈する必要がない

3. **スケーラビリティの実現**:
   - 組織が大きくなっても、プロセスが維持できる
   - 整合性を保つコストが増大しない

例:
```typescript
// 要件定義、設計、実装、テストを統合（Single Source of Truth）
describe('User Authentication', () => {
  // 要件定義: ユーザーはログインできる
  // 設計: メールアドレスとパスワードでログイン
  // 実装: login関数
  // テスト: ログイン成功のテスト
  it('should login with valid credentials', async () => {
    const result = await login('test@example.com', 'Test1234!@#$');
    expect(result.success).toBe(true);
    expect(result.token).toBeDefined();
  });
  
  // 要件定義: ユーザーは多要素認証でログインできる
  // 設計: メールアドレス、パスワード、OTPでログイン
  // 実装: loginWithMFA関数
  // テスト: 多要素認証のテスト
  it('should login with multi-factor authentication', async () => {
    const result = await loginWithMFA(
      'test@example.com',
      'Test1234!@#$',
      '123456'
    );
    expect(result.success).toBe(true);
  });
});
```

# メリット:
# - 情報のサイロ化がない
# - 組織が大きくなっても、プロセスが維持できる
# - マニュアルを読まずとも「コードが仕様を語る」状態を維持
# - スケーラビリティの実現
```

## まとめ

要件定義完全ガイドのポイント：

- **要件の収集**: ステークホルダーからの要件収集
- **要件の分析**: 要件の整理と分析
- **要件の文書化**: 要件定義書の作成
- **要件の検証**: 要件の妥当性確認

#### 覚醒の一言（資料を破り捨てて「仕組み（As Code）」に投資するために）

**「要件定義書を『書く』のをやめ、要件を『テスト』としてコミットしてください」**

貴殿が「要件定義完全ガイド」を考えるために費やす時間を、以下のように使ってください：

1. **要件定義書を作成する時間**: 
   要件を「Cucumber」や「Playwright」による実行可能な仕様（Executable Specifications）
   として記述し、テストコードと仕様を一致させる

2. **要件の承認プロセスを設ける時間**: 
   要件を「承認」するのではなく、継続的に改善する仕組みを構築する

3. **非機能要件を文書化する時間**: 
   非機能要件を「SLO（サービスレベル目標）」の計測ツールとアラート設定、
   インフラのコード化（IaC）として定義する

4. **要件定義書の構成をテンプレート化する時間**: 
   全ての情報をコードベース（Single Source of Truth）に集約し、
   マニュアルを読まずとも「コードが仕様を語る」状態を維持する

**資料を破り捨てて、「仕組み（As Code）」に投資してください。**

「完全ガイド」という傲慢なタイトルを冠しながら、その実態は20年前から進歩していない
「静的な情報の墓場」を構築する手引書に過ぎません。

この資料が現場に導入された場合、半年以内に優秀なエンジニアは「解釈の壁」に絶望し、
静かに去っていくでしょう。

要件定義書を「書く」のをやめ、要件を「テスト」としてコミットしてください。

適切な要件定義により、成功するプロジェクトを構築できます。
ただし、「要件定義書を書く」という前時代的な管理手法ではなく、
「要件をテストとしてコミットする」という技術的卓越性の実現が必要です。

**最も重要なのは、エンジニアを「自律したプロ」として扱い、
「日本語を解釈する」という無賃労働を強いることをやめることです。**


