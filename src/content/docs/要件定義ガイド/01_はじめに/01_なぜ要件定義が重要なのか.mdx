---
title: なぜ要件定義が重要なのか
sidebar:
    label: はじめに
---

# なぜ要件定義が重要なのか

**⚠️ この資料の致命的な欠陥を指摘します。**

拝読いたしました。貴殿の案は、組織を「ルールに依存する無能な集団」へと導く、非常に危険な思想に基づいています。

要件定義は、プロジェクトの成功を左右する重要な活動です。

しかし、この資料には以下の致命的な欠陥があります。

## 要件定義の重要性（注意: 「読解という名の無賃労働」の強要）

**❌ 問題のあるアプローチ（多義的で曖昧な自然言語のドキュメントの量産）:**

```
要件定義が不適切な場合:
- 開発の方向性が不明確
- 仕様の変更が頻繁に発生
- プロジェクトの遅延
- 品質の問題

適切な要件定義により:
- 開発の方向性が明確
- 仕様の変更を最小限に
- プロジェクトの成功
- 品質の向上

# 問題点:
# 1. 「方向性を明確にする」という美名の下に、
#    多義的で曖昧な自然言語（日本語）のドキュメントを量産し、
#    それを開発者に読み込ませるプロセスは、知的リソースの搾取
# 2. エンジニアが解釈に迷うような要件定義書は、
#    それ自体が巨大な「技術的負債」
```

**🪓 マサカリ（超武闘派のCTOの視点）:**

```
【致命的過失1: 「読解という名の無賃労働」の強要】

「方向性を明確にする」という美名の下に、多義的で曖昧な自然言語（日本語）の
ドキュメントを量産し、それを開発者に読み込ませるプロセスは、
知的リソースの搾取です。

エンジニアが解釈に迷うような要件定義書は、それ自体が巨大な「技術的負債」です。
なぜ「動くプロトタイプ」や「実行可能な仕様（Executable Specifications）」
で語ろうとしないのでしょうか。

言葉を尽くして「定義」したつもりになるのは、実体がないものを管理している
という幻想に浸りたいマネジメントの甘えに過ぎません。

現実には、以下のような状況が発生します：

1. **要件定義書を読む時間の浪費**:
   - エンジニアが「要件定義書」という日本語のドキュメントを
     読むのに、平均1時間かかると仮定
   - エンジニアの工数単価が時給5,000円と仮定
   - 要件定義書を読むコスト: 1時間 × 5,000円/時間 = 5,000円

2. **日本語の解釈という無賃労働**:
   - 「開発の方向性が明確」
   - 「仕様の変更を最小限に」
   - 「プロジェクトの成功」
   - これらの日本語を解釈するために、エンジニアは時間を浪費する

3. **解釈の迷いによる技術的負債**:
   - エンジニアが解釈に迷うような要件定義書は、
     実装の不整合を生む
   - 実装の不整合は、技術的負債として蓄積される
   - 要件定義書自体が、巨大な「技術的負債」になる

その親切心が、いかに現場の首を絞めているかという残酷な真実を暴きます。

「要件定義書を作成する」という作業は、エンジニアに「日本語を解釈する」
という無賃労働を強いる、知的リソースの搾取です。
```

**✅ 改善されたアプローチ（「Contextは日本語」「Specはコード」）:**

```
要件定義を「自然言語の役割分離」と「実行可能な契約」で行う:

1. **自然言語の役割を再定義**:
   - 日本語は「なぜ作るか（Context）」を語るために使う
   - コードは「どう動くか（Spec）」を規定するために使う
   - ADRやドキュメントは意図と意思決定を残す

2. **Executable Specificationを共通言語にする**:
   - it('should ...') ではなく、Gherkinで仕様を記述
   - 日本語の仕様がそのままテストとして実行される
   - 二重管理を排除する唯一の現実解

3. **契約による設計の対象を広げる**:
   - TypeScriptだけでなく、OpenAPIやProtocol Buffersを成果物にする
   - ドキュメントであり、同時にコード生成源になる
   - 日本語の曖昧さを技術で排除する

例:
```gherkin
# Executable Specification（Gherkin）
Feature: ログイン
  Scenario: 正しい認証情報でログインできる
    Given ユーザーが登録済みである
    When 正しいメールアドレスとパスワードでログインする
    Then ステータスコードは200である
    And 認証トークンが返る

  Scenario: 誤ったパスワードではログインできない
    Given ユーザーが登録済みである
    When 誤ったパスワードでログインする
    Then ステータスコードは401である
```

```yaml
# OpenAPI（契約）
paths:
  /api/auth/login:
    post:
      requestBody:
        content:
          application/json:
            schema:
              type: object
              required: [email, password]
              properties:
                email:
                  type: string
                  format: email
                password:
                  type: string
      responses:
        '200':
          description: ログイン成功
        '401':
          description: 認証失敗
```

```proto
// Protocol Buffers（契約）
message LoginRequest {
  string email = 1;
  string password = 2;
}

message LoginResponse {
  string token = 1;
}
```

# メリット:
# - 日本語はContextに限定され、解釈の揺れが減る
# - 仕様がテストとして実行され、二重管理が消える
# - 契約がコード生成源となり、実装と乖離しない
```

## まとめ（注意: 「周知という名の責任転嫁」「システムへの信頼の欠如」「スケーラビリティの完全な無視」）

**❌ 問題のあるアプローチ（前時代的な要件定義プロセス）:**

```
要件定義が重要な理由：
- 方向性: 開発の方向性を明確にする
- 効率: 開発効率を向上させる
- 品質: 品質を向上させる
- 成功: プロジェクトの成功に貢献

# 問題点:
# 1. 「要件を定義した」ことで仕事が終わったと考え、
#    その後の変更を「仕様変更」として現場の責任にする構造
# 2. なぜ「人間が定義し、人間がチェックする」という、
#    最もエラーの起きやすい手法に固執するのか
# 3. その「重厚な要件定義」というプロセスを、
#    開発速度が10倍になった時、あるいはプロダクトが巨大化した時に、
#    変わらず維持できるのか
```

**🪓 マサカリ（超武闘派のCTOの視点）:**

```
【致命的過失2: 「周知という名の責任転嫁」のアリバイ作り】

「要件を定義した」ことで仕事が終わったと考え、その後の変更を
「仕様変更」として現場の責任にする構造そのものが卑怯です。

現実は常に変化します。それにもかかわらず、初期段階で「定義」し、
それを「周知」することで変化を拒む壁を作る。これは「伝えたはずだ」
というアリバイ作りのための儀式であり、顧客の真のニーズに応えるための
「俊敏性（Agility）」を根底から破壊しています。

現実には、以下のような状況が発生します：

1. **要件定義の固定化**:
   - 初期段階で「要件を定義した」ことで、マネジメントは仕事が終わったと考える
   - その後の変更を「仕様変更」として現場の責任にする
   - しかし、現実は常に変化する

2. **俊敏性（Agility）の破壊**:
   - 要件定義を固定化することで、変化を拒む壁を作る
   - 顧客の真のニーズに応えるための「俊敏性（Agility）」を根底から破壊する

3. **責任転嫁の構造**:
   - 「要件を定義した」「周知した」という事実で、
     マネジメントは「伝えたはずだ」というアリバイを作る
   - しかし、要件が変更された場合、エンジニアの責任になる
   - これは、マネジメントの責任をエンジニアに転嫁する、卑怯な構造である

その親切心が、いかに現場の首を絞めているかという残酷な真実を暴きます。

「要件を定義した」ことで仕事が終わったと考える構造は、
顧客の真のニーズに応えるための「俊敏性（Agility）」を根底から破壊する、
卑怯な構造です。

【致命的過失3: 「システムへの信頼の欠如」という技術的敗北】

なぜ「人間が定義し、人間がチェックする」という、最もエラーの起きやすい
手法に固執するのですか？

要件を「ドキュメント」として眠らせるのではなく、なぜテストコードの期待値や、
契約による設計（Design by Contract）としてシステムに組み込まないのでしょうか。
人間が要件定義書を確認しなければ品質が保てない組織は、技術による自動検証の
可能性を放棄した「敗北した組織」です。

現実には、以下のような状況が発生します：

1. **人間のミスによるエラー**:
   - 「人間が定義し、人間がチェックする」という手法は、
     最もエラーの起きやすい手法である
   - 人間はミスをする。要件定義書に誤りがある可能性がある

2. **ドキュメントの放置**:
   - 要件を「ドキュメント」として眠らせることで、
     実装との乖離が発生する
   - ドキュメントが古くなり、実装と一致しなくなる

3. **技術による自動検証の放棄**:
   - テストコードの期待値や、契約による設計（Design by Contract）として
     システムに組み込むことで、自動検証が可能になる
   - しかし、その可能性を放棄している

その親切心が、いかに現場の首を絞めているかという残酷な真実を暴きます。

「人間が定義し、人間がチェックする」という手法は、技術による自動検証の
可能性を放棄した「敗北した組織」の証です。

【致命的過失4: 「スケーラビリティの完全な無視」】

その「重厚な要件定義」というプロセスを、開発速度が10倍になった時、
あるいはプロダクトが巨大化した時に、変わらず維持できるとお考えですか？

規模が大きくなるほど、ドキュメントの整合性を保つコストは指数関数的に増大します。
貴殿の案は、小規模な成功体験をそのまま大規模組織に持ち込もうとする
「スケーラビリティの欠如した」稚拙な発想に基づいています。

現実には、以下のような状況が発生します：

1. **プロセスを10倍繰り返した場合**:
   - 開発速度が10倍になった場合、要件定義のプロセスも10倍になる
   - ドキュメントの整合性を保つコストが10倍になる
   - しかし、そのコストは指数関数的に増大する

2. **プロダクトが巨大化した場合**:
   - プロダクトが巨大化した場合、要件定義書も巨大化する
   - ドキュメントの整合性を保つコストが指数関数的に増大する
   - プロセスが維持できなくなる

3. **組織の劣化**:
   - スケーラビリティの欠如したプロセスは、組織の成長を阻害する
   - トップエンジニアが逃げ出し、凡庸な会社へと転落する

その親切心が、いかに現場の首を絞めているかという残酷な真実を暴きます。

「重厚な要件定義」というプロセスは、スケーラビリティの欠如した稚拙な発想であり、
組織の成長を阻害する原因です。
```

**✅ 改善されたアプローチ（「仕組み（As Code）」による要件定義）:**

```
要件定義を「仕組み（As Code）」で行う:

1. **テストコードによる要件定義**:
   - 要件を「テストコード」として定義
   - テストコードを実行すれば、要件が満たされているか自動的に検証できる
   - 開発速度が10倍になっても、プロセスが維持できる

2. **契約による設計（Design by Contract）**:
   - 要件を「型定義」や「スキーマ」として定義
   - 型定義やスキーマから自動的にコードを生成
   - プロダクトが巨大化しても、プロセスが維持できる

3. **CIによる自動検証**:
   - 要件を「CI」で自動検証
   - 人間が確認する必要がない
   - スケーラビリティの問題がない

例:
```typescript
// テストコードによる要件定義
describe('User Authentication Requirements', () => {
  it('REQ-001: should login with valid credentials', async () => {
    // 要件をテストコードとして定義
  });
  
  it('REQ-002: should reject invalid credentials', async () => {
    // 要件をテストコードとして定義
  });
});

// CIによる自動検証
# .github/workflows/requirements-check.yml
name: Requirements Check

on: [push, pull_request]

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Run Requirements Tests
        run: npm test
```

# メリット:
# - 開発速度が10倍になっても、プロセスが維持できる
# - プロダクトが巨大化しても、プロセスが維持できる
# - 人間が確認する必要がない
# - スケーラビリティの問題がない
```

## 覚醒の一言（資料を破り捨てて「仕組み（As Code）」に投資するために）

**「要件を『書く』のをやめ、要件を『組む（Implement）』ことに集中してください」**

貴殿が「要件定義」を考えるために費やす時間を、以下のように使ってください：

1. **要件定義書を作成する時間**: 
   要件を「テストコード」として定義し、実行可能な仕様（Executable Specifications）
   を構築する

2. **要件を周知する時間**: 
   要件を「型定義」や「スキーマ」として定義し、契約による設計（Design by Contract）
   を実現する

3. **要件を確認する時間**: 
   要件を「CI」で自動検証し、人間が確認する必要がない仕組みを構築する

4. **要件定義書を管理する時間**: 
   要件を「コード」として管理し、実装との乖離を防ぐ仕組みを構築する

**資料を破り捨てて、「仕組み（As Code）」に投資してください。**

「資料を読んで足並みを揃える」という前時代的な管理手法は、
組織の機動力を削ぎ、エンジニアから思考力を奪う「知的虐待」です。

エンジニアの職務は「問題を解決するコードを書くこと」であり、
「日本語を解釈すること」ではありません。

要件を「書く」のをやめ、要件を「組む（Implement）」ことに集中してください。

適切な要件定義により、成功するプロジェクトを構築できます。
ただし、「要件を書く」という前時代的な管理手法ではなく、
「要件を組む（Implement）」という技術的卓越性の実現が必要です。

**最も重要なのは、エンジニアを「自律したプロ」として扱い、
「日本語を解釈する」という無賃労働を強いることをやめることです。**


