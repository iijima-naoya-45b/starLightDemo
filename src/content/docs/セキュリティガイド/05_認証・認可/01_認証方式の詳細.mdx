---
title: "èªè¨¼æ–¹å¼ã®è©³ç´°"
label: "èªè¨¼æ–¹å¼ã®è©³ç´°"
---

## ğŸ”‘ èªè¨¼æ–¹å¼ã®è©³ç´°

`èªè¨¼`ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæœ¬äººã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã§ã™ã€‚é©åˆ‡ãª`èªè¨¼æ–¹å¼`ã‚’é¸æŠã—ã€å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€`ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£`ã‚’ç¢ºä¿ã§ãã¾ã™ã€‚

### ğŸ¯ ãªãœèªè¨¼æ–¹å¼ãŒé‡è¦ãªã®ã‹

#### âš ï¸ èªè¨¼ã®ä¸å‚™ã«ã‚ˆã‚‹å•é¡Œ

**ğŸ’¡ å®Ÿéš›ã®äº‹ä¾‹:**

2021å¹´ã€ã‚ã‚‹SaaSã‚µãƒ¼ãƒ“ã‚¹ã§`èªè¨¼`ã®ä¸å‚™ãŒç™ºè¦‹ã•ã‚Œã¾ã—ãŸï¼š

- ğŸ”¥ **å•é¡Œ**: `ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰`ãŒå¹³æ–‡ã§ä¿å­˜ã•ã‚Œã¦ã„ãŸ
- ğŸ”¥ **çµæœ**: `ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹`ãŒæ¼æ´©ã—ã€ç´„10ä¸‡äººã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒä¾µå®³ã•ã‚ŒãŸ
- ğŸ’¸ **å½±éŸ¿**: 
  - ç´„5å„„å††ã®æå®³è³ å„Ÿ
  - ã‚µãƒ¼ãƒ“ã‚¹ã®ä¿¡é ¼å¤±å¢œ
  - æ³•çš„è²¬ä»»ãŒå•ã‚ã‚ŒãŸ

**æ•™è¨“:**
- âœ… é©åˆ‡ãª`èªè¨¼æ–¹å¼`ã®é¸æŠã¨å®Ÿè£…ãŒé‡è¦
- âœ… `ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰`ã®é©åˆ‡ãªç®¡ç†ãŒå¿…é ˆ

### èªè¨¼æ–¹å¼ã®ç¨®é¡

#### 1. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼

**åŸºæœ¬çš„ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼:**

```javascript
// å®‰å…¨ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼ã®å®Ÿè£…
const bcrypt = require('bcrypt');

class PasswordAuth {
  async hashPassword(password) {
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ï¼ˆã‚½ãƒ«ãƒˆã‚’è‡ªå‹•ç”Ÿæˆï¼‰
    const saltRounds = 12;  // ã‚³ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ï¼ˆé«˜ã„ã»ã©å®‰å…¨ã ãŒé…ã„ï¼‰
    const hash = await bcrypt.hash(password, saltRounds);
    return hash;
  }
  
  async verifyPassword(password, hash) {
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
    const isValid = await bcrypt.compare(password, hash);
    return isValid;
  }
  
  async createUser(email, password) {
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ä¿å­˜
    const passwordHash = await this.hashPassword(password);
    
    await db.users.create({
      email,
      passwordHash,  // å¹³æ–‡ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯ä¿å­˜ã—ãªã„
      createdAt: new Date(),
    });
  }
  
  async authenticate(email, password) {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
    const user = await db.users.findOne({ email });
    if (!user) {
      throw new Error('Invalid credentials');
    }
    
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
    const isValid = await this.verifyPassword(password, user.passwordHash);
    if (!isValid) {
      throw new Error('Invalid credentials');
    }
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¾ãŸã¯ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    const sessionToken = await this.generateSessionToken(user.id);
    return sessionToken;
  }
}
```

**ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®å¼·åº¦ãƒã‚§ãƒƒã‚¯:**

```javascript
// ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®å¼·åº¦ã‚’ãƒã‚§ãƒƒã‚¯
class PasswordValidator {
  validatePassword(password) {
    const errors = [];
    
    // é•·ã•ã®ãƒã‚§ãƒƒã‚¯ï¼ˆ12æ–‡å­—ä»¥ä¸Šï¼‰
    if (password.length < 12) {
      errors.push('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯12æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }
    
    // å¤§æ–‡å­—ã®ãƒã‚§ãƒƒã‚¯
    if (!/[A-Z]/.test(password)) {
      errors.push('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯å¤§æ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }
    
    // å°æ–‡å­—ã®ãƒã‚§ãƒƒã‚¯
    if (!/[a-z]/.test(password)) {
      errors.push('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯å°æ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }
    
    // æ•°å­—ã®ãƒã‚§ãƒƒã‚¯
    if (!/[0-9]/.test(password)) {
      errors.push('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯æ•°å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }
    
    // è¨˜å·ã®ãƒã‚§ãƒƒã‚¯
    if (!/[!@#$%^&*]/.test(password)) {
      errors.push('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯è¨˜å·ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }
    
    // ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
    const commonPasswords = ['password', '123456', 'qwerty'];
    if (commonPasswords.includes(password.toLowerCase())) {
      errors.push('ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“');
    }
    
    return {
      valid: errors.length === 0,
      errors,
    };
  }
}
```

#### 2. å¤šè¦ç´ èªè¨¼ï¼ˆMFAï¼‰

**å¤šè¦ç´ èªè¨¼ã®å®Ÿè£…:**

```javascript
// å¤šè¦ç´ èªè¨¼ï¼ˆMFAï¼‰ã®å®Ÿè£…
const speakeasy = require('speakeasy');
const QRCode = require('qrcode');

class MultiFactorAuth {
  async setupMFA(userId) {
    // TOTPï¼ˆTime-based One-Time Passwordï¼‰ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆ
    const secret = speakeasy.generateSecret({
      name: `MyApp (${userId})`,
      issuer: 'MyApp',
    });
    
    // QRã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
    const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url);
    
    // ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ä¸€æ™‚çš„ã«ä¿å­˜ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç¢ºèªã§ãã‚‹ã‚ˆã†ã«ï¼‰
    await db.mfaSecrets.create({
      userId,
      secret: secret.base32,
      verified: false,
      createdAt: new Date(),
    });
    
    return {
      secret: secret.base32,
      qrCodeUrl,
    };
  }
  
  async verifyMFA(userId, token) {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®MFAã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’å–å¾—
    const mfaSecret = await db.mfaSecrets.findOne({
      userId,
      verified: true,
    });
    
    if (!mfaSecret) {
      throw new Error('MFA is not set up');
    }
    
    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼
    const verified = speakeasy.totp.verify({
      secret: mfaSecret.secret,
      encoding: 'base32',
      token,
      window: 2,  // å‰å¾Œ2åˆ†ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¨±å®¹
    });
    
    return verified;
  }
  
  async authenticateWithMFA(email, password, mfaToken) {
    // 1. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼
    const user = await passwordAuth.authenticate(email, password);
    
    // 2. MFAèªè¨¼
    const mfaValid = await this.verifyMFA(user.id, mfaToken);
    if (!mfaValid) {
      throw new Error('Invalid MFA token');
    }
    
    // 3. ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
    const sessionToken = await this.generateSessionToken(user.id);
    return sessionToken;
  }
}
```

**SMSèªè¨¼ã®å®Ÿè£…:**

```javascript
// SMSèªè¨¼ã®å®Ÿè£…
class SMSAuth {
  async sendVerificationCode(phoneNumber) {
    // 6æ¡ã®èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜ï¼ˆ5åˆ†é–“æœ‰åŠ¹ï¼‰
    await db.verificationCodes.create({
      phoneNumber,
      code,
      expiresAt: new Date(Date.now() + 5 * 60 * 1000),  // 5åˆ†å¾Œ
    });
    
    // SMSã‚’é€ä¿¡
    await smsService.send(phoneNumber, `èªè¨¼ã‚³ãƒ¼ãƒ‰: ${code}`);
    
    return { sent: true };
  }
  
  async verifyCode(phoneNumber, code) {
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
    const verificationCode = await db.verificationCodes.findOne({
      phoneNumber,
      code,
      expiresAt: { $gt: new Date() },  // æœ‰åŠ¹æœŸé™å†…
      used: false,
    });
    
    if (!verificationCode) {
      throw new Error('Invalid or expired verification code');
    }
    
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨æ¸ˆã¿ã«ã™ã‚‹
    await db.verificationCodes.update(verificationCode.id, {
      used: true,
      usedAt: new Date(),
    });
    
    return { verified: true };
  }
}
```

#### 3. OAuth 2.0èªè¨¼

**OAuth 2.0èªè¨¼ã®å®Ÿè£…:**

```javascript
// OAuth 2.0èªè¨¼ã®å®Ÿè£…
const axios = require('axios');

class OAuth2Auth {
  constructor() {
    this.clientId = process.env.OAUTH_CLIENT_ID;
    this.clientSecret = process.env.OAUTH_CLIENT_SECRET;
    this.redirectUri = process.env.OAUTH_REDIRECT_URI;
    this.authorizationUrl = 'https://oauth.provider.com/authorize';
    this.tokenUrl = 'https://oauth.provider.com/token';
  }
  
  getAuthorizationUrl(state) {
    // èªè¨¼URLã‚’ç”Ÿæˆ
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      response_type: 'code',
      scope: 'openid profile email',
      state,  // CSRFå¯¾ç­–
    });
    
    return `${this.authorizationUrl}?${params.toString()}`;
  }
  
  async exchangeCodeForToken(code) {
    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ã«äº¤æ›
    const response = await axios.post(this.tokenUrl, {
      grant_type: 'authorization_code',
      code,
      redirect_uri: this.redirectUri,
      client_id: this.clientId,
      client_secret: this.clientSecret,
    });
    
    return {
      accessToken: response.data.access_token,
      refreshToken: response.data.refresh_token,
      expiresIn: response.data.expires_in,
    };
  }
  
  async getUserInfo(accessToken) {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
    const response = await axios.get('https://oauth.provider.com/userinfo', {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
    
    return {
      id: response.data.sub,
      email: response.data.email,
      name: response.data.name,
    };
  }
  
  async authenticateWithOAuth(code, state) {
    // 1. stateã‚’æ¤œè¨¼ï¼ˆCSRFå¯¾ç­–ï¼‰
    const storedState = await this.getStoredState();
    if (state !== storedState) {
      throw new Error('Invalid state');
    }
    
    // 2. èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ã«äº¤æ›
    const tokens = await this.exchangeCodeForToken(code);
    
    // 3. ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
    const userInfo = await this.getUserInfo(tokens.accessToken);
    
    // 4. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆã¾ãŸã¯æ›´æ–°
    let user = await db.users.findOne({ oauthId: userInfo.id });
    if (!user) {
      user = await db.users.create({
        oauthId: userInfo.id,
        email: userInfo.email,
        name: userInfo.name,
        oauthProvider: 'oauth',
      });
    }
    
    // 5. ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
    const sessionToken = await this.generateSessionToken(user.id);
    return sessionToken;
  }
}
```

#### 4. JWTï¼ˆJSON Web Tokenï¼‰èªè¨¼

**JWTèªè¨¼ã®å®Ÿè£…:**

```javascript
// JWTèªè¨¼ã®å®Ÿè£…
const jwt = require('jsonwebtoken');

class JWTAuth {
  constructor() {
    this.secret = process.env.JWT_SECRET;
    this.accessTokenExpiry = '15m';  // 15åˆ†
    this.refreshTokenExpiry = '7d';  // 7æ—¥
  }
  
  generateAccessToken(userId) {
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    return jwt.sign(
      { userId, type: 'access' },
      this.secret,
      { expiresIn: this.accessTokenExpiry }
    );
  }
  
  generateRefreshToken(userId) {
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    return jwt.sign(
      { userId, type: 'refresh' },
      this.secret,
      { expiresIn: this.refreshTokenExpiry }
    );
  }
  
  verifyToken(token) {
    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼
    try {
      const decoded = jwt.verify(token, this.secret);
      return decoded;
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        throw new Error('Token expired');
      }
      throw new Error('Invalid token');
    }
  }
  
  async authenticate(email, password) {
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼
    const user = await passwordAuth.authenticate(email, password);
    
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã¨ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    const accessToken = this.generateAccessToken(user.id);
    const refreshToken = this.generateRefreshToken(user.id);
    
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
    await db.refreshTokens.create({
      userId: user.id,
      token: refreshToken,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),  // 7æ—¥å¾Œ
    });
    
    return {
      accessToken,
      refreshToken,
    };
  }
  
  async refreshAccessToken(refreshToken) {
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼
    const decoded = this.verifyToken(refreshToken);
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç¢ºèª
    const storedToken = await db.refreshTokens.findOne({
      userId: decoded.userId,
      token: refreshToken,
      expiresAt: { $gt: new Date() },
      revoked: false,
    });
    
    if (!storedToken) {
      throw new Error('Invalid refresh token');
    }
    
    // æ–°ã—ã„ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    const accessToken = this.generateAccessToken(decoded.userId);
    
    return { accessToken };
  }
}
```

### èªè¨¼ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

#### 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†

**å®‰å…¨ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†:**

```javascript
// å®‰å…¨ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†
class SessionManager {
  async createSession(userId) {
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ç”Ÿæˆï¼ˆãƒ©ãƒ³ãƒ€ãƒ ã§æ¨æ¸¬ä¸å¯èƒ½ï¼‰
    const sessionId = this.generateSecureSessionId();
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä¿å­˜
    await db.sessions.create({
      sessionId,
      userId,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),  // 24æ™‚é–“å¾Œ
      ipAddress: this.getClientIp(),
      userAgent: this.getUserAgent(),
    });
    
    // Cookieã«ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’è¨­å®š
    this.setCookie('sessionId', sessionId, {
      httpOnly: true,  // JavaScriptã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯
      secure: true,    // HTTPSã®ã¿
      sameSite: 'strict',  // CSRFå¯¾ç­–
      maxAge: 24 * 60 * 60 * 1000,  // 24æ™‚é–“
    });
    
    return sessionId;
  }
  
  async validateSession(sessionId) {
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’æ¤œè¨¼
    const session = await db.sessions.findOne({
      sessionId,
      expiresAt: { $gt: new Date() },
      revoked: false,
    });
    
    if (!session) {
      throw new Error('Invalid or expired session');
    }
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æ›´æ–°ï¼ˆã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ã‚¯ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
    await db.sessions.update(session.id, {
      lastAccessedAt: new Date(),
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
    });
    
    return session;
  }
  
  async revokeSession(sessionId) {
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç„¡åŠ¹åŒ–
    await db.sessions.update(
      { sessionId },
      { revoked: true, revokedAt: new Date() }
    );
  }
  
  async revokeAllUserSessions(userId) {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã™ã¹ã¦ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç„¡åŠ¹åŒ–
    await db.sessions.update(
      { userId, revoked: false },
      { revoked: true, revokedAt: new Date() }
    );
  }
}
```

#### 2. ãƒ¬ãƒ¼ãƒˆåˆ¶é™

**èªè¨¼è©¦è¡Œã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™:**

```javascript
// èªè¨¼è©¦è¡Œã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™
class RateLimiter {
  async checkRateLimit(identifier, action, maxAttempts, windowMs) {
    const key = `rate_limit:${action}:${identifier}`;
    
    // ç¾åœ¨ã®è©¦è¡Œå›æ•°ã‚’å–å¾—
    const attempts = await redis.incr(key);
    
    // åˆå›ã®è©¦è¡Œã®å ´åˆã€æœ‰åŠ¹æœŸé™ã‚’è¨­å®š
    if (attempts === 1) {
      await redis.expire(key, Math.ceil(windowMs / 1000));
    }
    
    // è©¦è¡Œå›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆ
    if (attempts > maxAttempts) {
      const ttl = await redis.ttl(key);
      throw new Error(`Too many attempts. Please try again in ${ttl} seconds.`);
    }
    
    return { attempts, remaining: maxAttempts - attempts };
  }
  
  async limitLoginAttempts(email) {
    // ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã‚’5å›/15åˆ†ã«åˆ¶é™
    return await this.checkRateLimit(email, 'login', 5, 15 * 60 * 1000);
  }
  
  async limitPasswordReset(email) {
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã‚’3å›/æ™‚é–“ã«åˆ¶é™
    return await this.checkRateLimit(email, 'password_reset', 3, 60 * 60 * 1000);
  }
}
```

### ã¾ã¨ã‚

èªè¨¼æ–¹å¼ã®ãƒã‚¤ãƒ³ãƒˆï¼š

- **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰èªè¨¼**: å¼·åŠ›ãªãƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã€å¼·åº¦ãƒã‚§ãƒƒã‚¯ã€é©åˆ‡ãªç®¡ç†
- **å¤šè¦ç´ èªè¨¼**: TOTPã€SMSèªè¨¼ãªã©ã€è¤‡æ•°ã®èªè¨¼è¦ç´ ã‚’çµ„ã¿åˆã‚ã›ã‚‹
- **OAuth 2.0**: ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£èªè¨¼ã€é©åˆ‡ãªå®Ÿè£…ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–
- **JWTèªè¨¼**: ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã¨ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®é©åˆ‡ãªç®¡ç†
- **ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†**: å®‰å…¨ãªã‚»ãƒƒã‚·ãƒ§ãƒ³IDã€é©åˆ‡ãªæœ‰åŠ¹æœŸé™ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ç„¡åŠ¹åŒ–
- **ãƒ¬ãƒ¼ãƒˆåˆ¶é™**: èªè¨¼è©¦è¡Œã®åˆ¶é™ã€ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹æ”»æ’ƒã®é˜²æ­¢

é©åˆ‡ãªèªè¨¼æ–¹å¼ã‚’é¸æŠã—ã€å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ç¢ºä¿ã§ãã¾ã™ã€‚

