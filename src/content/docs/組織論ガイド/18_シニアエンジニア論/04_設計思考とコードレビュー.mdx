---
title: 設計思考とコードレビュー
sidebar:
    label: 設計思考とコードレビュー
---

# 設計思考とコードレビュー

## 設計思考：正解を出す → 選択肢を提示する

### ジュニア・ミドルとの差

**ジュニア・ミドルのアプローチ:**
- 「これが正しい」
- 1つの解決策を提示
- 他の選択肢を考慮しない

**シニアのアプローチ:**
- 「制約条件を踏まえると、この3案がある」
- 複数の選択肢を提示
- 各選択肢のトレードオフを説明

### トレードオフを説明できる

#### 開発速度 vs 安定性

```markdown
## 設計判断: 開発速度 vs 安定性

### 選択肢1: 開発速度を優先
- **実装**: 既存のライブラリをそのまま使用
- **メリット**: 迅速な開発、短期間でのリリース
- **デメリット**: 技術的負債の蓄積、将来の変更が困難
- **適用**: MVP、プロトタイプ、短期プロジェクト

### 選択肢2: 安定性を優先
- **実装**: カスタム実装、包括的なテスト
- **メリット**: 高い品質、長期的な保守性
- **デメリット**: 開発時間の増加、コストの増加
- **適用**: 本番環境、長期運用が前提のシステム

### 選択肢3: バランス型
- **実装**: 重要な部分はカスタム、その他はライブラリ
- **メリット**: 開発速度と安定性のバランス
- **デメリット**: 判断が難しい、設計の複雑化
- **適用**: 中規模プロジェクト、段階的な開発
```

### UNKNOWNを状態として扱える

```typescript
// UNKNOWNを状態として扱う
class DesignDecision {
  status: 'decided' | 'unknown' | 'needs_research';
  alternatives: Alternative[];
  constraints: Constraint[];
  risks: Risk[];
  
  markAsUnknown(reason: string, researchPlan: string): void {
    this.status = 'unknown';
    this.unknownReason = reason;
    this.researchPlan = researchPlan;
    this.deadline = this.calculateDeadline();
  }
}
```

## コードレビュー力：指摘する → 育てる

### シニアのレビューはここが違う

**ジュニア・ミドルのレビュー:**
- 文法・書き方の指摘
- 「変数名をキャメルケースにしてください」
- 「インデントを修正してください」

**シニアのレビュー:**
- 設計意図・責務・将来影響を見る
- 「この関数の責務は何ですか？単一責任の原則に違反していませんか？」
- 「この設計は将来の変更に対応できますか？」

### レビューの実践例

#### Before（よくある）

```markdown
**レビューコメント:**
「命名が分かりづらいです。直してください」

**問題点:**
- 具体的な改善点が不明確
- なぜ修正が必要かが説明されていない
- 強制的な口調
```

#### After（シニア）

```markdown
**レビューコメント:**
「この名前だと責務が広く見えます。
将来、ユーザー情報の更新機能も入りそうですが、その想定はありますか？
もし単一の責務に絞るなら、`updateUserEmail`のような名前の方が明確かもしれません。
また、`updateUser`という名前だと、パスワード更新も含まれるように見えますが、
セキュリティ上の理由で分離する想定はありますか？」

**改善点:**
- 将来の影響を指摘
- 質問形式で判断を促す
- 代替案を提示
- 学習を促進
```

### レビューの原則

1. **人ではなく将来を見る**
   - 個人の能力を指摘するのではなく、将来の影響を指摘する

2. **修正ではなく判断を促す**
   - 具体的な修正を強制するのではなく、判断を促す質問をする

3. **強制ではなく選択肢を出す**
   - 1つの正解を押し付けるのではなく、複数の選択肢を提示する

### レビューで使える黄金フレーズ

#### ① トランザクション系

**フレーズ:**
「ここ、どこまでを一貫性の単位として守りたいですか？
失敗した場合、どこまで戻せる前提でしょうか？」

#### ② 冪等・再実行系

**フレーズ:**
「これが二重実行された場合、
"安全に同じ結果になる"設計になっていますか？」

#### ③ UNKNOWN系

**フレーズ:**
「現時点で未確定なのはどこでしょうか？
今回は"決めない"選択肢もありそうですがどうですか？」

#### ④ 将来拡張系

**フレーズ:**
「今は◯◯前提ですが、
もし◯◯が増えたらどこを触る想定ですか？」

#### ⑤ 運用系

**フレーズ:**
「障害時、誰が・どこを見て・どう判断しますか？」

## 設計レビューで論点を作る

### 論点の提示方法

```markdown
## 設計レビュー: 論点の提示

### 論点1: トランザクション境界の設計

**背景:**
注文作成時に在庫減算と支払い処理を同一トランザクションで行うか？

**選択肢:**
1. **同一トランザクション**: データ整合性が高いが、外部API呼び出しが含まれる
2. **Saga パターン**: 分散トランザクションを避けるが、補償トランザクションが必要
3. **イベントソーシング**: イベントで状態を管理、高い拡張性

**推奨:**
Saga パターン（選択肢2）
- 理由: 外部API呼び出しを含むため、分散トランザクションは避けるべき
- トレードオフ: 補償トランザクションの実装が必要

### 論点2: キャッシュ戦略

**背景:**
商品情報のキャッシュをどのように実装するか？

**選択肢:**
1. **Redis**: 高性能だが、追加のインフラが必要
2. **メモリキャッシュ**: シンプルだが、スケーラビリティに制限
3. **CDN**: 静的コンテンツに有効だが、動的コンテンツには不向き

**推奨:**
Redis（選択肢1）
- 理由: スケーラビリティとパフォーマンスのバランス
- トレードオフ: コストと運用の複雑化
```