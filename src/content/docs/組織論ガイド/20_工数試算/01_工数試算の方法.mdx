---
title: "工数試算の方法"
label: "工数試算の方法"
---

## 工数試算の方法

工数試算は、プロジェクトの計画と予算管理において重要な要素です。適切な工数試算により、現実的なスケジュールと予算を設定できます。

### なぜ工数試算が重要なのか

#### 工数試算なしの問題

**問題のある状況:**

```
プロジェクトマネージャー: 「この機能、いつまでにできますか？」
開発者: 「うーん、3日くらいかな...」
（実際には1週間かかった）

// 問題点:
// - 見積もりが不正確
// - スケジュールが遅延
// - 予算が超過
// - ステークホルダーの信頼低下
```

**影響:**
- スケジュールの遅延
- 予算の超過
- チームの負荷増加
- プロジェクトの失敗

#### 工数試算による解決

**改善された状況:**

```
適切な工数試算:
- 見積もりが正確
- スケジュールが守られる
- 予算が管理できる
- ステークホルダーの信頼向上
```

**メリット:**
- 現実的なスケジュール設定
- 適切な予算管理
- リソースの最適配置
- プロジェクトの成功確率向上

### 工数試算の基本概念

#### 工数の定義

**工数とは:**
- **人日（Person-Day）**: 1人が1日で完了できる作業量
- **人時（Person-Hour）**: 1人が1時間で完了できる作業量
- **人月（Person-Month）**: 1人が1ヶ月で完了できる作業量

**実働時間の考慮:**

```
1人日 = 8時間（実働時間）
1人月 = 20人日（営業日ベース）
1人月 = 160時間（20人日 × 8時間）
```

#### 工数の種類

**開発工数:**

```
- 設計: 要件定義、詳細設計
- 実装: コーディング、単体テスト
- テスト: 結合テスト、システムテスト
- デバッグ: バグ修正、リファクタリング
- ドキュメント: 設計書、マニュアル
```

**非開発工数:**

```
- 会議: 定例会議、レビュー会議
- コミュニケーション: メール、チャット
- 学習: 技術調査、勉強会
- その他: 休暇、病欠
```

### 工数試算の方法

#### 1. ボトムアップ見積もり

**定義:**
タスクを細かく分解し、各タスクの工数を見積もって合計する方法です。

**実践例:**

```typescript
// タスクの分解例
interface Task {
  id: string;
  name: string;
  subtasks: Subtask[];
  estimatedHours: number;
}

interface Subtask {
  id: string;
  name: string;
  estimatedHours: number;
}

// 例: ユーザー認証機能の開発
const userAuthTask: Task = {
  id: 'TASK-001',
  name: 'ユーザー認証機能の開発',
  subtasks: [
    { id: 'ST-001', name: 'ログイン画面の実装', estimatedHours: 8 },
    { id: 'ST-002', name: '認証APIの実装', estimatedHours: 16 },
    { id: 'ST-003', name: 'セッション管理の実装', estimatedHours: 8 },
    { id: 'ST-004', name: '単体テストの作成', estimatedHours: 8 },
    { id: 'ST-005', name: '結合テストの実施', estimatedHours: 4 },
    { id: 'ST-006', name: 'バグ修正', estimatedHours: 8 },
  ],
  estimatedHours: 52, // 合計
};

// 人日に変換（1人日 = 8時間）
const estimatedDays = userAuthTask.estimatedHours / 8; // 6.5人日
```

**メリット:**
- 詳細な見積もりが可能
- 各タスクの工数が明確
- 進捗管理が容易

**デメリット:**
- 時間がかかる
- 細かすぎると見積もりが複雑になる

#### 2. トップダウン見積もり

**定義:**
プロジェクト全体の工数を見積もり、それを各タスクに配分する方法です。

**実践例:**

```typescript
// プロジェクト全体の工数見積もり
const projectEstimate = {
  totalDays: 100, // 100人日
  phases: {
    design: 20,      // 設計: 20人日
    development: 50, // 開発: 50人日
    testing: 20,      // テスト: 20人日
    deployment: 10,  // デプロイ: 10人日
  },
};

// 各機能への配分
const featureAllocation = {
  userAuth: 10,      // ユーザー認証: 10人日
  productList: 15,  // 商品一覧: 15人日
  order: 20,         // 注文機能: 20人日
  payment: 15,       // 決済機能: 15人日
  admin: 20,         // 管理画面: 20人日
  other: 20,         // その他: 20人日
};
```

**メリット:**
- 迅速に見積もりが可能
- プロジェクト全体の把握が容易

**デメリット:**
- 詳細な見積もりが困難
- 各タスクの工数が不明確

#### 3. 類推見積もり（アナロジー法）

**定義:**
過去の類似プロジェクトの実績を基に工数を見積もる方法です。

**実践例:**

```typescript
// 過去のプロジェクト実績
const pastProjects = [
  {
    name: 'ECサイト構築（小規模）',
    features: ['商品一覧', 'カート', '決済'],
    actualDays: 60,
  },
  {
    name: 'ECサイト構築（中規模）',
    features: ['商品一覧', 'カート', '決済', '会員管理', '管理画面'],
    actualDays: 120,
  },
];

// 新しいプロジェクトの見積もり
const newProject = {
  name: 'ECサイト構築（新規）',
  features: ['商品一覧', 'カート', '決済', '会員管理'],
  estimatedDays: 90, // 過去の実績を参考に90人日と見積もり
};
```

**メリット:**
- 過去の実績を活用できる
- 比較的迅速に見積もりが可能

**デメリット:**
- 過去の実績データが必要
- プロジェクトの違いを考慮する必要がある

#### 4. 三点見積もり（PERT法）

**定義:**
楽観値、悲観値、最頻値の3つの値から工数を算出する方法です。

**実践例:**

```typescript
interface ThreePointEstimate {
  optimistic: number;  // 楽観値（最良のケース）
  pessimistic: number; // 悲観値（最悪のケース）
  mostLikely: number;  // 最頻値（最も可能性が高い）
}

// PERT式による工数計算
function calculatePERT(estimate: ThreePointEstimate): number {
  // PERT式: (楽観値 + 4 × 最頻値 + 悲観値) / 6
  return (
    (estimate.optimistic + 
     4 * estimate.mostLikely + 
     estimate.pessimistic) / 6
  );
}

// 例: ユーザー認証機能の開発
const userAuthEstimate: ThreePointEstimate = {
  optimistic: 4,    // 4人日（最良のケース）
  pessimistic: 10,  // 10人日（最悪のケース）
  mostLikely: 6,    // 6人日（最も可能性が高い）
};

const estimatedDays = calculatePERT(userAuthEstimate); // 約6.3人日
```

**メリット:**
- 不確実性を考慮できる
- リスクを考慮した見積もりが可能

**デメリット:**
- 3つの値の見積もりが必要
- 計算が複雑

### 工数試算の実践例

#### 機能別の工数見積もり

**ECサイトの例:**

```typescript
interface FeatureEstimate {
  feature: string;
  design: number;      // 設計工数（人日）
  development: number; // 開発工数（人日）
  testing: number;     // テスト工数（人日）
  total: number;       // 合計工数（人日）
}

const featureEstimates: FeatureEstimate[] = [
  {
    feature: 'ユーザー認証',
    design: 1,
    development: 4,
    testing: 1,
    total: 6,
  },
  {
    feature: '商品一覧',
    design: 2,
    development: 6,
    testing: 2,
    total: 10,
  },
  {
    feature: 'カート機能',
    design: 2,
    development: 8,
    testing: 2,
    total: 12,
  },
  {
    feature: '決済機能',
    design: 3,
    development: 12,
    testing: 3,
    total: 18,
  },
  {
    feature: '管理画面',
    design: 3,
    development: 10,
    testing: 2,
    total: 15,
  },
];

// 合計工数の計算
const totalDays = featureEstimates.reduce(
  (sum, feature) => sum + feature.total,
  0
); // 61人日
```

#### フェーズ別の工数見積もり

**プロジェクトフェーズの例:**

```typescript
interface PhaseEstimate {
  phase: string;
  days: number;
  percentage: number; // 全体に対する割合（%）
}

const phaseEstimates: PhaseEstimate[] = [
  {
    phase: '要件定義',
    days: 10,
    percentage: 10,
  },
  {
    phase: '設計',
    days: 20,
    percentage: 20,
  },
  {
    phase: '開発',
    days: 50,
    percentage: 50,
  },
  {
    phase: 'テスト',
    days: 15,
    percentage: 15,
  },
  {
    phase: 'デプロイ・運用',
    days: 5,
    percentage: 5,
  },
];

const totalDays = phaseEstimates.reduce(
  (sum, phase) => sum + phase.days,
  0
); // 100人日
```

### 工数試算の調整

#### バッファの考慮

**バッファの種類:**

```typescript
interface EstimateWithBuffer {
  baseEstimate: number;  // 基本見積もり
  buffer: number;        // バッファ（%）
  totalEstimate: number; // 合計見積もり
}

// 例: 10%のバッファを追加
const estimate: EstimateWithBuffer = {
  baseEstimate: 100,     // 基本見積もり: 100人日
  buffer: 10,            // バッファ: 10%
  totalEstimate: 110,    // 合計見積もり: 110人日
};

// バッファの計算
function addBuffer(baseEstimate: number, bufferPercent: number): number {
  return baseEstimate * (1 + bufferPercent / 100);
}
```

**バッファの設定指針:**

| プロジェクトの複雑さ | 推奨バッファ |
|-------------------|------------|
| 低 | 5-10% |
| 中 | 10-20% |
| 高 | 20-30% |

#### リスクの考慮

**リスク要因:**

```typescript
interface RiskFactor {
  factor: string;
  impact: number;  // 影響度（1-5）
  probability: number; // 発生確率（0-1）
  riskScore: number;   // リスクスコア（影響度 × 発生確率）
}

const riskFactors: RiskFactor[] = [
  {
    factor: '新技術の採用',
    impact: 4,
    probability: 0.3,
    riskScore: 1.2,
  },
  {
    factor: '要件の変更',
    impact: 3,
    probability: 0.5,
    riskScore: 1.5,
  },
  {
    factor: 'リソースの不足',
    impact: 5,
    probability: 0.2,
    riskScore: 1.0,
  },
];

// リスクを考慮した工数調整
function adjustForRisk(baseEstimate: number, riskScore: number): number {
  return baseEstimate * (1 + riskScore / 10);
}
```

### 工数試算のベストプラクティス

#### 1. 過去の実績データの活用

```typescript
// 過去の実績データを記録
interface HistoricalData {
  project: string;
  feature: string;
  estimatedDays: number;
  actualDays: number;
  variance: number; // 差異（%）
}

// 実績データを基に調整係数を計算
function calculateAdjustmentFactor(
  historicalData: HistoricalData[]
): number {
  const totalVariance = historicalData.reduce(
    (sum, data) => sum + data.variance,
    0
  );
  return totalVariance / historicalData.length;
}
```

#### 2. 段階的な見積もり

```typescript
// 初期見積もり（粗い見積もり）
const initialEstimate = {
  phase: '要件定義前',
  accuracy: '±50%',
  estimate: 100,
};

// 詳細見積もり（要件定義後）
const detailedEstimate = {
  phase: '要件定義後',
  accuracy: '±20%',
  estimate: 120,
};

// 最終見積もり（設計完了後）
const finalEstimate = {
  phase: '設計完了後',
  accuracy: '±10%',
  estimate: 115,
};
```

#### 3. チームの経験レベルを考慮

```typescript
interface TeamMember {
  name: string;
  experience: 'junior' | 'middle' | 'senior';
  productivity: number; // 生産性係数（1.0が標準）
}

const teamMembers: TeamMember[] = [
  { name: '田中', experience: 'senior', productivity: 1.2 },
  { name: '佐藤', experience: 'middle', productivity: 1.0 },
  { name: '鈴木', experience: 'junior', productivity: 0.8 },
];

// チームの平均生産性を計算
const averageProductivity = teamMembers.reduce(
  (sum, member) => sum + member.productivity,
  0
) / teamMembers.length;

// 生産性を考慮した工数調整
function adjustForProductivity(
  baseEstimate: number,
  productivity: number
): number {
  return baseEstimate / productivity;
}
```

### まとめ

工数試算の方法のポイント：

- **工数の定義**: 人日、人時、人月、実働時間の考慮
- **工数試算の方法**: ボトムアップ、トップダウン、類推見積もり、三点見積もり
- **実践例**: 機能別、フェーズ別の工数見積もり
- **調整**: バッファの考慮、リスクの考慮
- **ベストプラクティス**: 過去の実績データの活用、段階的な見積もり、チームの経験レベルを考慮

適切に工数試算を行うことで、現実的なスケジュールと予算を設定し、プロジェクトの成功確率を向上させることができます。

