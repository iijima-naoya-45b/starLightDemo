---
title: "CSR・SSR"
label: "CSR・SSR"
---

## 🔄 レンダリングの比較: CSR vs. SSR

Webページのレンダリング方法には主に2つのアプローチがあります。Next.jsは、これら両方の利点を組み合わせることで、高速なパフォーマンスと優れた開発体験を提供します。

### 1. クライアントサイドレンダリング (CSR) 🖥️

CSRは、レンダリングをブラウザに任せる方式です。サーバーは最低限のHTMLとJavaScriptを送信し、データ取得やDOM構築はすべてクライアント（ブラウザ）で行われます。

- **仕組み**: 最初に空のHTMLとJavaScriptの「シェル」が送られます。ブラウザはJavaScriptを実行し、APIからデータをフェッチして動的にコンテンツを生成します。

- **利点**:
  - 高速なページ遷移: 初回ロード後は、必要なデータだけをAPIで取得し、DOMを部分的に更新するため、ページ間の移動が非常に滑らかです。
  - インタラクティブ: ユーザーの操作に応じて動的に変化するUI（例：フォーム入力、グラフ）の実装に適しています。

- **欠点**:
  - 初回表示までの遅延: JavaScriptとデータがすべてロードされるまで、ユーザーは何も表示されない「白い画面」を見ることになります。
  - SEOへの影響: 検索エンジンのクローラーが初期に完全なコンテンツを取得できないため、SEOのパフォーマンスに影響する可能性があります。

### 2. サーバーサイドレンダリング (SSR) 💻

SSRは、レンダリングをサーバーで行う方式です。

- **仕組み**: ユーザーからのリクエストに対して、サーバーがデータを取得し、完成したHTMLを生成してブラウザに送信します。ブラウザは受け取ったHTMLをすぐに表示し、その後、JavaScriptがロードされてインタラクティブな機能が追加されます（これをハイドレーションと呼びます）。

- **利点**:
  - 高速な初回表示: ユーザーはすぐにコンテンツを見ることができ、ユーザー体験が向上します。
  - 優れたSEO: 検索エンジンのクローラーは完成したHTMLを受け取るため、コンテンツを正確にインデックスできます。

- **欠点**:
  - サーバー負荷: リクエストごとにサーバーがHTMLを生成するため、アクセス数が増えるとサーバーの負荷が高まります。
  - ページ遷移: ページを移動するたびにサーバーが新しいHTMLを生成するため、CSRに比べると遷移が遅く感じることがあります。

### 3. Next.jsにおけるハイブリッドレンダリング 🧩

Next.jsの最新のApp Routerは、これらのレンダリング方法を組み合わせて利用するハイブリッドレンダリングを標準としています。

- **サーバーコンポーネント (SSR)**: デフォルトでは、すべてのコンポーネントがサーバーでレンダリングされます。これにより、ページの大部分は高速に表示され、SEOに有利な状態が保たれます。

- **クライアントコンポーネント (CSR)**: ユーザーインタラクションが必要なコンポーネントのみを'use client'ディレクティブでクライアントコンポーネントとしてマークします。これにより、フォーム、アニメーション、状態管理が必要な部分だけがCSRとして動作し、パフォーマンスとユーザー体験を両立させます。

このハイブリッドアプローチにより、開発者はページ全体をCSRにするかSSRにするかという二者択一から解放され、より効率的でパフォーマンスに優れたアプリケーションを構築できます。

## 🔄 CSRとSSRのレンダリングフローを比較する図解

クライアントサイドレンダリング（CSR）とサーバーサイドレンダリング（SSR）の主な違いは、誰がいつ、ページのコンテンツを生成するかです。この違いは、ページの表示速度、SEO、そしてサーバー負荷に影響します。Next.jsは、この両方のメリットを活かすハイブリッドレンダリングで、これらの問題を解決します。

### 1. クライアントサイドレンダリング (CSR) 🖥️

CSRでは、レンダリングの大部分をブラウザが担当します。サーバーは最小限のHTMLとJavaScriptの**「骨組み」**だけを送り、ブラウザがAPIからデータを取得してページを構築します。

- **レンダリングフロー**:
  1. ユーザーがリクエストを送る。
  2. サーバーは空のHTMLとJavaScriptを送り返す。
  3. ブラウザはHTMLを表示する。この時点ではまだコンテンツは表示されない。
  4. ブラウザがJavaScriptをダウンロードし、実行を開始。
  5. ブラウザはAPIからデータを取得する。
  6. ブラウザが取得したデータを使ってDOMを構築し、ページにコンテンツが表示される。

### 2. サーバーサイドレンダリング (SSR) 💻

SSRでは、レンダリングをサーバーが担当します。サーバーがデータを取得し、完全にレンダリングされたHTMLをブラウザに送り返します。

- **レンダリングフロー**:
  1. ユーザーがリクエストを送る。
  2. サーバーはページに必要なデータを取得し、完全にレンダリングされたHTMLを生成する。
  3. サーバーはそのHTMLをブラウザに送り返す。
  4. ブラウザはHTMLをすぐに表示する。この時点でコンテンツは見える状態になっている。
  5. ブラウザがJavaScriptをダウンロードし、実行を開始（ハイドレーション）。これにより、ボタンのクリックなど、インタラクティブな機能が有効になる。

### 3. Next.jsのハイブリッドレンダリング 🧩

Next.jsは、CSRとSSRの長所を組み合わせることで、ハイブリッドレンダリングという最適なアプローチを提供します。

- **サーバーコンポーネント (SSR)**: デフォルトでサーバーサイドレンダリングが行われます。これにより、初回ロードが速くなり、SEOに強くなります。

- **クライアントコンポーネント (CSR)**: `use client`ディレクティブを使うことで、一部のコンポーネントだけをCSRとしてレンダリングできます。これにより、フォームやアニメーションなど、インタラクティブな要素を持つ部分だけをクライアントで動かし、不必要なサーバー負荷を軽減します。

このハイブリッドなアプローチによって、Next.jsはパフォーマンスとユーザー体験を高いレベルで両立させています。

## 🔄 CSRとSSRの使い分け：具体的なシナリオ

Next.jsのハイブリッドレンダリングは強力ですが、ページのどの部分をCSRにするか、SSRにするかを見極めることが重要です。一般的なアプリケーションの機能ごとに、最適なレンダリング方法を以下に示します。

### 1. サーバーサイドレンダリング（SSR）が最適なシーン 💻

SSRは、コンテンツが静的または頻繁に更新されるが、リアルタイム性は不要なページに最適です。

- **ブログ記事やニュースサイト**:
  - **理由**: 記事の内容は頻繁に変わりますが、すべてのユーザーに対して同じコンテンツを表示するため、リクエストごとにサーバーでレンダリングすることでSEOに強くなります。
  - **実装**: `app/blog/[slug]/page.tsx` のようなサーバーコンポーネントで記事データをフェッチし、HTMLを生成します。

- **ECサイトの商品詳細ページ**:
  - **理由**: 商品情報（価格、在庫、説明）は常に最新である必要がありますが、SEOも重要です。クローラーが商品ページを正しくインデックスできるように、サーバーでレンダリングします。
  - **実装**: `app/products/[id]/page.tsx`で商品IDを基にデータを取得し、ページをレンダリングします。

- **プロフィールページやダッシュボードの初期表示**:
  - **理由**: ユーザーがログインした後に最初に表示されるページは、認証情報に基づいてデータをサーバーで取得し、高速に表示させるのが良いでしょう。
  - **実装**: ユーザーのトークンをCookieから読み取り、`app/dashboard/page.tsx`のようなサーバーコンポーネントでユーザー情報をフェッチします。

### 2. クライアントサイドレンダリング（CSR）が最適なシーン 🖥️

CSRは、ユーザーの操作に強く依存するインタラクティブなUIや、リアルタイム性が求められるコンポーネントに最適です。

- **フォーム、モーダル、アニメーション**:
  - **理由**: これらのUI要素は、ユーザーの入力やクリックに応じて動的に変化するため、JavaScriptによるクライアントサイドでの制御が必要です。
  - **実装**: `app/form.tsx`のようなファイルで、'use client'ディレクティブを宣言し、`useState`や`useEffect`などのクライアントサイドのフックを使用します。

- **検索フィルター、ソート機能**:
  - **理由**: ユーザーが検索ボックスに文字を入力するたびに、サーバーにリクエストを送るのは非効率です。クライアントサイドで状態を管理し、APIリクエストを最適化する方が良いです。
  - **実装**: `app/search.tsx`のようなクライアントコンポーネントで、検索クエリの状態を管理し、ユーザーの入力に応じてリアルタイムで結果を表示します。

- **リアルタイムなデータ表示**:
  - **理由**: 株価チャートやライブチャットなど、継続的にサーバーと通信してデータを更新する必要がある場合は、WebSocket通信やポーリングをクライアントコンポーネントで実装します。
  - **実装**: 状態管理ライブラリ（Zustandなど）と組み合わせて、`use client`で宣言したコンポーネントでリアルタイムデータを扱います。

### 3. ハイブリッドレンダリングの実践 🧩

Next.jsでは、CSRとSSRを同じページで組み合わせることができます。

- **ECサイトの商品詳細ページ**:
  - **全体**: 商品情報（名前、価格、説明）は**サーバーコンポーネント（SSR）**でレンダリングし、高速な初回表示とSEOを確保します。
  - **インタラクティブな部分**: 「カートに追加」ボタンや、ユーザーレビューの星評価コンポーネントは、'use client'を宣言した**クライアントコンポーネント（CSR）**として実装します。これにより、JavaScriptがロードされた後、これらの要素がインタラクティブになります。

このように、Next.jsは「初期表示とSEO」にはSSR、「ユーザーインタラクション」にはCSRを使い分けることで、最高のパフォーマンスと開発体験を実現します。

## 🔄 CSRとSSRの使い分け：具体的な実装例

Next.jsにおけるハイブリッドレンダリングの真価は、1つのページ内でサーバーコンポーネント（SSR）とクライアントコンポーネント（CSR）を組み合わせて使う点にあります。ここでは、その具体的なコード例として、ECサイトの商品詳細ページを題材に解説します。

### 1. サーバーコンポーネント（SSR）: 商品情報の表示 💻

このコンポーネントはサーバーでレンダリングされ、SEOに有利な状態でユーザーに届きます。ここでは、データをフェッチし、静的なUIを生成する役割を担います。

- **役割**: ユーザーリクエスト時に、URLのidから商品データを取得し、HTMLを生成する。
- **使用例**: 商品名、価格、説明、画像など。

```typescript
// app/products/[id]/page.tsx
// このファイルはデフォルトでサーバーコンポーネントです

import AddToCartButton from '@/components/AddToCartButton';

// サーバーコンポーネント内で直接データを取得
async function getProduct(id: string) {
  const res = await fetch(`https://api.example.com/products/${id}`);
  return res.json();
}

export default async function ProductPage({ params }: { params: { id: string } }) {
  const product = await getProduct(params.id);

  return (
    <div className="container">
      {/* SEOに重要な部分をSSRでレンダリング */}
      <h1 className="text-3xl font-bold">{product.name}</h1>
      <p className="text-2xl">${product.price}</p>
      <img src={product.image_url} alt={product.name} />
      <p>{product.description}</p>

      {/* インタラクティブな部分はクライアントコンポーネントに任せる */}
      <AddToCartButton productId={product.id} />
    </div>
  );
}
```

このProductPageは、サーバーでレンダリングされるため、初回のロードが非常に速く、検索エンジンがコンテンツを正確に読み取ることができます。

### 2. クライアントコンポーネント（CSR）: 「カートに追加」ボタン 🛒

このコンポーネントは'use client'ディレクティブを持つため、ブラウザでレンダリングされます。ユーザーの操作に応じた状態変更やAPI呼び出しを扱います。

- **役割**: ユーザーのクリックイベントを処理し、カートの状態を更新する。
- **使用例**: カウントアップ、カートへの商品追加、モーダル表示など。

```typescript
// components/AddToCartButton.tsx
'use client';

import { useState } from 'react';

export default function AddToCartButton({ productId }: { productId: string }) {
  const [isAdding, setIsAdding] = useState(false);

  const handleAddToCart = async () => {
    setIsAdding(true);
    // APIルートを呼び出し、カートに商品を追加
    await fetch('/api/cart', {
      method: 'POST',
      body: JSON.stringify({ productId }),
    });
    setIsAdding(false);
  };

  return (
    <button
      onClick={handleAddToCart}
      disabled={isAdding}
      className="bg-green-500 text-white p-2 rounded"
    >
      {isAdding ? '追加中...' : 'カートに追加'}
    </button>
  );
}
```

このAddToCartButtonは、useStateフックを使用しているため、必ずクライアントで実行される必要があります。親のサーバーコンポーネントからpropsとしてproductIdを受け取り、その情報を使ってAPIを呼び出します。

## まとめ：ハイブリッドレンダリングの利点

この実装例では、**ページのコアコンテンツ（SSR）とインタラクティブな機能（CSR）**が明確に分離されています。これにより、以下のメリットが生まれます。

- **パフォーマンス**: 初期ロードが速くなり、ユーザーはすぐに商品情報を見ることができます。
- **開発体験**: サーバーとクライアントのロジックが分離されるため、コードの見通しが良くなります。
- **SEO**: サーバーで生成されたHTMLにより、検索エンジンがページを正しくインデックスできます。

Next.jsは、このハイブリッドなアプローチによって、ウェブ開発のベストプラクティスを簡単に適用できるようにしています。

Next.jsにおけるハイブリッドレンダリングは、**サーバーサイドレンダリング（SSR）とクライアントサイドレンダリング（CSR）**の長所を組み合わせることで、ウェブページのパフォーマンスとユーザー体験を最適化する強力なアプローチです。この戦略では、SEOに重要な静的コンテンツを高速に表示し、ユーザーインタラクションが必要な部分だけを動的にロードします。

### 1. サーバーコンポーネント (SSR) の役割

サーバーコンポーネントは、レンダリングをサーバー上で行うため、データの取得からHTMLの生成までを単一のリクエスト内で完結させます。これにより、ブラウザに渡されるのは完全にレンダリングされたHTMLとなり、ユーザーはすぐにコンテンツを見ることができます。これは、ブログ記事やECサイトの商品詳細ページのように、SEOが重要で、かつ初回表示が速いことが求められるページに最適です。

- **提供されたコード例**では、`app/products/[id]/page.tsx`がサーバーコンポーネントとして機能しています。
- `getProduct(id)`関数は、サーバーサイドで直接外部APIを呼び出し、商品データを取得します。
- このデータは、`<h1>`や`<img>`タグなどのHTML要素に直接埋め込まれてレンダリングされます。
- このプロセスはクライアントサイドのJavaScriptに依存しないため、初回表示が非常に高速になり、検索エンジンのクローラーもコンテンツを正確に読み取ることができます。

### 2. クライアントコンポーネント (CSR) の役割

クライアントコンポーネントは、ブラウザでレンダリングされ、ユーザーの操作に応じて動的に動作する部分を担います。'use client'ディレクティブで明示的に宣言し、`useState`や`useEffect`といったReactのフックを利用できます。これにより、フォームの入力、ボタンのクリック、リアルタイムなデータの更新など、インタラクティブな機能を実現します。

- **提供されたコード例**では、`components/AddToCartButton.tsx`がクライアントコンポーネントです。
- `'use client'`ディレクティブが宣言されているため、このコンポーネントとその子孫コンポーネントはクライアントでレンダリングされます。
- `useState`フックを使ってボタンの状態（例：isAdding）を管理し、ユーザーのクリックイベントに応じてUIを更新します。
- `fetch` APIを使い、非同期でサーバーのAPIルート（`/api/cart`）を呼び出してカートに商品を追加するロジックが含まれています。

### 3. ハイブリッドレンダリングの実践例 🧩

ECサイトの商品詳細ページは、ハイブリッドレンダリングの理想的な例です。

- **SSR部分**: 商品名、価格、説明、画像といった静的かつSEOに重要な情報は、サーバーコンポーネントでレンダリングされます。
- **CSR部分**: 「カートに追加」ボタンのように、ユーザーの操作に応じて状態が変化する部分は、クライアントコンポーネントとして分離されます。

この分離により、Next.jsはページの「表示」と「インタラクション」を明確に分け、それぞれの最適な環境で実行します。ユーザーはすぐにコンテンツを見ることができ、その後にJavaScriptがロードされてインタラクティブな機能が有効になるため、パフォーマンスとユーザビリティの両方が向上します。

このアプローチは、Next.jsが現代のウェブ開発における多くの課題（SEO、初回ロード速度、ユーザー体験）を解決するための核心的な戦略と言えます。
