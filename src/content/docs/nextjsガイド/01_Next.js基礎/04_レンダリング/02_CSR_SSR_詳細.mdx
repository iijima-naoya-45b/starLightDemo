---
title: "CSR・SSR詳細"
label: "CSR・SSR詳細"
---

## Next.jsのレンダリング戦略詳細

Next.jsは、複数のレンダリング戦略を提供しており、それぞれに異なる特徴とユースケースがあります。このガイドでは、各戦略の詳細な仕組み、実装方法、そして実務での使い分けについて詳しく解説します。

## レンダリング戦略の種類

Next.jsで利用可能なレンダリング戦略は以下の通りです：

| 戦略 | 略称 | レンダリングタイミング | 特徴 |
|------|------|----------------------|------|
| **Client-Side Rendering** | CSR | ブラウザ（クライアント） | インタラクティブ、SEOに弱い |
| **Server-Side Rendering** | SSR | サーバー（リクエスト時） | SEOに強い、サーバー負荷あり |
| **Static Site Generation** | SSG | ビルド時 | 最速、SEOに強い、動的コンテンツ不可 |
| **Incremental Static Regeneration** | ISR | ビルド時 + 再生成 | SSG + 動的更新 |

## Client-Side Rendering (CSR)

CSRは、レンダリングをブラウザに任せる方式です。サーバーは最低限のHTMLとJavaScriptを送信し、データ取得やDOM構築はすべてクライアント（ブラウザ）で行われます。

### CSRの仕組み

```typescript
// CSRのレンダリングフロー
// 1. サーバーが空のHTMLとJavaScriptを送信
// 2. ブラウザがJavaScriptをダウンロード・実行
// 3. JavaScriptがAPIからデータを取得
// 4. データを使ってDOMを構築
```

**実装例:**

```typescript
// app/products/page.tsx
'use client';

import { useState, useEffect } from 'react';

export default function ProductsPage() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // クライアントサイドでデータを取得
    fetch('/api/products')
      .then(res => res.json())
      .then(data => {
        setProducts(data);
        setLoading(false);
      });
  }, []);

  if (loading) {
    return <div>読み込み中...</div>;
  }

  return (
    <div>
      {products.map(product => (
        <div key={product.id}>
          <h2>{product.name}</h2>
          <p>{product.price}</p>
        </div>
      ))}
    </div>
  );
}
```

### CSRの利点と欠点

**利点:**

- **高速なページ遷移**: 初回ロード後は、必要なデータだけをAPIで取得し、DOMを部分的に更新するため、ページ間の移動が非常に滑らか
- **インタラクティブ**: ユーザーの操作に応じて動的に変化するUI（例：フォーム入力、グラフ）の実装に適している
- **サーバー負荷が少ない**: サーバーは静的なファイルを配信するだけなので、負荷が少ない

**欠点:**

- **初回表示までの遅延**: JavaScriptとデータがすべてロードされるまで、ユーザーは何も表示されない「白い画面」を見ることになる
- **SEOへの影響**: 検索エンジンのクローラーが初期に完全なコンテンツを取得できないため、SEOのパフォーマンスに影響する可能性がある
- **パフォーマンス指標への影響**: FCP (First Contentful Paint) や LCP (Largest Contentful Paint) が遅くなる

### CSRが適しているケース

```typescript
// ✅ CSRが適しているケース

// 1. 管理画面やダッシュボード（SEO不要）
'use client';
export default function AdminDashboard() {
  const [data, setData] = useState(null);
  // ...
}

// 2. リアルタイムなデータ表示（WebSocket使用）
'use client';
export default function LiveChart() {
  const [prices, setPrices] = useState([]);
  useEffect(() => {
    const ws = new WebSocket('wss://api.example.com/prices');
    ws.onmessage = (event) => {
      setPrices(JSON.parse(event.data));
    };
  }, []);
  // ...
}

// 3. インタラクティブなフォーム
'use client';
export default function ContactForm() {
  const [formData, setFormData] = useState({});
  // リアルタイムバリデーションなど
  // ...
}
```

## Server-Side Rendering (SSR)

SSRは、レンダリングをサーバーで行う方式です。ユーザーからのリクエストに対して、サーバーがデータを取得し、完成したHTMLを生成してブラウザに送信します。

### SSRの仕組み

```typescript
// SSRのレンダリングフロー
// 1. ユーザーがリクエストを送る
// 2. サーバーがデータを取得し、HTMLを生成
// 3. サーバーが完成したHTMLをブラウザに送信
// 4. ブラウザがHTMLをすぐに表示
// 5. JavaScriptがロードされ、ハイドレーションが実行される
```

**実装例（App Router）:**

```typescript
// app/products/[id]/page.tsx
// デフォルトでサーバーコンポーネント（SSR）

async function getProduct(id: string) {
  // サーバーサイドでデータを取得
  const res = await fetch(`https://api.example.com/products/${id}`, {
    cache: 'no-store', // SSRの場合はキャッシュしない
  });
  return res.json();
}

export default async function ProductPage({ params }: { params: { id: string } }) {
  const product = await getProduct(params.id);

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.price}</p>
      <p>{product.description}</p>
    </div>
  );
}
```

**実装例（Pages Router）:**

```typescript
// pages/products/[id].tsx
import { GetServerSideProps } from 'next';

type ProductPageProps = {
  product: {
    id: string;
    name: string;
    price: number;
    description: string;
  };
};

export default function ProductPage({ product }: ProductPageProps) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.price}</p>
      <p>{product.description}</p>
    </div>
  );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { id } = context.params!;
  
  const product = await fetch(`https://api.example.com/products/${id}`)
    .then(res => res.json());
  
  return {
    props: {
      product,
    },
  };
};
```

### SSRの利点と欠点

**利点:**

- **高速な初回表示**: ユーザーはすぐにコンテンツを見ることができ、ユーザー体験が向上する
- **優れたSEO**: 検索エンジンのクローラーは完成したHTMLを受け取るため、コンテンツを正確にインデックスできる
- **最新データの表示**: リクエストごとにデータを取得するため、常に最新のデータを表示できる

**欠点:**

- **サーバー負荷**: リクエストごとにサーバーがHTMLを生成するため、アクセス数が増えるとサーバーの負荷が高まる
- **ページ遷移の遅延**: ページを移動するたびにサーバーが新しいHTMLを生成するため、CSRに比べると遷移が遅く感じることがある
- **TTFB (Time to First Byte) の増加**: サーバーでHTMLを生成する時間がかかるため、TTFBが増加する

### SSRが適しているケース

```typescript
// ✅ SSRが適しているケース

// 1. SEOが重要なページ（ブログ、ECサイト）
export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug);
  return <Article post={post} />;
}

// 2. ユーザー固有のデータを表示するページ
export default async function Dashboard() {
  const user = await getCurrentUser();
  const data = await getUserData(user.id);
  return <DashboardContent data={data} />;
}

// 3. 頻繁に更新されるコンテンツ
export default async function NewsPage() {
  const news = await fetch('https://api.example.com/news', {
    cache: 'no-store', // 常に最新のデータを取得
  }).then(res => res.json());
  
  return <NewsList news={news} />;
}
```

## Static Site Generation (SSG)

SSGは、ビルド時にページを事前にレンダリングし、CDNにデプロイすることで、ユーザーからのリクエストに対して静的なHTMLファイルを直接提供するアプローチです。

### SSGの仕組み

```typescript
// SSGのレンダリングフロー
// 1. ビルド時にすべてのページをレンダリング
// 2. 静的なHTMLファイルを生成
// 3. CDNにデプロイ
// 4. ユーザーがリクエストを送る
// 5. CDNから静的なHTMLを直接配信
```

**実装例（App Router）:**

```typescript
// app/blog/[slug]/page.tsx

// ビルド時に生成するパスを定義
export async function generateStaticParams() {
  const posts = await getPosts();
  return posts.map(post => ({
    slug: post.slug,
  }));
}

// 静的ページとして生成
export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}
```

**実装例（Pages Router）:**

```typescript
// pages/blog/[slug].tsx
import { GetStaticProps, GetStaticPaths } from 'next';

export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await getPosts();
  
  return {
    paths: posts.map(post => ({
      params: { slug: post.slug },
    })),
    fallback: false, // 404を返す
  };
};

export const getStaticProps: GetStaticProps = async (context) => {
  const { slug } = context.params!;
  const post = await getPost(slug);
  
  return {
    props: {
      post,
    },
  };
};
```

### SSGの利点と欠点

**利点:**

- **極めて高速な表示**: ユーザーはサーバーにリクエストを送る必要がなく、CDNから直接HTMLを受け取るため、非常に高速
- **サーバー負荷なし**: ページはビルド時に一度だけ生成されるため、トラフィックの増加がサーバーに影響を与えない
- **優れたSEO**: SSRと同様に、クローラーは完全にレンダリングされたHTMLを受け取る
- **コスト削減**: サーバーリソースが不要なため、コストを削減できる

**欠点:**

- **動的コンテンツの制限**: ビルド時に生成されるため、リクエストごとに異なるコンテンツを表示できない
- **再ビルドが必要**: コンテンツが更新された場合、再ビルドと再デプロイが必要
- **ビルド時間の増加**: ページ数が増えると、ビルド時間が長くなる

### SSGが適しているケース

```typescript
// ✅ SSGが適しているケース

// 1. ブログやドキュメントサイト（更新頻度が低い）
export async function generateStaticParams() {
  const posts = await getPosts();
  return posts.map(post => ({ slug: post.slug }));
}

// 2. ランディングページ（静的コンテンツ）
export default function LandingPage() {
  return (
    <div>
      <h1>ようこそ</h1>
      <p>私たちについて</p>
    </div>
  );
}

// 3. ポートフォリオサイト
export default function Portfolio() {
  const projects = getProjects(); // ビルド時に取得
  return <ProjectList projects={projects} />;
}
```

## Incremental Static Regeneration (ISR)

ISRは、SSGとSSRの中間的なアプローチです。ビルド時にページを生成しますが、指定した時間間隔で再生成することで、動的なコンテンツにも対応できます。

### ISRの仕組み

```typescript
// ISRのレンダリングフロー
// 1. ビルド時にページを生成（SSG）
// 2. ユーザーがリクエストを送る
// 3. CDNから静的なHTMLを配信
// 4. 再生成の時間が経過した場合、バックグラウンドで再生成
// 5. 次のリクエストから新しいHTMLを配信
```

**実装例（App Router）:**

```typescript
// app/products/[id]/page.tsx

export const revalidate = 3600; // 1時間ごとに再生成

export default async function ProductPage({ params }: { params: { id: string } }) {
  const product = await fetch(`https://api.example.com/products/${params.id}`, {
    next: { revalidate: 3600 }, // 1時間キャッシュ
  }).then(res => res.json());

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.price}</p>
    </div>
  );
}
```

**実装例（Pages Router）:**

```typescript
// pages/products/[id].tsx

export const getStaticProps: GetStaticProps = async (context) => {
  const { id } = context.params!;
  const product = await getProduct(id);
  
  return {
    props: {
      product,
    },
    revalidate: 3600, // 1時間ごとに再生成
  };
};
```

### ISRの利点と欠点

**利点:**

- **SSGの利点を維持**: 高速な表示とサーバー負荷の軽減
- **動的コンテンツに対応**: 指定した時間間隔で再生成することで、動的なコンテンツにも対応
- **段階的な再生成**: すべてのページを再生成する必要がなく、必要なページだけを再生成できる

**欠点:**

- **再生成の遅延**: 再生成の時間が経過するまで、古いコンテンツが表示される可能性がある
- **複雑さ**: SSGやSSRに比べて、設定が複雑になる

### ISRが適しているケース

```typescript
// ✅ ISRが適しているケース

// 1. ECサイトの商品ページ（更新頻度が中程度）
export const revalidate = 3600; // 1時間ごとに再生成

// 2. ブログのトップページ（最新記事を表示）
export const revalidate = 1800; // 30分ごとに再生成

// 3. ニュースサイト（頻繁に更新されるが、リアルタイム性は不要）
export const revalidate = 600; // 10分ごとに再生成
```

## ハイブリッドレンダリング

Next.jsのApp Routerは、これらのレンダリング方法を組み合わせて利用するハイブリッドレンダリングを標準としています。

### サーバーコンポーネントとクライアントコンポーネント

```typescript
// app/products/[id]/page.tsx
// デフォルトでサーバーコンポーネント（SSR）

import AddToCartButton from '@/components/AddToCartButton';

async function getProduct(id: string) {
  const res = await fetch(`https://api.example.com/products/${id}`, {
    cache: 'no-store', // SSR
  });
  return res.json();
}

export default async function ProductPage({ params }: { params: { id: string } }) {
  const product = await getProduct(params.id);

  return (
    <div>
      {/* サーバーコンポーネントでレンダリング（SSR） */}
      <h1>{product.name}</h1>
      <p>{product.price}</p>
      <p>{product.description}</p>

      {/* クライアントコンポーネント（CSR） */}
      <AddToCartButton productId={product.id} />
    </div>
  );
}
```

```typescript
// components/AddToCartButton.tsx
'use client'; // クライアントコンポーネントとして宣言

import { useState } from 'react';

export default function AddToCartButton({ productId }: { productId: string }) {
  const [isAdding, setIsAdding] = useState(false);

  const handleAddToCart = async () => {
    setIsAdding(true);
    await fetch('/api/cart', {
      method: 'POST',
      body: JSON.stringify({ productId }),
    });
    setIsAdding(false);
  };

  return (
    <button
      onClick={handleAddToCart}
      disabled={isAdding}
    >
      {isAdding ? '追加中...' : 'カートに追加'}
    </button>
  );
}
```

### ハイブリッドレンダリングの利点

- **パフォーマンス**: 初期ロードが速く、SEOに有利
- **開発体験**: サーバーとクライアントのロジックが分離され、コードの見通しが良くなる
- **柔軟性**: ページごとに最適なレンダリング戦略を選択できる

## レンダリング戦略の選択判断

### 判断フレームワーク

```typescript
// 判断基準1: コンテンツの更新頻度
// 静的コンテンツ → SSG
export async function generateStaticParams() {
  const posts = await getPosts();
  return posts.map(post => ({ slug: post.slug }));
}

// 動的コンテンツ → SSR
export default async function Page() {
  const data = await fetch('https://api.example.com/data', {
    cache: 'no-store' // SSR
  });
  return <div>{data.title}</div>;
}

// 中程度の更新頻度 → ISR
export const revalidate = 3600; // 1時間ごとに再生成

// 判断基準2: ユーザー固有かどうか
// ユーザー固有 → SSR
export default async function Dashboard() {
  const user = await getCurrentUser();
  const data = await getUserData(user.id);
  return <Dashboard data={data} />;
}

// 全ユーザー共通 → SSG / ISR
export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug);
  return <Article post={post} />;
}

// 判断基準3: SEOの重要性
// SEO重要 → SSR / SSG
export default async function ProductPage({ params }: { params: { id: string } }) {
  const product = await getProduct(params.id);
  return <ProductDetails product={product} />;
}

// SEO不要 → CSR
'use client';
export default function AdminPanel() {
  const [data, setData] = useState(null);
  useEffect(() => {
    fetchData().then(setData);
  }, []);
  return <AdminContent data={data} />;
}
```

### 実践的な判断基準

| 要件 | 推奨戦略 | 理由 |
|------|---------|------|
| SEOが重要 | SSR / SSG | 検索エンジンがコンテンツを認識できる |
| 初回表示速度が重要 | SSG / ISR | CDNから直接配信されるため最速 |
| ユーザー固有のデータ | SSR | リクエストごとにデータを取得 |
| リアルタイム性が必要 | CSR | クライアントサイドで動的に更新 |
| 更新頻度が低い | SSG | ビルド時に生成すれば十分 |
| 更新頻度が中程度 | ISR | 定期的に再生成することで対応 |
| 更新頻度が高い | SSR | 常に最新のデータを表示 |

## パフォーマンスへの影響

### レンダリング戦略によるパフォーマンス指標の違い

```typescript
// CSRの問題: 初期表示までの時間
// 1. HTMLのダウンロード: 50ms
// 2. JavaScriptのダウンロード: 200ms
// 3. JavaScriptの実行: 100ms
// 4. API呼び出し: 300ms
// 5. DOMの構築: 50ms
// 合計: 700ms（この間、ユーザーは白い画面を見る）

// SSRの利点: 即座にコンテンツが表示される
// 1. HTMLのダウンロード: 50ms（コンテンツが含まれている）
// 2. JavaScriptのダウンロード: 200ms（並行実行）
// 3. ハイドレーション: 100ms
// 合計: 350ms（ユーザーはすぐにコンテンツを見られる）

// SSGの利点: 最速の表示
// 1. HTMLのダウンロード: 10ms（CDNから直接配信）
// 合計: 10ms（最も高速）

// 実際のパフォーマンス指標への影響
// CSR: FCP (First Contentful Paint) = 700ms
// SSR: FCP = 50ms（約14倍の改善）
// SSG: FCP = 10ms（約70倍の改善）
```

### SEOへの影響

```typescript
// CSRの問題: 検索エンジンがコンテンツを認識できない
// 1. クローラーがHTMLを取得 → 空のdivのみ
// 2. JavaScriptを実行（時間がかかる、失敗する可能性）
// 3. コンテンツが表示される（遅延、または失敗）

// SSRの利点: 検索エンジンが即座にコンテンツを認識
// 1. クローラーがHTMLを取得 → 完全なコンテンツが含まれている
// 2. インデックス可能

// SSGの利点: SSRと同様にSEOに強い
// 1. クローラーがHTMLを取得 → 完全なコンテンツが含まれている
// 2. インデックス可能

// 実際のSEOスコアへの影響
// CSR: SEOスコア = 60/100（コンテンツが認識されない）
// SSR: SEOスコア = 95/100（コンテンツが完全に認識される）
// SSG: SEOスコア = 95/100（コンテンツが完全に認識される）
```

## まとめ

Next.jsのレンダリング戦略は、それぞれ異なる特徴とユースケースを持っています。適切な戦略を選択することで、パフォーマンスとユーザー体験を最適化できます。

**推奨事項:**

- **新規プロジェクト**: App Routerを使用し、デフォルトでサーバーコンポーネント（SSR）を活用
- **SEOが重要**: SSRまたはSSGを使用
- **初回表示速度が重要**: SSGまたはISRを使用
- **ユーザー固有のデータ**: SSRを使用
- **リアルタイム性が必要**: CSRを使用
- **ハイブリッドアプローチ**: サーバーコンポーネントとクライアントコンポーネントを組み合わせる

これらのベストプラクティスを守ることで、パフォーマンスが高く、SEOに強く、ユーザー体験の優れたNext.jsアプリケーションを構築できます。
