---
title: "MVVMについて"
label: "MVVMについて"
---

MVVMをレストランに例える 🍽️
MVVMは、まるでレストランのキッチンのようなものです。このレストランでは、役割が明確に分担されています。

View (ビュー) - レストランのホール 👨‍🍳

役割: お客様（ユーザー）と直接やり取りし、料理（データ）を美しく提供する役割です。

仕事: メニューを見せたり、注文を受けたり、料理をテーブルに運んだりします。

MVVMでは: Viewは単に表示するだけの役割です。ロジック（どうやって料理を作るか）は知りません。

Model (モデル) - 食材の倉庫 📦

役割: 料理の元となる食材（データ）を管理し、下ごしらえする場所です。

仕事: 食材を新鮮に保ち、必要な時に提供できるように準備します。

MVVMでは: Modelはアプリケーションのデータとビジネスロジックそのものです。UIとは完全に切り離されており、データの保存や計算を行います。

ViewModel (ビューモデル) - 料理長 🧑‍🍳

役割: ホール（View）と倉庫（Model）の中間役です。

仕事: ホールから受けた注文（ユーザーの操作）を元に、倉庫（Model）から食材を調達し、レシピ通りに料理（表示用のデータ）を調理します。料理ができたら、自動的にホールに「料理ができたよ！」と知らせます。

MVVMでは: ViewModelは、Viewに表示するデータを扱いやすい形に整形し、Viewからの指示でModelを操作します。ViewModel内のデータが変更されると、データバインディングという魔法の糸🪄で結ばれたViewの表示が自動的に更新されます。

なぜこの分担が重要なのか？
このレストランの例で考えると、MVVMのメリットがより明確になります。

分業がしやすい 🤝

ホールの担当者（View）は、料理の作り方（ViewModel）や食材の管理（Model）について知る必要がありません。

料理長（ViewModel）も、料理をどうテーブルに並べるか（View）をいちいち気にする必要はありません。

これにより、チームの各メンバーが自分の専門分野に集中できます。

テストが簡単 🧪

料理長（ViewModel）は、実際にテーブル（View）がなくても、レシピ（ロジック）通りに料理（データ）が作れるかテストできます。

「チーズケーキのレシピをテストして」と言われれば、実際にケーキを焼く代わりに、冷蔵庫にある材料と手順だけで、論理的に正しいかを確認できます。

変更に強い 💪

メニュー（View）を変えたい場合でも、料理長（ViewModel）は同じレシピ（ロジック）を使い続けられます。例えば、ホールでメニュー表が紙からタブレットに変わっても、料理長はいつも通りの仕事をするだけです。

これは、ViewとViewModelが疎結合（お互いについて最低限しか知らない関係）であるためです。

MVVMにおける「データバインディング」の魔法 🪄
MVVMの最も重要な概念がデータバインディングです。これは、ViewModelのデータとViewの表示を自動的に同期させる仕組みです。

ViewがViewModelを監視 👀

ViewはViewModelに対して、「あなたのデータが変わったら教えてね」と伝えておきます。

ViewModelがデータを更新すると、Viewは自動でその変更を検知し、画面を再描画します。

双方向バインディング

ユーザーがView（例えば、テキストボックス）に何かを入力すると、そのデータは自動的にViewModelに反映されます。

この双方向のやり取りが、コードをよりシンプルに、そして柔軟にします。

MVVMとデータバインディングのイメージ

MVVMがよく使われる技術スタック 💻
MVVMは、以下の特徴を持つフレームワークと特に相性が良いです。

React: ステート管理（useState, Reduxなど）がViewModelの役割を担います。

Vue.js: dataプロパティやcomputedプロパティがViewModelの機能を果たし、双方向データバインディングが組み込まれています。

SwiftUI (iOS): ObservableObjectやStateといった仕組みがMVVMの概念を強力にサポートしています。

Jetpack Compose (Android): Stateオブジェクトを利用して、ViewとViewModelの連携をスムーズにします。

MVVMは、UIを持つアプリケーションの複雑さを管理するための強力な設計パターンです。役割分担を明確にすることで、開発者はより効率的に、そしてより高品質なコードを書くことができます。