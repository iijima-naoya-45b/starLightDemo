---
title: "パフォーマンス最適化"
label: "パフォーマンス最適化"
---

## パフォーマンス最適化

Spring Bootアプリケーションのパフォーマンスを向上させるための様々な手法について解説します。

### キャッシング

#### Spring Cacheの設定

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration());
        
        return builder.build();
    }
    
    private RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
}
```

#### キャッシュの使用

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Cacheable(value = "users", key = "#id")
    public User findById(Long id) {
        return userRepository.findById(id).orElseThrow();
    }
    
    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }
    
    @CacheEvict(value = "users", allEntries = true)
    public void clearAllCache() {
        // すべてのキャッシュをクリア
    }
    
    @CachePut(value = "users", key = "#user.id")
    public User saveUser(User user) {
        return userRepository.save(user);
    }
}
```

### 非同期処理

#### @Asyncの使用

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}

@Service
public class EmailService {
    
    @Async("taskExecutor")
    public CompletableFuture<Void> sendEmail(String to, String subject, String body) {
        // メール送信処理
        return CompletableFuture.completedFuture(null);
    }
    
    @Async
    public void sendNotification(String message) {
        // 通知送信処理
    }
}
```

#### CompletableFutureの使用

```java
@Service
public class OrderService {
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private ShippingService shippingService;
    
    public OrderResult processOrder(Order order) {
        CompletableFuture<PaymentResult> paymentFuture = 
            CompletableFuture.supplyAsync(() -> paymentService.process(order));
        
        CompletableFuture<InventoryResult> inventoryFuture = 
            CompletableFuture.supplyAsync(() -> inventoryService.reserve(order));
        
        CompletableFuture<ShippingResult> shippingFuture = 
            paymentFuture.thenCompose(payment -> 
                inventoryFuture.thenCompose(inventory -> 
                    CompletableFuture.supplyAsync(() -> 
                        shippingService.schedule(order)
                    )
                )
            );
        
        return shippingFuture.join();
    }
}
```

### データベースクエリの最適化

#### バッチ処理

```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void saveUsersInBatch(List<User> users) {
        int batchSize = 50;
        for (int i = 0; i < users.size(); i += batchSize) {
            List<User> batch = users.subList(i, Math.min(i + batchSize, users.size()));
            userRepository.saveAll(batch);
            userRepository.flush();
            userRepository.clear();
        }
    }
}
```

**application.properties:**

```properties
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
```

#### プロジェクションの使用

```java
public interface UserSummary {
    String getName();
    String getEmail();
}

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u.name as name, u.email as email FROM User u")
    List<UserSummary> findAllSummaries();
}
```

#### ページングの最適化

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public Page<UserDTO> getUsers(int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return userRepository.findAll(pageable)
            .map(this::convertToDTO);
    }
    
    // カウントクエリを最適化
    @Query(value = "SELECT u FROM User u",
           countQuery = "SELECT COUNT(u.id) FROM User u")
    Page<User> findAllOptimized(Pageable pageable);
}
```

### コネクションプールの設定

**application.properties:**

```properties
# HikariCPの設定
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
```

### ロギングの最適化

```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <logger name="org.hibernate.SQL" level="DEBUG"/>
    <logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE"/>
    
    <root level="INFO">
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

### まとめ

パフォーマンス最適化のポイント：

- **キャッシング**: 頻繁にアクセスされるデータをキャッシュ
- **非同期処理**: 時間のかかる処理を非同期で実行
- **クエリ最適化**: バッチ処理、プロジェクション、ページング
- **コネクションプール**: 適切なプールサイズの設定
- **ロギング**: 適切なログレベルの設定

これらの最適化により、アプリケーションのパフォーマンスを大幅に向上させることができます。


