---
title: Javaの基本概念と補足
sidebar:
    label: Javaの基本概念と補足
---

# Javaの基本概念と補足

Java開発で重要な基本概念と、実務で役立つ補足情報を詳しく解説します。

## 1. JVM（Java Virtual Machine）の理解

### JVMの役割

JVMは、Javaバイトコードを実行する仮想マシンです。プラットフォーム非依存性を実現する重要なコンポーネントです。

```java
// Javaソースコード (.java)
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// コンパイル後 (.class - バイトコード)
// JVMがこのバイトコードを実行
```

### JVMのメモリ構造

```
┌─────────────────┐
│   Method Area   │ クラス情報、定数プール
├─────────────────┤
│   Heap Area     │ オブジェクトのインスタンス
├─────────────────┤
│  Stack Area     │ メソッド呼び出し、ローカル変数
├─────────────────┤
│   PC Register   │ 現在実行中の命令のアドレス
├─────────────────┤
│ Native Method   │ ネイティブメソッドのスタック
└─────────────────┘
```

## 2. ガベージコレクション（GC）

### GCの種類

#### 1. Serial GC
- シングルスレッドで動作
- 小規模アプリケーション向け

```bash
java -XX:+UseSerialGC MyApp
```

#### 2. Parallel GC
- マルチスレッドで動作
- スループット重視

```bash
java -XX:+UseParallelGC MyApp
```

#### 3. G1 GC（推奨）
- 大規模ヒープに適している
- 低レイテンシを実現

```bash
java -XX:+UseG1GC MyApp
```

#### 4. ZGC / Shenandoah
- 超大規模ヒープ向け
- 超低レイテンシ

```bash
java -XX:+UseZGC MyApp
```

### GCの監視

```bash
# GCログの出力
java -Xlog:gc*:file=gc.log MyApp

# JVM統計情報の表示
jstat -gc <pid> 1000
```

## 3. クラスローダー

### クラスローダーの階層

```java
// ブートストラップクラスローダー
// → rt.jarなどのコアクラス

// 拡張クラスローダー
// → $JAVA_HOME/lib/ext/のクラス

// アプリケーションクラスローダー
// → クラスパス上のクラス
```

### カスタムクラスローダー

```java
public class CustomClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // カスタムロジックでクラスを読み込む
        byte[] classData = loadClassData(name);
        return defineClass(name, classData, 0, classData.length);
    }
    
    private byte[] loadClassData(String className) {
        // クラスファイルを読み込む処理
        return null;
    }
}
```

## 4. アクセス修飾子の詳細

### アクセス修飾子の種類

```java
public class AccessModifiers {
    public int publicField;        // どこからでもアクセス可能
    protected int protectedField;  // 同じパッケージ + サブクラス
    int packagePrivateField;      // 同じパッケージのみ
    private int privateField;      // 同じクラス内のみ
    
    public void publicMethod() {}
    protected void protectedMethod() {}
    void packagePrivateMethod() {}
    private void privateMethod() {}
}
```

### 実務での使い分け

```java
// 良い例: カプセル化
public class User {
    private String name;  // 直接アクセスを防ぐ
    private int age;
    
    // ゲッター/セッターで制御
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        }
    }
}
```

## 5. 例外処理のベストプラクティス

### チェック例外と非チェック例外

```java
// チェック例外（必ず処理が必要）
public void readFile() throws IOException {
    FileReader file = new FileReader("file.txt");
    // IOExceptionが発生する可能性がある
}

// 非チェック例外（RuntimeException）
public void divide(int a, int b) {
    if (b == 0) {
        throw new IllegalArgumentException("除数は0にできません");
    }
    return a / b;
}
```

### 例外処理の実装例

```java
public class ExceptionHandling {
    public void processFile(String filename) {
        try {
            FileReader file = new FileReader(filename);
            // ファイル処理
        } catch (FileNotFoundException e) {
            logger.error("ファイルが見つかりません: " + filename, e);
            throw new BusinessException("ファイル処理に失敗しました", e);
        } catch (IOException e) {
            logger.error("IOエラーが発生しました", e);
            throw new BusinessException("ファイル処理に失敗しました", e);
        } finally {
            // リソースのクリーンアップ
        }
    }
}
```

## 6. コレクションフレームワークの補足

### コレクションの選択基準

| 用途 | 推奨コレクション | 理由 |
|------|----------------|------|
| 順序保持、重複可 | `ArrayList` | 高速なランダムアクセス |
| 順序保持、重複不可 | `LinkedHashSet` | 挿入順序を保持 |
| 重複不可、順序不要 | `HashSet` | 高速な検索 |
| ソート済み | `TreeSet` | 自動ソート |
| キー・バリュー | `HashMap` | 高速な検索 |
| スレッドセーフ | `ConcurrentHashMap` | 並行処理対応 |

### 実務での使用例

```java
// ArrayListの使用
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");
names.forEach(System.out::println);

// HashMapの使用
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 87);
scores.get("Alice"); // 95

// Stream APIとの組み合わせ
List<String> filtered = names.stream()
    .filter(name -> name.startsWith("A"))
    .collect(Collectors.toList());
```

## 7. ラムダ式とストリームAPIの補足

### ラムダ式の実装例

```java
// 従来の書き方
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.compareTo(b);
    }
});

// ラムダ式
Collections.sort(names, (a, b) -> a.compareTo(b));

// メソッド参照
Collections.sort(names, String::compareTo);
```

### ストリームAPIの実装例

```java
List<User> users = Arrays.asList(
    new User("Alice", 25),
    new User("Bob", 30),
    new User("Charlie", 25)
);

// フィルタリングとマッピング
List<String> names = users.stream()
    .filter(user -> user.getAge() >= 25)
    .map(User::getName)
    .collect(Collectors.toList());

// グループ化
Map<Integer, List<User>> byAge = users.stream()
    .collect(Collectors.groupingBy(User::getAge));

// 集計
int totalAge = users.stream()
    .mapToInt(User::getAge)
    .sum();
```

## 8. 実務でのベストプラクティス

### 命名規則

```java
// クラス名: パスカルケース
public class UserService {}

// メソッド名: キャメルケース
public void getUserById() {}

// 定数: 大文字 + アンダースコア
public static final int MAX_RETRY_COUNT = 3;

// プライベートフィールド: キャメルケース（_プレフィックス可）
private String userName;
private int _retryCount;
```

### コードの可読性

```java
// 悪い例
public void p(String n, int a) {
    if (a > 18) {
        System.out.println(n + " is adult");
    }
}

// 良い例
public void printAdultStatus(String name, int age) {
    if (isAdult(age)) {
        System.out.println(name + " is adult");
    }
}

private boolean isAdult(int age) {
    return age > 18;
}
```

### リソース管理

```java
// try-with-resourcesの使用（推奨）
try (FileReader file = new FileReader("file.txt");
     BufferedReader reader = new BufferedReader(file)) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    logger.error("ファイル読み込みエラー", e);
}
```

## 9. よくある問題と解決策

### 問題1: NullPointerException

**解決策**: Optionalの使用

```java
// 悪い例
String name = user.getName();
int length = name.length(); // NullPointerExceptionの可能性

// 良い例
Optional<String> name = Optional.ofNullable(user.getName());
int length = name.map(String::length).orElse(0);
```

### 問題2: メモリリーク

**解決策**: リソースの適切な解放

```java
// コレクションのクリア
List<Object> largeList = new ArrayList<>();
// 使用後
largeList.clear();
largeList = null;

// ストリームのクローズ
try (InputStream is = new FileInputStream("file.txt")) {
    // 処理
} // 自動的にクローズされる
```

### 問題3: スレッドセーフティ

**解決策**: 適切な同期機構の使用

```java
// ConcurrentHashMapの使用
Map<String, Integer> map = new ConcurrentHashMap<>();

// synchronizedの使用
public synchronized void increment() {
    count++;
}

// AtomicIntegerの使用
private AtomicInteger count = new AtomicInteger(0);
public void increment() {
    count.incrementAndGet();
}
```

これで、Javaの基本概念と実務で役立つ補足情報を理解できるようになりました。
