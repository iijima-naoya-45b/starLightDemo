---
title: "よくあるエラーとトラブルシューティング"
label: "よくあるエラーとトラブルシューティング"
---

## よくあるエラーとトラブルシューティング

Spring Boot開発でよく遭遇するエラーとその解決方法について、実践的な対処法を解説します。

### コンパイルエラー

#### エラー1: パッケージが見つからない

**エラーメッセージ:**
```
package com.example does not exist
```

**原因:**
- パッケージ構造が正しくない
- インポート文が間違っている

**解決方法:**

```java
// 正しいパッケージ宣言
package com.example.myapp.service;

// 正しいインポート
import com.example.myapp.model.User;
import com.example.myapp.repository.UserRepository;
```

**確認事項:**
- ファイルのパスがパッケージ名と一致しているか
- `src/main/java/com/example/myapp/service/UserService.java` → `package com.example.myapp.service;`

---

#### エラー2: シンボルが見つからない

**エラーメッセージ:**
```
cannot find symbol: class UserRepository
```

**原因:**
- クラスが存在しない
- インポートが不足している
- Lombokのアノテーションが正しく処理されていない

**解決方法:**

```java
// 1. インポートを確認
import com.example.myapp.repository.UserRepository;

// 2. Lombokを使用している場合、IDEでアノテーション処理を有効化
// IntelliJ IDEA: Settings → Build → Compiler → Annotation Processors → Enable annotation processing

// 3. Maven/Gradleでクリーンビルド
// Maven
./mvnw clean compile

// Gradle
./gradlew clean build
```

---

### 実行時エラー

#### エラー3: Beanが見つからない（NoSuchBeanDefinitionException）

**エラーメッセージ:**
```
No qualifying bean of type 'com.example.myapp.service.UserService' available
```

**原因:**
- `@Service`、`@Component`などのアノテーションが不足
- コンポーネントスキャンの対象外
- プロファイルが一致しない

**解決方法:**

```java
// 1. アノテーションを追加
@Service  // または @Component
public class UserService {
    // ...
}

// 2. コンポーネントスキャンの範囲を確認
@SpringBootApplication
@ComponentScan(basePackages = "com.example.myapp")
public class MyAppApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyAppApplication.class, args);
    }
}

// 3. プロファイルを確認
@Profile("dev")  // プロファイルが一致しているか確認
@Service
public class DevUserService {
    // ...
}
```

---

#### エラー4: 循環依存（Circular Dependency）

**エラーメッセージ:**
```
The dependencies of some of the beans in the application context form a cycle
```

**原因:**
- クラスAがクラスBに依存し、クラスBがクラスAに依存している

**解決方法:**

```java
// 悪い例: 循環依存
@Service
public class UserService {
    @Autowired
    private OrderService orderService;  // UserService → OrderService
}

@Service
public class OrderService {
    @Autowired
    private UserService userService;  // OrderService → UserService（循環）
}

// 解決方法1: コンストラクタインジェクション + @Lazy
@Service
public class UserService {
    private final OrderService orderService;
    
    public UserService(@Lazy OrderService orderService) {
        this.orderService = orderService;
    }
}

// 解決方法2: インターフェースを使用
public interface UserServiceInterface {
    User findById(Long id);
}

@Service
public class UserService implements UserServiceInterface {
    // ...
}

@Service
public class OrderService {
    private final UserServiceInterface userService;  // インターフェースに依存
    
    public OrderService(UserServiceInterface userService) {
        this.userService = userService;
    }
}

// 解決方法3: アーキテクチャの見直し（推奨）
// 共通のサービス層を作成するか、イベント駆動アーキテクチャを使用
```

---

#### エラー5: トランザクションが機能しない

**エラーメッセージ:**
```
Transaction is not active
```

**原因:**
- `@Transactional`が適用されていない
- 同じクラス内のメソッド呼び出し
- 例外がキャッチされている

**解決方法:**

```java
// 悪い例: 同じクラス内のメソッド呼び出し
@Service
public class UserService {
    
    public void createUser(UserCreateRequest request) {
        saveUser(request);  // @Transactionalが効かない
    }
    
    @Transactional
    public void saveUser(UserCreateRequest request) {
        userRepository.save(new User());
    }
}

// 解決方法1: メソッドを統合
@Service
public class UserService {
    
    @Transactional
    public void createUser(UserCreateRequest request) {
        userRepository.save(new User());
    }
}

// 解決方法2: 自己注入（非推奨）
@Service
public class UserService {
    
    @Autowired
    private UserService self;  // プロキシ経由で呼び出す
    
    public void createUser(UserCreateRequest request) {
        self.saveUser(request);  // プロキシ経由なので@Transactionalが効く
    }
    
    @Transactional
    public void saveUser(UserCreateRequest request) {
        userRepository.save(new User());
    }
}

// 解決方法3: 例外を再スロー
@Service
public class UserService {
    
    @Transactional
    public void createUser(UserCreateRequest request) {
        try {
            userRepository.save(new User());
        } catch (Exception e) {
            log.error("Error", e);
            throw e;  // 例外を再スローしないとロールバックされない
        }
    }
}
```

---

### データベース関連エラー

#### エラー6: テーブルが見つからない

**エラーメッセージ:**
```
Table 'mydb.users' doesn't exist
```

**原因:**
- テーブルが作成されていない
- `ddl-auto`設定が間違っている
- マイグレーションが実行されていない

**解決方法:**

```properties
# application.properties
# 開発環境: 自動でテーブルを作成
spring.jpa.hibernate.ddl-auto=create-drop

# 本番環境: マイグレーションツールを使用
spring.jpa.hibernate.ddl-auto=validate

# Flywayを使用する場合
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
```

```java
// エンティティクラスを確認
@Entity
@Table(name = "users")  // テーブル名を明示的に指定
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    // ...
}
```

---

#### エラー7: カラムが見つからない

**エラーメッセージ:**
```
Column 'user_name' doesn't exist
```

**原因:**
- カラム名の不一致
- `@Column`アノテーションの設定ミス

**解決方法:**

```java
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // カラム名を明示的に指定
    @Column(name = "user_name", nullable = false, length = 100)
    private String name;
    
    // スネークケースとキャメルケースの変換設定
    // application.properties
    // spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
}
```

---

#### エラー8: 接続エラー

**エラーメッセージ:**
```
Connection refused. Check that the hostname and port are correct
```

**原因:**
- データベースサーバーが起動していない
- 接続情報が間違っている
- ファイアウォールの設定

**解決方法:**

```properties
# 接続情報を確認
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
spring.datasource.username=myuser
spring.datasource.password=mypassword

# 接続タイムアウトを設定
spring.datasource.hikari.connection-timeout=30000
```

```bash
# データベースサーバーの状態を確認
# PostgreSQL
pg_isready -h localhost -p 5432

# MySQL
mysqladmin ping -h localhost -u root -p
```

---

### HTTP関連エラー

#### エラー9: 404 Not Found

**エラーメッセージ:**
```
404 Not Found
```

**原因:**
- URLパスが間違っている
- コントローラーのマッピングが間違っている
- コンテキストパスの設定

**解決方法:**

```java
// コントローラーのマッピングを確認
@RestController
@RequestMapping("/api/users")  // ベースパス
public class UserController {
    
    @GetMapping("/{id}")  // GET /api/users/{id}
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        // ...
    }
}

// application.propertiesでコンテキストパスを確認
server.servlet.context-path=/api
```

**デバッグ方法:**

```java
@RestController
@RequestMapping("/api/users")
@Slf4j
public class UserController {
    
    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        log.info("GET /api/users/{} called", id);  // ログで確認
        // ...
    }
}
```

---

#### エラー10: 400 Bad Request

**エラーメッセージ:**
```
400 Bad Request
```

**原因:**
- リクエストボディの形式が間違っている
- バリデーションエラー
- 必須パラメータが不足

**解決方法:**

```java
// バリデーションエラーの詳細を確認
@RestController
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex) {
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });
        
        ErrorResponse errorResponse = new ErrorResponse(
            "Validation failed", errors);
        return ResponseEntity.badRequest().body(errorResponse);
    }
}

// DTOクラスでバリデーションを確認
public class UserCreateRequest {
    
    @NotBlank(message = "名前は必須です")
    @Size(max = 100, message = "名前は100文字以内で入力してください")
    private String name;
    
    @NotBlank(message = "メールアドレスは必須です")
    @Email(message = "有効なメールアドレスを入力してください")
    private String email;
}
```

---

#### エラー11: 500 Internal Server Error

**エラーメッセージ:**
```
500 Internal Server Error
```

**原因:**
- 未処理の例外
- NullPointerException
- データベースエラー

**解決方法:**

```java
// グローバル例外ハンドラーを実装
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        log.error("Unexpected error occurred", ex);
        
        ErrorResponse errorResponse = new ErrorResponse(
            "Internal server error", 
            ex.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(errorResponse);
    }
    
    @ExceptionHandler(NullPointerException.class)
    public ResponseEntity<ErrorResponse> handleNullPointerException(
            NullPointerException ex) {
        log.error("NullPointerException occurred", ex);
        
        ErrorResponse errorResponse = new ErrorResponse(
            "Null pointer exception", 
            "A required value is null");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(errorResponse);
    }
}
```

---

### パフォーマンス関連エラー

#### エラー12: OutOfMemoryError

**エラーメッセージ:**
```
java.lang.OutOfMemoryError: Java heap space
```

**原因:**
- メモリ不足
- 大量のデータ処理
- メモリリーク

**解決方法:**

```bash
# JVMのメモリ設定を変更
java -Xms512m -Xmx2048m -jar myapp.jar

# または、application.propertiesで設定（Spring Boot）
spring.jvm.arguments=-Xms512m -Xmx2048m
```

```java
// 大量データの処理を最適化
@Service
public class UserService {
    
    // 悪い例: 全件取得
    public List<User> getAllUsers() {
        return userRepository.findAll();  // メモリ不足の原因
    }
    
    // 良い例: ページネーション
    public Page<User> getAllUsers(Pageable pageable) {
        return userRepository.findAll(pageable);
    }
    
    // 良い例: ストリーム処理
    @Transactional(readOnly = true)
    public void processAllUsers() {
        try (Stream<User> users = userRepository.findAllStream()) {
            users.forEach(this::processUser);
        }
    }
}
```

---

### デバッグテクニック

#### ログレベルの変更

```properties
# デバッグ用にログレベルを変更
logging.level.com.example.myapp=DEBUG
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

#### ブレークポイントの設定

```java
@Service
@Slf4j
public class UserService {
    
    public User createUser(UserCreateRequest request) {
        log.debug("Creating user: {}", request);  // ブレークポイントを設定
        
        // 変数の値を確認
        User user = new User();
        user.setName(request.getName());
        
        return userRepository.save(user);
    }
}
```

#### スタックトレースの確認

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        // スタックトレースをログに出力
        log.error("Exception occurred", ex);
        
        // 開発環境ではスタックトレースを含める
        String message = ex.getMessage();
        if (isDevEnvironment()) {
            message += "\n" + getStackTrace(ex);
        }
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(new ErrorResponse("Error", message));
    }
}
```

### まとめ

よくあるエラーと解決方法：

1. **コンパイルエラー**: パッケージ構造とインポートを確認
2. **Beanエラー**: アノテーションとコンポーネントスキャンを確認
3. **循環依存**: アーキテクチャの見直しまたは`@Lazy`を使用
4. **トランザクション**: メソッド呼び出し方法と例外処理を確認
5. **データベースエラー**: 接続情報とテーブル定義を確認
6. **HTTPエラー**: マッピングとバリデーションを確認
7. **パフォーマンス**: メモリ設定とデータ処理方法を最適化

適切なエラーハンドリングとデバッグテクニックにより、問題を迅速に解決できます。

