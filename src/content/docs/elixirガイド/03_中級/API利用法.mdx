---
title: "API利用法"
label: "API利用法"
---

## `Elixir`での`API`プロジェクトの作成

`Elixir`の`Phoenix`フレームワークを使用して、`API`専用のプロジェクトを作成する方法を紹介します。以下の手順で、データベースを使用する場合と使用しない場合のプロジェクトを作成できます。

### データベースありの`API`モード

データベースに接続してデータの永続化を伴う`API`を作成する場合、`Phoenix`プロジェクトは`Ecto`をデフォルトで含みます。

1. **プロジェクトの作成**
   - コマンド: `mix phx.new my_api --no-html --no-webpack`
   - 説明: `HTML`やフロントエンドのビルドツールを含めず、バックエンド`API`に特化した構造を作成します。`Ecto`と`PostgreSQL`への接続設定も含まれます。

2. **リソースの生成とデータベース操作**
   - `mix ecto.create`: `config/dev.exs`の設定に基づいて、データベースを作成します。
   - `mix phx.gen.json Accounts User users name:string`: `API`エンドポイントの作成を自動化します。`Accounts`というコンテキスト、`User`というモデル、および`users`テーブルのマイグレーションファイルを生成します。
   - `mix ecto.migrate`: データベースマイグレーションを実行し、`users`テーブルを作成します。

#### フォルダ構成（データベースあり）

```
my_api/
├── config/
├── lib/
│   ├── my_api/
│   │   ├── accounts/
│   │   │   ├── user.ex      # Userモデル
│   │   │   └── accounts.ex  # コンテキストモジュール
│   │   └── repo.ex          # データベースリポジトリ
│   └── my_api_web/
│       ├── controllers/
│       │   └── user_controller.ex # APIコントローラー
│       └── router.ex          # ルーター
├── priv/
│   └── repo/
│       └── migrations/        # マイグレーションファイル
└── ...
```

### データベースなしの`API`モード

データベースを使用しない、純粋な`API`（例：外部`API`のプロキシやインメモリデータのみを扱う場合）を作成するには、プロジェクト生成時に`--no-ecto`フラグを追加します。

1. **プロジェクトの作成**
   - コマンド: `mix phx.new my_api --no-html --no-webpack --no-ecto`
   - 説明: `Ecto`関連の依存関係や設定ファイルを一切含みません。

2. **APIエンドポイントの手動作成**
   - `lib/my_api_web/controllers/api_controller.ex`: `API`エンドポイントのロジックを記述します。
   - `lib/my_api_web/router.ex`: そのコントローラーへのルーティングを設定します。

#### フォルダ構成（データベースなし）

```
my_api/
├── config/
├── lib/
│   └── my_api_web/
│       ├── controllers/
│       │   └── api_controller.ex  # 手動で作成したコントローラー
│       └── router.ex            # ルーター
├── priv/
└── ...
```

### 比較と使い分け

| 特徴 | データベースあり`API`モード | データベースなし`API`モード |
|------|--------------------------|--------------------------|
| 主な用途 | データの永続化が必要な`API`（例：ユーザー管理、ブログ投稿） | データベースを必要としない`API`（例：外部`API`のプロキシ、計算サービス） |
| プロジェクト作成 | `mix phx.new --no-html --no-webpack` | `mix phx.new --no-html --no-webpack --no-ecto` |
| データ永続化 | ✅ `Ecto`によるデータベース接続 | ❌ データベース接続なし |
| リソース作成 | ✅ `phx.gen.json`ジェネレーターが利用可能 | ❌ ジェネレーターは利用不可、手動で作成 |
| 利点 | 複雑なデータモデルを効率的に管理できる | 不要な依存関係がなく、軽量でシンプル |
| 考慮点 | 開発環境のセットアップ（`Postgres`など）が必要 | すべての`API`エンドポイントを手動で定義する必要がある |

どちらのモードを選択するかは、`API`の目的によって決まります。データの読み書きが必要な場合はデータベースあり、外部サービスとの連携や単純な処理に特化する場合はデータベースなしが適しています。

### `Endpoint`と`Router`の役割

`Phoenix`フレームワークでは、`Web`リクエストの処理が`Endpoint`と`Router`という2つの主要なコンポーネントによって管理されます。これらは、リクエストの「入り口」と「交通整理役」として機能し、コードの役割を明確に分離します。

1. **`Endpoint`: アプリケーションの玄関口 🚪**
   - `Endpoint`は、`Web`リクエストがアプリケーションに到達する最初のポイントです。アプリケーションの`HTTP`サーバーとして機能し、ネットワーク接続の受付、初期設定、そしてすべてのリクエストをルーターに渡す役割を担います。

   - **主な役割**: 接続の受付、`SSL`証明書の管理、リクエストの基本的なロギング、そして`Plug`パイプラインの開始点。

   - **設定例 (`config/config.exs`)**: ポート番号や`SSL`設定が定義されます。

   ```elixir
   # config/config.exs
   config :my_app, MyAppWeb.Endpoint,
     http: [port: 4000],
     url: [host: "localhost"],
     plug: MyAppWeb.Router
   ```

2. **`Router`: リクエストの交通整理役 🚦**
   - `Router`は、`Endpoint`が受け取ったリクエストを、`URL`に基づいて適切なコントローラーや処理ロジックに振り分ける役割を担います。

   - **主な役割**: `URL`と`HTTP`メソッド（`GET`, `POST`など）を対応するコントローラーの関数にマッピングすること。

   - **設定例 (`lib/my_app_web/router.ex`)**:

   ```elixir
   # lib/my_app_web/router.ex
   defmodule MyAppWeb.Router do
     use Phoenix.Router
     import Plug.Conn

     pipeline :api do
       plug :accepts, ["json"]
       plug Plug.Parsers, parsers: [:json]
     end

     scope "/api", MyAppWeb do
       pipe_through :api

       get "/users", UserController, :index
     end
   end
   ```

### `WebSocket`通信：リアルタイムな連携 💬

`Phoenix`は、`Phoenix Channels`という抽象化を通じて、`WebSocket`通信を簡単に実装できます。これにより、リアルタイムな双方向通信（例：チャット、ライブ更新）が可能になります。これは、従来の`REST API`だけでは実現が難しい、`Elixir`の強みが特に活かされる部分です。

#### `WebSocket`の仕組みと`React`との連携

- **`Channel`の定義**: バックエンドで、特定のトピック（例: `room:lobby`）を購読するための`Channel`モジュールを定義します。このモジュールは、クライアントからのメッセージを受け取り、処理し、ブロードキャストするロジックを保持します。

- **`Socket`の定義**: `lib/my_app_web/endpoint.ex`ファイルで、`WebSocket`接続の入り口となる`Socket`を定義します。これは、クライアントが接続すべきエンドポイントになります。

- **`React`クライアントでの接続**: `React`アプリケーションでは、`phoenix.js`ライブラリを使用してバックエンドに接続します。

#### `React`クライアントとの疎通例

**バックエンド (`Elixir`)**

まず、`WebSocket`の入り口となるソケットを`Endpoint`に定義します。

```elixir
# lib/my_app_web/endpoint.ex
defmodule MyAppWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :my_app
  # ... 省略

  socket "/socket", MyAppWeb.UserSocket,
    websocket: true,
    longpoll: false
  
  # ... 省略
end
```

次に、メッセージを処理する`Channel`を定義します。

```elixir
# lib/my_app_web/channels/room_channel.ex
defmodule MyAppWeb.RoomChannel do
  use Phoenix.Channel

  # クライアントがトピックに参加する際に呼び出される
  def join("room:" <> _room_name, _params, socket) do
    {:ok, socket}
  end

  # クライアントからのメッセージを受信（`"new_msg"`イベント）
  def handle_in("new_msg", %{"body" => body}, socket) do
    # 受け取ったメッセージを同じトピックのすべてのクライアントにブロードキャスト
    broadcast!(socket, "new_msg", %{body: body, sender: "Server"})
    {:noreply, socket}
  end
end
```

**フロントエンド (`React`)**

`phoenix.js`ライブラリを使用して、バックエンドの`WebSocket`エンドポイントに接続し、チャネルを購読します。

```javascript
import { Socket } from "phoenix";

// WebSocketエンドポイントに接続
let socket = new Socket("ws://localhost:4000/socket", {});
socket.connect();

// 特定のトピックを購読するチャネルを作成
let channel = socket.channel("room:lobby", {});

// チャネルへの接続を試行
channel.join()
  .receive("ok", resp => console.log("Joined successfully", resp))
  .receive("error", resp => console.log("Unable to join", resp));

// バックエンドからメッセージを受信
channel.on("new_msg", payload => {
  console.log("Received a new message:", payload.body);
});

// ボタンクリックなどでバックエンドにメッセージを送信
document.getElementById("send-btn").onclick = () => {
  let message = "Hello from React!";
  channel.push("new_msg", {body: message});
};
```

この連携により、リアルタイムなチャットアプリや、バックエンドでのデータ変更を即座にフロントエンドに反映するライブ更新機能などを、効率的に構築できます。

これらの例は、`Elixir`と`Phoenix`が`API`開発とリアルタイム通信の両方にいかに強力なツールであるかを示しています。ご質問があれば、いつでもお尋ねください。

### `Phoenix`における`SPA`の疎通方法

`Elixir`の`Phoenix`フレームワークで、`React`や`Vue.js`のような**`SPA`（Single Page Application）**と連携する場合、主に2つの方法があります。これらの方法は、それぞれ異なるユースケースと利点を持っています。

1. **`API`サーバーとして疎通する（`REST API` & `WebSocket`）**
   - これは最も一般的で柔軟なアプローチです。`Phoenix`は`API`サーバーとして機能し、`SPA`は`Fetch API`や`Axios`、`phoenix.js`ライブラリなどを使ってバックエンドと通信します。

   - **特徴**
     - 完全な分離: フロントエンドとバックエンドが完全に独立しています。これにより、それぞれを別のチームで開発したり、異なる技術スタックで構築したりすることが可能です。
     - 汎用性: モバイルアプリや他のクライアント（`IoT`デバイスなど）とも同じ`API`を共有できます。
     - 認証: `JWT`（`JSON Web Token`）やセッションベースの認証など、標準的な`API`認証手法を使用します。
     - リアルタイム通信: `Phoenix Channels`を通じて`WebSocket`通信を実装し、チャットやリアルタイム通知などの機能を簡単に構築できます。

   - **実装例**
     - `Phoenix`プロジェクトの作成: `API`専用プロジェクトとして作成します。

     ```bash
     mix phx.new my_api --no-html --no-webpack --no-live
     ```

     - `API`エンドポイント: `REST API`として、`JSON`形式でデータをやり取りします。

     ```elixir
     # lib/my_app_web/router.ex
     scope "/api", MyAppWeb do
       pipe_through :api

       get "/posts", PostController, :index
       post "/posts", PostController, :create
     end
     ```

     - `React`からのデータ取得: `React`側では、`useEffect`フックなどを使って`API`を呼び出します。

     ```javascript
     import React, { useEffect, useState } from 'react';

     function PostsList() {
       const [posts, setPosts] = useState([]);

       useEffect(() => {
         fetch('/api/posts')
           .then(response => response.json())
           .then(data => setPosts(data));
       }, []);

       return (
         <div>
           {posts.map(post => (
             <div key={post.id}>{post.title}</div>
           ))}
         </div>
       );
     }
     ```

2. **`Phoenix LiveView`で疎通する**
   - `LiveView`は、`Elixir`と`Phoenix`の最も革新的な機能の一つです。`HTML`をサーバー側でレンダリングし、`WebSocket`を通じて`HTML`の差分だけをクライアントに送信することで、`JavaScript`をほとんど書かずにリッチな`UI`を実現します。

   - **特徴**
     - サーバーサイドレンダリング: サーバー側でレンダリングを行うため、初期表示が高速です。
     - 開発体験: サーバー側の`Elixir`コードだけで`UI`のロジックを完結できるため、`JavaScript`と`Elixir`の間でコンテキストスイッチが不要になり、開発効率が大幅に向上します。
     - リアルタイム性: ユーザーアクションは即座にサーバーに送信され、`UI`の更新が`WebSocket`経由でリアルタイムに反映されます。
     - ステート管理: アプリケーションの状態（`State`）はすべてサーバーで管理されるため、フロントエンドの複雑なステート管理ライブラリ（`Redux`, `Zustand`など）が不要になります。

   - **実装例**
     - プロジェクトの作成: `LiveView`を含めてプロジェクトを作成します。

     ```bash
     mix phx.new my_app
     ```

     - `LiveView`コンポーネント: ユーザーがクリックするとカウントが増えるシンプルなカウンターの例です。

     ```elixir
     # lib/my_app_web/live/counter_live.ex
     defmodule MyAppWeb.CounterLive do
       use MyAppWeb, :live_view

       @impl true
       def mount(_params, _session, socket) do
         {:ok, assign(socket, count: 0)}
       end

       @impl true
       def handle_event("increment", _params, socket) do
         {:noreply, update(socket, :count, &(&1 + 1))}
       end
     end
     ```

     - `HTML`テンプレート: ボタンがクリックされると、`phx-click`属性がサーバーの`handle_event`関数を呼び出します。

     ```html
     <div>
       <p>Count is: <%= @count %></p>
       <button phx-click="increment">Increment</button>
     </div>
     ```

     `LiveView`は、この`HTML`テンプレートをサーバーでレンダリングし、`WebSocket`を通じて変更を効率的に同期します。これにより、クライアント側では`HTML`と少量の`JavaScript`だけで、動的な`UI`が実現されます。

### どちらを選ぶべきか？

- **`API`サーバーとして疎通**:
  - **おすすめのケース**: `React Native`のようなモバイルアプリや、複数の異なるクライアントをサポートする必要がある場合。フロントエンドとバックエンドの技術を完全に分離したいチーム。

- **`LiveView`**:
  - **おすすめのケース**: 開発チームが`Elixir`に精通しており、フロントエンドの複雑なステート管理やビルドプロセスを避けたい場合。リアルタイム性が重要で、`UI`を迅速に構築する必要がある場合。

`LiveView`は、`SPA`の複雑さをサーバー側で吸収することで、開発の生産性を劇的に向上させます。しかし、既存の`React`プロジェクトと統合する場合は`API`アプローチが適しています。どちらの方法も、`Elixir`の並行処理の強みを活かし、スケーラブルなアプリケーションを構築できます。