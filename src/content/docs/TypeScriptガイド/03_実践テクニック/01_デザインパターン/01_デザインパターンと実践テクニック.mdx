---
title: "ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨å®Ÿè·µãƒ†ã‚¯ãƒ‹ãƒƒã‚¯"
label: "ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨å®Ÿè·µãƒ†ã‚¯ãƒ‹ãƒƒã‚¯"
---

## ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨å®Ÿè·µãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ ğŸ’¡

TypeScriptã¯ã€å˜ãªã‚‹JavaScriptã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚»ãƒƒãƒˆã§ã¯ãªãã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­è¨ˆã‚’æ”¹å–„ã™ã‚‹ãŸã‚ã®å¤šãã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã“ã§ã¯ã€TypeScriptã‚’æœ€å¤§é™ã«æ´»ç”¨ã™ã‚‹ãŸã‚ã®ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨å®Ÿè·µçš„ãªãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’è§£èª¬ã—ã¾ã™ã€‚

### ãªãœãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒé‡è¦ãªã®ã‹

#### å‹å®‰å…¨ãªè¨­è¨ˆã®ä¾¡å€¤

**å•é¡Œã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ï¼ˆå‹å®‰å…¨æ€§ã®æ¬ å¦‚ï¼‰:**

```typescript
// å•é¡Œ: å‹æƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã‚‹
function processOrder(order) {
  if (order.status === "pending") {
    return order.total * 0.1;  // 10%ã®æ‰‹æ•°æ–™
  }
  return 0;
}

// å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼ã®å¯èƒ½æ€§
processOrder({ status: "completed", total: "100" });  // NaNãŒè¿”ã•ã‚Œã‚‹
```

**è§£æ±º: å‹å®‰å…¨ãªè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³**

```typescript
// è§£æ±º: å‹å®‰å…¨ãªè¨­è¨ˆ
type OrderStatus = "pending" | "completed" | "cancelled";

interface Order {
  id: number;
  status: OrderStatus;
  total: number;
}

function processOrder(order: Order): number {
  if (order.status === "pending") {
    return order.total * 0.1;
  }
  return 0;
}

// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã‚‹
processOrder({ status: "completed", total: "100" });  // ã‚¨ãƒ©ãƒ¼: totalã¯numberå‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹
```

### 1. ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã®ä½¿ã„åˆ†ã‘

`interface`ã¨`type`ã¯ã©ã¡ã‚‰ã‚‚å‹ã‚’å®šç¾©ã§ãã¾ã™ãŒã€ãã‚Œãã‚Œã®ç‰¹æ€§ã‚’ç†è§£ã—ã¦ä½¿ã„åˆ†ã‘ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

- **interface**: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ã‚„ã€ã‚¯ãƒ©ã‚¹ãŒå®Ÿè£…ã™ã¹ãã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ä½¿ã„ã¾ã™ã€‚
  - **æ‹¡å¼µæ€§**: `extends`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã€ä»–ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æ‹¡å¼µã§ãã¾ã™ã€‚
  - **å®£è¨€ã®ãƒãƒ¼ã‚¸**: åŒã˜åå‰ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’è¤‡æ•°å®£è¨€ã™ã‚‹ã¨ã€ãã‚Œã‚‰ãŒè‡ªå‹•çš„ã«ãƒãƒ¼ã‚¸ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒæ—¢å­˜ã®å‹ã«æ–°ã—ã„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ ã—ãŸã„å ´åˆã«ä¾¿åˆ©ã§ã™ã€‚

- **type (å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹)**: ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã€ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã€ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³å‹ãªã©ã€ä»»æ„ã®å‹ã«åˆ¥åã‚’ä»˜ã‘ãŸã„å ´åˆã«æœ€é©ã§ã™ã€‚
  - **æŸ”è»Ÿæ€§**: `interface`ã§ã¯ã§ããªã„è¤‡é›‘ãªå‹ï¼ˆä¾‹ï¼šãƒ¦ãƒ‹ã‚ªãƒ³å‹ï¼‰ã‚’å®šç¾©ã§ãã¾ã™ã€‚

#### ä½¿ã„åˆ†ã‘ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹:

ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’å®šç¾©ã™ã‚‹å ´åˆã€ã‚¯ãƒ©ã‚¹ã®ã‚ˆã†ã«æŒ¯ã‚‹èˆã†æ§‹é€ ã‚’å®šç¾©ã™ã‚‹ãªã‚‰`interface`ã€å˜ãªã‚‹å‹ã®åˆ¥åã¨ã—ã¦ä½¿ã†ãªã‚‰`type`ã‚’æ¤œè¨ã—ã¾ã™ã€‚

ä¸€èˆ¬çš„ã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹å®šç¾©ã«ã¯**`interface`ã‚’å„ªå…ˆã—ã€ä»–ã®å‹ï¼ˆãƒ¦ãƒ‹ã‚ªãƒ³å‹ãªã©ï¼‰ã‚’çµ„ã¿åˆã‚ã›ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã«`type`ã‚’ä½¿ç”¨**ã™ã‚‹ã®ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚

### 2. é–¢æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰

é–¢æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã¯ã€åŒã˜é–¢æ•°åã§ç•°ãªã‚‹å¼•æ•°ã®å‹ã‚„æ•°ã«å¯¾å¿œã™ã‚‹æ©Ÿèƒ½ã§ã™ã€‚TypeScriptã¯ã€å‘¼ã³å‡ºã—æ™‚ã®å¼•æ•°ã«åŸºã¥ã„ã¦ã€ã©ã®é–¢æ•°ã®å®Ÿè£…ãŒä½¿ç”¨ã•ã‚Œã‚‹ã‹ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«åˆ¤æ–­ã—ã¾ã™ã€‚

```typescript
// ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚·ã‚°ãƒãƒãƒ£
function add(x: string, y: string): string;
function add(x: number, y: number): number;

// å®Ÿè£…ã‚·ã‚°ãƒãƒãƒ£ï¼ˆã‚ˆã‚Šæ±ç”¨çš„ãªå‹ã‚’ä½¿ç”¨ï¼‰
function add(x: any, y: any): any {
  return x + y;
}

// å‘¼ã³å‡ºã—ä¾‹
const sum1 = add("hello", " world"); // string å‹ã¨æ¨è«–
const sum2 = add(1, 2);              // number å‹ã¨æ¨è«–
```

ã“ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã¯ã€æŸ”è»ŸãªAPIã‚’è¨­è¨ˆã™ã‚‹éš›ã«å½¹ç«‹ã¡ã¾ã™ã€‚

### 3. å‹ã‚¬ãƒ¼ãƒ‰ (Type Guards)

å‹ã‚¬ãƒ¼ãƒ‰ã¯ã€ç‰¹å®šã®ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§å¤‰æ•°ã®å‹ã‚’çµã‚Šè¾¼ã‚€ãŸã‚ã®æŠ€è¡“ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€`unknown`ã‚„ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã‚’å®‰å…¨ã«æ‰±ãˆã¾ã™ã€‚

- **`typeof` å‹ã‚¬ãƒ¼ãƒ‰**: ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
- **`instanceof` å‹ã‚¬ãƒ¼ãƒ‰**: ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
- **ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å‹ã‚¬ãƒ¼ãƒ‰**: é–‹ç™ºè€…ãŒç‹¬è‡ªã®å‹ãƒã‚§ãƒƒã‚¯é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚

#### ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å‹ã‚¬ãƒ¼ãƒ‰ã®ä¾‹:

```typescript
interface Cat { meow(): void; }
interface Dog { bark(): void; }

type Pet = Cat | Dog;

// ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å‹ã‚¬ãƒ¼ãƒ‰é–¢æ•°
function isCat(pet: Pet): pet is Cat {
  return (pet as Cat).meow !== undefined;
}

function speak(pet: Pet) {
  if (isCat(pet)) {
    pet.meow(); // ã“ã“ã§ã¯ pet ã¯ Cat å‹ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹
  } else {
    (pet as Dog).bark(); // ã‚‚ã—ãã¯ pet.bark();
  }
}
```

`pet is Cat`ã¨ã„ã†æ§‹æ–‡ãŒã€ã“ã®é–¢æ•°ãŒ`true`ã‚’è¿”ã™å ´åˆã«`pet`ãŒ`Cat`å‹ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚

**å®Ÿè·µçš„ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹:**

```typescript
// ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹1: APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‹ã‚¬ãƒ¼ãƒ‰
interface SuccessResponse<T> {
  success: true;
  data: T;
}

interface ErrorResponse {
  success: false;
  error: string;
}

type ApiResponse<T> = SuccessResponse<T> | ErrorResponse;

function isSuccess<T>(response: ApiResponse<T>): response is SuccessResponse<T> {
  return response.success === true;
}

async function fetchUser(id: number): Promise<ApiResponse<User>> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

const result = await fetchUser(1);
if (isSuccess(result)) {
  // ã“ã“ã§ã¯resultã¯SuccessResponse<User>å‹
  console.log(result.data.name);  // å‹å®‰å…¨
} else {
  // ã“ã“ã§ã¯resultã¯ErrorResponseå‹
  console.error(result.error);  // å‹å®‰å…¨
}
```

### 4. ãƒ–ãƒ©ãƒ³ãƒ‰å‹ï¼ˆNominal Typingï¼‰ã®å®Ÿè£…

TypeScriptã¯æ§‹é€ çš„éƒ¨åˆ†å‹ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ãŒã€æ™‚ã«ã¯åç›®å‹ï¼ˆNominal Typingï¼‰ãŒå¿…è¦ãªå ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãƒ–ãƒ©ãƒ³ãƒ‰å‹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€åŒã˜æ§‹é€ ã‚’æŒã¤å‹ã‚’åŒºåˆ¥ã§ãã¾ã™ã€‚

**å®Ÿè·µçš„ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹:**

```typescript
// ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹1: å˜ä½ã®åŒºåˆ¥
type USD = number & { readonly __brand: unique symbol };
type EUR = number & { readonly __brand: unique symbol };

function createUSD(amount: number): USD {
  return amount as USD;
}

function createEUR(amount: number): EUR {
  return amount as EUR;
}

function addUSD(a: USD, b: USD): USD {
  return (a + b) as USD;
}

const usd1 = createUSD(100);
const usd2 = createUSD(50);
const eur1 = createEUR(100);

addUSD(usd1, usd2);  // OK
addUSD(usd1, eur1);   // ã‚¨ãƒ©ãƒ¼: EURå‹ã¯USDå‹ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œãªã„

// ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹2: IDã®å‹å®‰å…¨æ€§
type UserId = number & { readonly __brand: unique symbol };
type OrderId = number & { readonly __brand: unique symbol };

function createUserId(id: number): UserId {
  return id as UserId;
}

function getUserById(id: UserId): User {
  // å®Ÿè£…
  return {} as User;
}

const userId = createUserId(1);
const orderId = 1 as OrderId;

getUserById(userId);   // OK
getUserById(orderId);  // ã‚¨ãƒ©ãƒ¼: OrderIdå‹ã¯UserIdå‹ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œãªã„
```

### 5. å‹å®‰å…¨ãªã‚¤ãƒ™ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ 

**å®Ÿè·µçš„ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹:**

```typescript
// ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹: å‹å®‰å…¨ãªã‚¤ãƒ™ãƒ³ãƒˆã‚¨ãƒŸãƒƒã‚¿ãƒ¼
type EventMap = {
  userCreated: { id: number; name: string };
  userUpdated: { id: number; changes: Partial<User> };
  userDeleted: { id: number };
};

class TypedEventEmitter {
  private listeners: {
    [K in keyof EventMap]?: Array<(data: EventMap[K]) => void>;
  } = {};

  on<K extends keyof EventMap>(
    event: K,
    listener: (data: EventMap[K]) => void
  ): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(listener);
  }

  emit<K extends keyof EventMap>(event: K, data: EventMap[K]): void {
    const listeners = this.listeners[event];
    if (listeners) {
      listeners.forEach(listener => listener(data));
    }
  }
}

const emitter = new TypedEventEmitter();

// å‹å®‰å…¨ãªã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
emitter.on("userCreated", (data) => {
  console.log(data.id, data.name);  // å‹å®‰å…¨
});

emitter.on("userUpdated", (data) => {
  console.log(data.id, data.changes);  // å‹å®‰å…¨
});

// ã‚¨ãƒ©ãƒ¼: ã‚¤ãƒ™ãƒ³ãƒˆåã¨ãƒ‡ãƒ¼ã‚¿ã®å‹ãŒä¸€è‡´ã—ãªã„
emitter.emit("userCreated", { id: 1, changes: {} });  // ã‚¨ãƒ©ãƒ¼
```

### 6. å‹å®‰å…¨ãªçŠ¶æ…‹ç®¡ç†ãƒ‘ã‚¿ãƒ¼ãƒ³

**å®Ÿè·µçš„ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹:**

```typescript
// ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹: å‹å®‰å…¨ãªã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³
type State = 
  | { type: "idle" }
  | { type: "loading" }
  | { type: "success"; data: User }
  | { type: "error"; error: string };

type StateType = State["type"];

class StateMachine {
  private state: State = { type: "idle" };

  transition(newState: State): void {
    this.state = newState;
  }

  getState(): State {
    return this.state;
  }

  // å‹å®‰å…¨ãªçŠ¶æ…‹ãƒã‚§ãƒƒã‚¯
  isIdle(): this is { state: { type: "idle" } } {
    return this.state.type === "idle";
  }

  isSuccess(): this is { state: { type: "success"; data: User } } {
    return this.state.type === "success";
  }
}

const machine = new StateMachine();

if (machine.isSuccess()) {
  // ã“ã“ã§ã¯state.dataãŒUserå‹ã¨ã—ã¦æ¨è«–ã•ã‚Œã‚‹
  console.log(machine.getState().data.name);  // å‹å®‰å…¨
}
```

### 7. å‹å®‰å…¨ãªãƒ“ãƒ«ãƒ€ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³

**å®Ÿè·µçš„ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹:**

```typescript
// ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹: å‹å®‰å…¨ãªã‚¯ã‚¨ãƒªãƒ“ãƒ«ãƒ€ãƒ¼
interface QueryBuilder<T> {
  where<K extends keyof T>(
    field: K,
    operator: "eq" | "ne" | "gt" | "lt",
    value: T[K]
  ): QueryBuilder<T>;
  orderBy<K extends keyof T>(field: K, direction: "asc" | "desc"): QueryBuilder<T>;
  limit(count: number): QueryBuilder<T>;
  build(): string;
}

class TypedQueryBuilder<T> implements QueryBuilder<T> {
  private conditions: string[] = [];
  private orderByClause: string = "";
  private limitClause: string = "";

  where<K extends keyof T>(
    field: K,
    operator: "eq" | "ne" | "gt" | "lt",
    value: T[K]
  ): this {
    this.conditions.push(`${String(field)} ${operator} ${value}`);
    return this;
  }

  orderBy<K extends keyof T>(field: K, direction: "asc" | "desc"): this {
    this.orderByClause = `ORDER BY ${String(field)} ${direction}`;
    return this;
  }

  limit(count: number): this {
    this.limitClause = `LIMIT ${count}`;
    return this;
  }

  build(): string {
    const where = this.conditions.length > 0 
      ? `WHERE ${this.conditions.join(" AND ")}` 
      : "";
    return [where, this.orderByClause, this.limitClause]
      .filter(Boolean)
      .join(" ");
  }
}

interface User {
  id: number;
  name: string;
  age: number;
}

const query = new TypedQueryBuilder<User>()
  .where("age", "gt", 18)      // å‹å®‰å…¨: ageã¯numberå‹
  .where("name", "eq", "Alice") // å‹å®‰å…¨: nameã¯stringå‹
  .orderBy("age", "desc")
  .limit(10)
  .build();
```

### 8. å‹å®‰å…¨ãªä¾å­˜æ€§æ³¨å…¥

**å®Ÿè·µçš„ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹:**

```typescript
// ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹: å‹å®‰å…¨ãªDIã‚³ãƒ³ãƒ†ãƒŠ
type Constructor<T> = new (...args: any[]) => T;

class Container {
  private services = new Map<Constructor<any>, any>();

  register<T>(ctor: Constructor<T>, instance: T): void {
    this.services.set(ctor, instance);
  }

  resolve<T>(ctor: Constructor<T>): T {
    const instance = this.services.get(ctor);
    if (!instance) {
      throw new Error(`Service ${ctor.name} not found`);
    }
    return instance as T;
  }
}

class UserService {
  getUsers(): User[] {
    return [];
  }
}

class OrderService {
  getOrders(): Order[] {
    return [];
  }
}

const container = new Container();
container.register(UserService, new UserService());
container.register(OrderService, new OrderService());

// å‹å®‰å…¨ãªè§£æ±º
const userService = container.resolve(UserService);
const users = userService.getUsers();  // User[]å‹ã¨ã—ã¦æ¨è«–
```

### ã¾ã¨ã‚

ã“ã‚Œã‚‰ã®å®Ÿè·µçš„ãªãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’ç¿’å¾—ã™ã‚‹ã“ã¨ã§ã€TypeScriptã®å¼·åŠ›ãªå‹ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ•ãƒ«æ´»ç”¨ã—ã€ã‚ˆã‚Šå …ç‰¢ã§ä¿å®ˆã—ã‚„ã™ã„ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã§ãã¾ã™ã€‚

**ã‚·ãƒ‹ã‚¢ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¨ã—ã¦è€ƒæ…®ã™ã¹ãç‚¹:**

1. **å‹å®‰å…¨æ€§ã¨æŸ”è»Ÿæ€§ã®ãƒãƒ©ãƒ³ã‚¹**: éåº¦ã«å³æ ¼ãªå‹å®šç¾©ã¯é–‹ç™ºé€Ÿåº¦ã‚’ä½ä¸‹ã•ã›ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: è¤‡é›‘ãªå‹ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ã«å½±éŸ¿ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
3. **ãƒãƒ¼ãƒ ã®ç†è§£åº¦**: ãƒãƒ¼ãƒ å…¨ä½“ãŒç†è§£ã§ãã‚‹ãƒ¬ãƒ™ãƒ«ã®å‹å®šç¾©ã‚’å¿ƒãŒã‘ã‚‹
4. **æ®µéšçš„ãªå°å…¥**: æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã«æ®µéšçš„ã«å‹å®‰å…¨æ€§ã‚’è¿½åŠ ã™ã‚‹