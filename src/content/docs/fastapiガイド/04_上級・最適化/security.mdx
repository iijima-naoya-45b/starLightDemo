---
title: "FastAPIã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–"
label: "FastAPIã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–"
---

æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚æä¾›ã•ã‚ŒãŸå†…å®¹ã‚’ã€ã‚ˆã‚Šç°¡æ½”ã«ã€ã‹ã¤ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å……å®Ÿã•ã›ã‚‹å½¢ã§å†æ§‹æˆã—ã¾ã™ã€‚

## `FastAPI`ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–

`FastAPI`ã¯ã€ãã®è¨­è¨ˆè‡ªä½“ãŒã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«å„ªã‚Œã¦ã„ã¾ã™ãŒã€ã‚ˆã‚Šå …ç‰¢ãª`API`ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«ã¯ã€è¿½åŠ ã®å¯¾ç­–ãŒä¸å¯æ¬ ã§ã™ã€‚ä»¥ä¸‹ã«ã€ä¸»è¦ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã‚’å…·ä½“çš„ãªã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¨å…±ã«è§£èª¬ã—ã¾ã™ã€‚

1. **èªè¨¼ã¨èªå¯ (`Authentication & Authorization`) ğŸ”‘**
   - `API`ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¿è­·ã™ã‚‹ãŸã‚ã€`OAuth2`ã¨`JWT`ï¼ˆ`JSON Web Tokens`ï¼‰ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚`FastAPI`ã®**`Depends`**æ©Ÿèƒ½ã‚’ä½¿ã†ã“ã¨ã§ã€èªè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«å®Ÿè£…ã§ãã¾ã™ã€‚

   - **å®Ÿè£…ä¾‹**:
     - ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã¨`JWT`ãƒˆãƒ¼ã‚¯ãƒ³ç™ºè¡Œã®ãŸã‚ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆã€‚
     - èªè¨¼ãŒå¿…è¦ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«`Depends(get_current_user)`ã‚’é©ç”¨ã—ã¦ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä¿è­·ã—ã¾ã™ã€‚

     ```python
     # main.py
     from fastapi import Depends, FastAPI, HTTPException, status
     from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
     from jose import JWTError, jwt

     app = FastAPI()
     SECRET_KEY = "your-super-secret-key"
     ALGORITHM = "HS256"
     oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

     def authenticate_user(username, password):
         if username == "test" and password == "password":
             return {"username": "test"}
         return None

     def create_access_token(data: dict):
         return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)

     def get_current_user(token: str = Depends(oauth2_scheme)):
         try:
             payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
             username: str = payload.get("sub")
             if username is None:
                 raise HTTPException(status_code=401, detail="Invalid token")
             return username
         except JWTError:
             raise HTTPException(status_code=401, detail="Invalid token")

     @app.post("/token")
     async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
         user = authenticate_user(form_data.username, form_data.password)
         if not user:
             raise HTTPException(status_code=401)
         access_token = create_access_token(data={"sub": user["username"]})
         return {"access_token": access_token, "token_type": "bearer"}

     @app.get("/users/me")
     async def read_users_me(current_user: str = Depends(get_current_user)):
         return {"username": current_user}
     ```

2. **`CORS`ï¼ˆã‚ªãƒªã‚¸ãƒ³é–“ãƒªã‚½ãƒ¼ã‚¹å…±æœ‰ï¼‰ ğŸŒ**
   - æ‚ªæ„ã®ã‚ã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‹ã‚‰ã®`API`åˆ©ç”¨ã‚’é˜²ããŸã‚ã®åŸºæœ¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã§ã™ã€‚**`main.py`**ã«`CORSMiddleware`ã‚’èª­ã¿è¾¼ã¿ã€è¨±å¯ã™ã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’è¨­å®šã—ã¾ã™ã€‚

   - **å®Ÿè£…ä¾‹**:

     ```python
     # main.py
     from fastapi import FastAPI
     from fastapi.middleware.cors import CORSMiddleware

     app = FastAPI()

     app.add_middleware(
         CORSMiddleware,
         allow_origins=["https://your-frontend.com", "http://localhost:3000"],
         allow_credentials=True,
         allow_methods=["*"],
         allow_headers=["*"],
     )
     ```

3. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã®é©ç”¨ ğŸ›¡ï¸**
   - `XSS`ã‚„ã‚¯ãƒªãƒƒã‚¯ã‚¸ãƒ£ãƒƒã‚­ãƒ³ã‚°ã‚’é˜²ããŸã‚ã€ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å¼·åŒ–ã™ã‚‹ã‚ˆã†æŒ‡ç¤ºã—ã¾ã™ã€‚`FastAPI`ã®ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã¨ã—ã¦ç°¡å˜ã«é©ç”¨ã§ãã¾ã™ã€‚

   - **å®Ÿè£…ä¾‹**:

     ```python
     # main.py
     from fastapi import FastAPI, Request

     app = FastAPI()

     @app.middleware("http")
     async def add_security_headers(request: Request, call_next):
         response = await call_next(request)
         response.headers["X-Content-Type-Options"] = "nosniff"
         response.headers["X-Frame-Options"] = "DENY"
         response.headers["Content-Security-Policy"] = "default-src 'self'"
         return response
     ```

4. **å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼ã¨ã‚µãƒ‹ã‚¿ã‚¤ã‚º ğŸ§¹**
   - `FastAPI`ã®`Pydantic`ãƒ¢ãƒ‡ãƒ«ã¯ã€å—ã‘å–ã‚‹ãƒ‡ãƒ¼ã‚¿ã®å‹ã‚„æ§‹é€ ã‚’è‡ªå‹•ã§æ¤œè¨¼ã—ã¾ã™ã€‚ã•ã‚‰ã«ã€`bleach`ã®ã‚ˆã†ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ã¦ã€æ‚ªæ„ã®ã‚ã‚‹`HTML`ã‚„ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç„¡å®³åŒ–ï¼ˆã‚µãƒ‹ã‚¿ã‚¤ã‚ºï¼‰ã—ã¾ã™ã€‚

   - **å®Ÿè£…ä¾‹**:

     ```python
     # main.py
     from fastapi import FastAPI
     from pydantic import BaseModel
     import bleach

     app = FastAPI()

     class Post(BaseModel):
         title: str
         content: str

     @app.post("/posts/")
     async def create_post(post: Post):
         sanitized_content = bleach.clean(post.content, tags=[], attributes={})
         return {"title": post.title, "content": sanitized_content}
     ```

5. **ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ â±ï¸**
   - `DoS`ï¼ˆã‚µãƒ¼ãƒ“ã‚¹æ‹’å¦ï¼‰æ”»æ’ƒã‚’é˜²ããŸã‚ã€ä¸€å®šæœŸé–“å†…ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°ã‚’åˆ¶é™ã—ã¾ã™ã€‚`fastapi-limiter`ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨`Redis`ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚

   - **å®Ÿè£…ä¾‹**:

     ```python
     # main.py
     from fastapi import FastAPI, Depends
     from fastapi_limiter import FastAPILimiter
     from fastapi_limiter.depends import RateLimiter
     import redis.asyncio as redis

     app = FastAPI()

     @app.on_event("startup")
     async def startup():
         redis_client = redis.Redis(host='localhost', port=6379, db=0)
         await FastAPILimiter.init(redis_client)

     @app.get("/items", dependencies=[Depends(RateLimiter(times=10, seconds=60))])
     async def read_items():
         return {"message": "Limited access"}
     ```

6. **`SQL`ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã¨`ORM` ğŸ›¡ï¸**
   - æ‚ªæ„ã®ã‚ã‚‹`SQL`ã‚¯ã‚¨ãƒªã®æŒ¿å…¥ã‚’é˜²ããŸã‚ã€`SQLAlchemy`ãªã©ã®`ORM`ï¼ˆ`Object-Relational Mapper`ï¼‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`ORM`ã¯ã€ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’è‡ªå‹•çš„ã«ç”Ÿæˆã™ã‚‹ãŸã‚ã€`SQL`ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒªã‚¹ã‚¯ã‚’å¤§å¹…ã«ä½æ¸›ã—ã¾ã™ã€‚

   - **å®Ÿè£…ä¾‹**:

     ```python
     # main.py
     from fastapi import FastAPI, Depends
     from sqlalchemy import create_engine, Column, Integer, String
     from sqlalchemy.orm import declarative_base, Session, sessionmaker

     app = FastAPI()

     SQLALCHEMY_DATABASE_URL = "sqlite:///./sql_app.db"
     engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
     SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
     Base = declarative_base()

     class User(Base):
         __tablename__ = "users"
         id = Column(Integer, primary_key=True, index=True)
         name = Column(String, index=True)

     Base.metadata.create_all(bind=engine)

     def get_db():
         db = SessionLocal()
         try:
             yield db
         finally:
             db.close()

     @app.post("/users/")
     def create_user(name: str, db: Session = Depends(get_db)):
         db_user = User(name=name)
         db.add(db_user)
         db.commit()
         db.refresh(db_user)
         return db_user
     ```

7. **ç’°å¢ƒå¤‰æ•°ã®æ´»ç”¨ ğŸ”**
   - `SECRET KEY`ã‚„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¨ã„ã£ãŸæ©Ÿå¯†æƒ…å ±ã¯ã€ã‚³ãƒ¼ãƒ‰ã«ç›´æ¥æ›¸ã‹ãšã€ç’°å¢ƒå¤‰æ•°ã¨ã—ã¦ç®¡ç†ã—ã¾ã™ã€‚`python-dotenv`ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†ã¨ã€`.env`ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç°¡å˜ã«ç’°å¢ƒå¤‰æ•°ã‚’èª­ã¿è¾¼ã‚ã¾ã™ã€‚

   - **å®Ÿè£…ä¾‹**:

     ```python
     # .envãƒ•ã‚¡ã‚¤ãƒ«
     SECRET_KEY="your-super-secret-key"
     DATABASE_URL="postgresql://user:password@host/dbname"
     ```

     ```python
     # main.py
     from fastapi import FastAPI
     from dotenv import load_dotenv
     import os

     load_dotenv()

     app = FastAPI()

     SECRET_KEY = os.getenv("SECRET_KEY")
     DB_URL = os.getenv("DATABASE_URL")

     @app.get("/secret")
     async def get_secret():
         if SECRET_KEY:
             return {"message": "Secret key is loaded"}
         return {"message": "Secret key is NOT loaded"}
     ```