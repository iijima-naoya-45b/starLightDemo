---
title: "FastAPIのセキュリティ強化"
label: "FastAPIのセキュリティ強化"
---

承知しました。提供された内容を、より簡潔に、かつサンプルコードを充実させる形で再構成します。

## `FastAPI`のセキュリティ強化

`FastAPI`は、その設計自体がセキュリティに優れていますが、より堅牢な`API`を構築するためには、追加の対策が不可欠です。以下に、主要なセキュリティ対策を具体的なサンプルコードと共に解説します。

1. **認証と認可 (`Authentication & Authorization`) 🔑**
   - `API`エンドポイントへのアクセスを保護するため、`OAuth2`と`JWT`（`JSON Web Tokens`）を組み合わせるのが一般的です。`FastAPI`の**`Depends`**機能を使うことで、認証ロジックをシンプルに実装できます。

   - **実装例**:
     - ユーザー認証と`JWT`トークン発行のためのエンドポイントを作成。
     - 認証が必要なエンドポイントに`Depends(get_current_user)`を適用して、リクエストを保護します。

     ```python
     # main.py
     from fastapi import Depends, FastAPI, HTTPException, status
     from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
     from jose import JWTError, jwt

     app = FastAPI()
     SECRET_KEY = "your-super-secret-key"
     ALGORITHM = "HS256"
     oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

     def authenticate_user(username, password):
         if username == "test" and password == "password":
             return {"username": "test"}
         return None

     def create_access_token(data: dict):
         return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)

     def get_current_user(token: str = Depends(oauth2_scheme)):
         try:
             payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
             username: str = payload.get("sub")
             if username is None:
                 raise HTTPException(status_code=401, detail="Invalid token")
             return username
         except JWTError:
             raise HTTPException(status_code=401, detail="Invalid token")

     @app.post("/token")
     async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
         user = authenticate_user(form_data.username, form_data.password)
         if not user:
             raise HTTPException(status_code=401)
         access_token = create_access_token(data={"sub": user["username"]})
         return {"access_token": access_token, "token_type": "bearer"}

     @app.get("/users/me")
     async def read_users_me(current_user: str = Depends(get_current_user)):
         return {"username": current_user}
     ```

2. **`CORS`（オリジン間リソース共有） 🌐**
   - 悪意のあるドメインからの`API`利用を防ぐための基本的なセキュリティ対策です。**`main.py`**に`CORSMiddleware`を読み込み、許可するドメインを設定します。

   - **実装例**:

     ```python
     # main.py
     from fastapi import FastAPI
     from fastapi.middleware.cors import CORSMiddleware

     app = FastAPI()

     app.add_middleware(
         CORSMiddleware,
         allow_origins=["https://your-frontend.com", "http://localhost:3000"],
         allow_credentials=True,
         allow_methods=["*"],
         allow_headers=["*"],
     )
     ```

3. **セキュリティヘッダーの適用 🛡️**
   - `XSS`やクリックジャッキングを防ぐため、ブラウザにセキュリティを強化するよう指示します。`FastAPI`のミドルウェアとして簡単に適用できます。

   - **実装例**:

     ```python
     # main.py
     from fastapi import FastAPI, Request

     app = FastAPI()

     @app.middleware("http")
     async def add_security_headers(request: Request, call_next):
         response = await call_next(request)
         response.headers["X-Content-Type-Options"] = "nosniff"
         response.headers["X-Frame-Options"] = "DENY"
         response.headers["Content-Security-Policy"] = "default-src 'self'"
         return response
     ```

4. **入力データの検証とサニタイズ 🧹**
   - `FastAPI`の`Pydantic`モデルは、受け取るデータの型や構造を自動で検証します。さらに、`bleach`のようなライブラリを使って、悪意のある`HTML`やスクリプトを無害化（サニタイズ）します。

   - **実装例**:

     ```python
     # main.py
     from fastapi import FastAPI
     from pydantic import BaseModel
     import bleach

     app = FastAPI()

     class Post(BaseModel):
         title: str
         content: str

     @app.post("/posts/")
     async def create_post(post: Post):
         sanitized_content = bleach.clean(post.content, tags=[], attributes={})
         return {"title": post.title, "content": sanitized_content}
     ```

5. **レートリミット ⏱️**
   - `DoS`（サービス拒否）攻撃を防ぐため、一定期間内のリクエスト数を制限します。`fastapi-limiter`ライブラリと`Redis`を組み合わせるのが一般的です。

   - **実装例**:

     ```python
     # main.py
     from fastapi import FastAPI, Depends
     from fastapi_limiter import FastAPILimiter
     from fastapi_limiter.depends import RateLimiter
     import redis.asyncio as redis

     app = FastAPI()

     @app.on_event("startup")
     async def startup():
         redis_client = redis.Redis(host='localhost', port=6379, db=0)
         await FastAPILimiter.init(redis_client)

     @app.get("/items", dependencies=[Depends(RateLimiter(times=10, seconds=60))])
     async def read_items():
         return {"message": "Limited access"}
     ```

6. **`SQL`インジェクションと`ORM` 🛡️**
   - 悪意のある`SQL`クエリの挿入を防ぐため、`SQLAlchemy`などの`ORM`（`Object-Relational Mapper`）を使用します。`ORM`は、プリペアドステートメントを自動的に生成するため、`SQL`インジェクションのリスクを大幅に低減します。

   - **実装例**:

     ```python
     # main.py
     from fastapi import FastAPI, Depends
     from sqlalchemy import create_engine, Column, Integer, String
     from sqlalchemy.orm import declarative_base, Session, sessionmaker

     app = FastAPI()

     SQLALCHEMY_DATABASE_URL = "sqlite:///./sql_app.db"
     engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
     SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
     Base = declarative_base()

     class User(Base):
         __tablename__ = "users"
         id = Column(Integer, primary_key=True, index=True)
         name = Column(String, index=True)

     Base.metadata.create_all(bind=engine)

     def get_db():
         db = SessionLocal()
         try:
             yield db
         finally:
             db.close()

     @app.post("/users/")
     def create_user(name: str, db: Session = Depends(get_db)):
         db_user = User(name=name)
         db.add(db_user)
         db.commit()
         db.refresh(db_user)
         return db_user
     ```

7. **環境変数の活用 🔐**
   - `SECRET KEY`やデータベースのパスワードといった機密情報は、コードに直接書かず、環境変数として管理します。`python-dotenv`ライブラリを使うと、`.env`ファイルから簡単に環境変数を読み込めます。

   - **実装例**:

     ```python
     # .envファイル
     SECRET_KEY="your-super-secret-key"
     DATABASE_URL="postgresql://user:password@host/dbname"
     ```

     ```python
     # main.py
     from fastapi import FastAPI
     from dotenv import load_dotenv
     import os

     load_dotenv()

     app = FastAPI()

     SECRET_KEY = os.getenv("SECRET_KEY")
     DB_URL = os.getenv("DATABASE_URL")

     @app.get("/secret")
     async def get_secret():
         if SECRET_KEY:
             return {"message": "Secret key is loaded"}
         return {"message": "Secret key is NOT loaded"}
     ```