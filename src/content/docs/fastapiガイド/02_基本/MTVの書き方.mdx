---
title: "MTVについて"
label: "MTVについて"
---

## FastAPIにおけるMTVの考え方

FastAPIは、WebアプリケーションのUIをサーバー側でレンダリングするのではなく、APIを提供することに特化しているため、MVC（Model-View-Controller）よりも**MTV（Model-Template-View）**の概念で役割を捉える方がより適切です。

### MTVの各コンポーネント

1. **Model（モデル）** 💾
   - モデルはデータの構造とビジネスロジックを扱います。FastAPIでは、以下のものがモデルに相当します。
   - **Pydanticモデル**: リクエストボディやレスポンスのデータの構造を定義し、自動的なデータ検証を行います。
   - **ORM（SQLAlchemyなど）モデル**: データベースのテーブルとPythonオブジェクトをマッピングし、データベース操作を抽象化します。

2. **Template（テンプレート）** 🖼️
   - テンプレートは、HTMLやUIを指します。FastAPIは主にAPIサーバーとして機能するため、通常、テンプレートは使用しません。クライアント側（例：React、Vue.js）がUIを構築し、FastAPIのAPIからデータを取得します。このため、MTVの観点ではこのレイヤーは存在しないか、クライアントサイドの責務となります。

3. **View（ビュー）** 🖥️
   - ビューは、ユーザーからのリクエストを受け取り、モデルと連携して、最終的なレスポンスを返すロジックを担います。FastAPIにおいては、APIエンドポイント関数がこのビューに相当します。

**主な役割:**

- リクエストからパスパラメータやクエリパラメータを取得します。
- データベースや外部サービスからデータを取得するロジックを呼び出します。
- データの整合性を確認し、エラーを返します。
- Pydanticモデルを使って、レスポンスの形式を定義・保証します。

**例: Viewとしてのエンドポイント関数**

```python
from fastapi import FastAPI, Depends, HTTPException
from typing import List

# 以下はモデルとサービスをインポートしていると仮定
from .schemas import UserResponse
from .services import get_user_from_db

app = FastAPI()

@app.get("/users/{user_id}", response_model=UserResponse)
def get_user_view(user_id: int):
    """
    ユーザー情報を取得するAPIエンドポイント。
    この関数がViewの役割を担う。
    """
    user = get_user_from_db(user_id) # モデルやサービスからデータを取得
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```


この例では、`get_user_view`関数がユーザーIDを受け取り、サービスを介してデータを取得し、レスポンスを返す一連の処理を行っています。

**例: FastAPI でテンプレートを読み込む例**
```py
from fastapi import FastAPI, Request
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse

app = FastAPI()

# templatesディレクトリを指定
templates = Jinja2Templates(directory="app/templates")

@app.get("/", response_class=HTMLResponse)
def read_root(request: Request):
    # index.html をレンダリング
    return templates.TemplateResponse("index.html", {"request": request, "title": "Home"})

```
## 📦 MTVに基づいたファイル構成

MTVの考え方で整理すると、以下のようなディレクトリ構造になります。

```
.
├── app/
│   ├── __init__.py
│   ├── main.py             # View (エンドポイント)
│   ├── schemas/
│   │   ├── __init__.py
│   │   └── user.py         # Model (Pydanticモデル)
│   └── services/
│       ├── __init__.py
│       └── db_service.py   # Model (データベース操作などのロジック)
│       └── templates/      # Template(apiでは使用しない)
│        ├── index.html
│        └── user.html
└── requirements.txt
```

このように、Viewを担うエンドポイント関数、Modelを担うPydanticモデルやサービスロジックを明確に分けることで、アプリケーションの構造をよりシンプルに保つことができます。

### 4. サービスレイヤーの導入 🛠️

MTVモデルをさらに洗練させるために、ビジネスロジックをビュー（エンドポイント）から完全に分離するサービスレイヤーを導入することが推奨されます。これにより、コードの再利用性が高まり、テストが容易になります。

**役割:** データベース操作、外部API呼び出し、複雑な計算など、エンドポイント関数が直接行うべきではない処理を担います。

**メリット:**

- **責務の分離**: ビュー関数はリクエストとレスポンスの処理に集中し、ビジネスロジックはサービスレイヤーに一任されます。
- **再利用性**: 同じビジネスロジックを複数のエンドポイントやタスク（例：バックグラウンドジョブ）で共有できます。
- **テストの容易性**: サービスレイヤーの関数は単独でテストできるため、単体テストの作成が簡単になります。

**例: サービスレイヤーの導入**

`app/services/user_service.py`

```python
from sqlalchemy.orm import Session
from .. import models, schemas

def create_user_service(db: Session, user_data: schemas.UserCreate):
    """
    ユーザー作成のビジネスロジック
    """
    # ユーザーが既に存在するか確認
    existing_user = db.query(models.User).filter_by(email=user_data.email).first()
    if existing_user:
        return None # ユーザーが既に存在する場合はNoneを返す
    
    # 新しいユーザーを作成し、データベースに保存
    db_user = models.User(email=user_data.email, name=user_data.name)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user
```

この`create_user_service`関数は、データベースセッションを受け取り、ユーザー作成に関連するすべてのロジック（検証、保存など）を処理します。

### 5. 依存性注入の活用（リファクタリング） 💉

サービスレイヤーを導入する際、FastAPIの依存性注入を積極的に活用することで、ビューとサービスの連携が非常にスムーズになります。

**役割:** ビュー関数がサービスインスタンスやデータベースセッションを直接作成するのではなく、依存性注入を通じてそれらを受け取るようにします。

**メリット:**

- **疎結合**: ビューは具体的なサービスの実装に依存せず、必要な機能だけを要求できます。
- **テストのモック化**: テスト時に本物のデータベース接続ではなく、モックのサービスやセッションを簡単に注入できます。

**例: サービスレイヤーと依存性注入の統合**

`app/api/v1/endpoints/users.py`（ビューの再構築）

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from ...services import user_service
from ...database import get_db
from ...schemas import UserResponse, UserCreate

router = APIRouter()

@router.post("/users/", response_model=UserResponse, status_code=201)
def create_new_user(user_data: UserCreate, db: Session = Depends(get_db)):
    """
    新しいユーザーを作成
    """
    # 依存性注入を通じてサービス関数を呼び出す
    created_user = user_service.create_user_service(db, user_data)
    if created_user is None:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    return created_user
```

このコードでは、`create_new_user`関数はデータベースセッションを`Depends`で受け取り、そのセッションを`user_service`に渡すだけです。これにより、エンドポイントは純粋なコントローラーとしての役割に集中できます。